webpackHotUpdate(0,{

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Map/Leaflet/Leaflet.vue?vue&type=script&lang=js&":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Map/Leaflet/Leaflet.vue?vue&type=script&lang=js& ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _home_dev_sp_frontend_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/objectSpread2 */ \"./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.filter.js */ \"./node_modules/core-js/modules/es.array.filter.js\");\n/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.map.js */ \"./node_modules/core-js/modules/es.array.map.js\");\n/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vuex */ \"./node_modules/vuex/dist/vuex.esm.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vue2-leaflet */ \"./node_modules/vue2-leaflet/dist/vue2-leaflet.es.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Const__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Const */ \"./src/components/Map/Leaflet/L.Const.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Marker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Marker */ \"./src/components/Map/Leaflet/L.Marker.js\");\n/* harmony import */ var vue2_leaflet_markercluster__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vue2-leaflet-markercluster */ \"./node_modules/vue2-leaflet-markercluster/dist/Vue2LeafletMarkercluster.js\");\n/* harmony import */ var vue2_leaflet_markercluster__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(vue2_leaflet_markercluster__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var vue2_leaflet_polyline_measure__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vue2-leaflet-polyline-measure */ \"./node_modules/vue2-leaflet-polyline-measure/LControlPolylineMeasure.vue\");\n/* harmony import */ var _components_Map_Leaflet_L_Marker_Pulse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Marker.Pulse */ \"./src/components/Map/Leaflet/L.Marker.Pulse.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Marker_Pulse__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_components_Map_Leaflet_L_Marker_Pulse__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _components_Map_Leaflet_proj4__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/Map/Leaflet/proj4 */ \"./src/components/Map/Leaflet/proj4.js\");\n/* harmony import */ var _components_Map_Leaflet_proj4__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_components_Map_Leaflet_proj4__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _components_Map_Leaflet_L_Proj4leaflet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Proj4leaflet */ \"./src/components/Map/Leaflet/L.Proj4leaflet.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Proj4leaflet__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_components_Map_Leaflet_L_Proj4leaflet__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _plugins_sys__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/plugins/sys */ \"./src/plugins/sys.js\");\n/* harmony import */ var _components_Map_Leaflet_Edit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/components/Map/Leaflet/Edit */ \"./src/components/Map/Leaflet/Edit.vue\");\n/* harmony import */ var _components_Map_Leaflet_Menu__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @/components/Map/Leaflet/Menu */ \"./src/components/Map/Leaflet/Menu.vue\");\n/* harmony import */ var _components_Map_Leaflet_Range__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @/components/Map/Leaflet/Range */ \"./src/components/Map/Leaflet/Range.vue\");\n/* harmony import */ var _components_Map_Leaflet_Legend__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @/components/Map/Leaflet/Legend */ \"./src/components/Map/Leaflet/Legend.vue\");\n/* harmony import */ var _components_Map_Leaflet_Logo__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/components/Map/Leaflet/Logo */ \"./src/components/Map/Leaflet/Logo.vue\");\n/* harmony import */ var _components_Map_Leaflet_L_Mix_Key__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Mix.Key */ \"./src/components/Map/Leaflet/L.Mix.Key.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Mix_FeatureColor__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Mix.FeatureColor */ \"./src/components/Map/Leaflet/L.Mix.FeatureColor.js\");\n/* harmony import */ var _components_Map_Leaflet_L_Mix_Control__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @/components/Map/Leaflet/L.Mix.Control */ \"./src/components/Map/Leaflet/L.Mix.Control.js\");\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // устранение бага с путями\n\ndelete leaflet__WEBPACK_IMPORTED_MODULE_4__[\"Icon\"].Default.prototype._getIconUrl;\nleaflet__WEBPACK_IMPORTED_MODULE_4__[\"Icon\"].Default.mergeOptions({\n  iconRetinaUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon-2x.png */ \"./node_modules/leaflet/dist/images/marker-icon-2x.png\"),\n  iconUrl: __webpack_require__(/*! leaflet/dist/images/marker-icon.png */ \"./node_modules/leaflet/dist/images/marker-icon.png\"),\n  shadowUrl: __webpack_require__(/*! leaflet/dist/images/marker-shadow.png */ \"./node_modules/leaflet/dist/images/marker-shadow.png\")\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: \"Leaflet\",\n  mixins: [_components_Map_Leaflet_L_Mix_Key__WEBPACK_IMPORTED_MODULE_19__[\"default\"], _components_Map_Leaflet_L_Mix_FeatureColor__WEBPACK_IMPORTED_MODULE_20__[\"default\"], _components_Map_Leaflet_L_Mix_Control__WEBPACK_IMPORTED_MODULE_21__[\"default\"]],\n  components: {\n    LMap: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LMap\"],\n    LTileLayer: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LTileLayer\"],\n    LMarker: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LMarker\"],\n    LPopup: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LPopup\"],\n    LTooltip: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LTooltip\"],\n    LFeatureGroup: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LFeatureGroup\"],\n    LLayerGroup: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LLayerGroup\"],\n    LGeoJson: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LGeoJson\"],\n    LPolyline: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LPolyline\"],\n    LPolygon: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LPolygon\"],\n    LControlScale: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LControlScale\"],\n    LControl: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LControl\"],\n    LIcon: vue2_leaflet__WEBPACK_IMPORTED_MODULE_5__[\"LIcon\"],\n    'l-marker-cluster': vue2_leaflet_markercluster__WEBPACK_IMPORTED_MODULE_8___default.a,\n    LControlPolylineMeasure: vue2_leaflet_polyline_measure__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n    Edit: _components_Map_Leaflet_Edit__WEBPACK_IMPORTED_MODULE_14__[\"default\"],\n    Menu: _components_Map_Leaflet_Menu__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n    Range: _components_Map_Leaflet_Range__WEBPACK_IMPORTED_MODULE_16__[\"default\"],\n    Legend: _components_Map_Leaflet_Legend__WEBPACK_IMPORTED_MODULE_17__[\"default\"],\n    Logo: _components_Map_Leaflet_Logo__WEBPACK_IMPORTED_MODULE_18__[\"default\"]\n  },\n  data: function data() {\n    return {\n      menu: {\n        visible: false,\n        x: 0,\n        y: 0\n      },\n      hover_map_ind: -1,\n      // MAP_ITEM[hover_map_ind]                   - блок, над которым находится курсор\n      hover_feature_ind: -1,\n      // MAP_ITEM[].FC.features[hover_feature_ind] - фигура, над которой находится курсор\n      mapOptions: {\n        zoomControl: false,\n        zoomSnap: 0.5\n      }\n    };\n  },\n  computed: Object(_home_dev_sp_frontend_node_modules_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, Object(vuex__WEBPACK_IMPORTED_MODULE_3__[\"mapGetters\"])(['MAP_GET_KEY', 'MAP_GET_RANGE_SEL', 'MAP_GET_TILES', 'MAP_GET_TILE', 'MAP_GET_SCALE', 'MAP_GET_MEASURE', 'MAP_GET_CLUSTER', 'MAP_GET_HINT', 'SCRIPT_GET', 'SCRIPT_GET_ITEM_COLOR', 'SCRIPT_GET_ITEM_MARKER', 'SCRIPT_GET_ITEM_LINE', 'SCRIPT_GET_ITEM_POLYGON', 'SCRIPT_GET_ITEM_ICON'])),\n  methods: {\n    // ...mapActions([\n    //   'MAP_ACT_RANGE_TS',\n    // ]),\n    // ===============\n    // MENU\n    // ===============\n    menu_show: function menu_show(e) {\n      var _this = this;\n\n      e.originalEvent.preventDefault();\n      e.originalEvent.stopPropagation();\n      this.menu.visible = false;\n      this.menu.x = e.originalEvent.clientX;\n      this.menu.y = e.originalEvent.clientY;\n      this.$nextTick(function () {\n        _this.menu.visible = true;\n      });\n    },\n    menu_options: function menu_options() {\n      return {\n        visible: this.menu.visible,\n        x: this.menu.x,\n        y: this.menu.y\n      };\n    },\n    // ===============\n    // MEASURE\n    // ===============\n    measure_options: function measure_options() {\n      var COLOR = '#494'; // цвет маркеров и линий\n\n      return {\n        position: 'topleft',\n        unit: 'metres',\n        measureControlClasses: ['select_off'],\n        clearMeasurementsOnStop: true,\n        measureControlTitleOn: 'Рулетка: включить',\n        measureControlTitleOff: 'Рулетка: выключить',\n        tooltipTextDelete: 'Нажмите  SHIFT и кликните мышкой для <b>удаления точки</b>',\n        tooltipTextResume: '<br>Нажмите CTRL и кликните мышкой для <b>продолжения линии</b>',\n        tooltipTextAdd: 'Нажмите CTRL и кликните мышкой для <b>добавления точки</b>',\n        tooltipTextFinish: '',\n        tooltipTextMove: '',\n        backgroundColor: '#dfd',\n        tempLine: {\n          color: COLOR,\n          weight: 2\n        },\n        fixedLine: {\n          color: COLOR,\n          weight: 2\n        },\n        startCircle: {\n          color: COLOR,\n          weight: 1,\n          fillColor: '#0f0',\n          fillOpacity: 1,\n          radius: 5\n        },\n        intermedCircle: {\n          color: COLOR,\n          weight: 1,\n          fillColor: '#ff0',\n          fillOpacity: 1,\n          radius: 5\n        },\n        currentCircle: {\n          color: COLOR,\n          weight: 1,\n          fillColor: '#f0f',\n          fillOpacity: 1,\n          radius: 5\n        },\n        endCircle: {\n          color: COLOR,\n          weight: 1,\n          fillColor: '#f00',\n          fillOpacity: 1,\n          radius: 5\n        }\n      };\n    },\n    // ===============\n    // RANGE\n    // ===============\n    range_options: function range_options() {\n      return {};\n    },\n    // ===============\n    // LEGEND\n    // ===============\n    legend_options: function legend_options() {\n      return {\n        hover_map_ind: this.hover_map_ind,\n        hover_feature_ind: this.hover_feature_ind\n      };\n    },\n    legend_hide: function legend_hide() {\n      this.hover_map_ind = -1;\n      this.hover_feature_ind = -1;\n    },\n    // ===============\n    // MAP\n    // ===============\n    // корректировать данные\n    data_normalize: function data_normalize(map_ind) {\n      // рассчитать цвета (легенда, цвет от значения в группе)\n      this.data_normalize_color(map_ind); // deep copy\n\n      var item = this.SCRIPT_GET_ITEM(map_ind);\n      var fc = item[_components_Map_Leaflet_L_Const__WEBPACK_IMPORTED_MODULE_6__[\"MAP_ITEM\"].FC];\n      fc = JSON.parse(JSON.stringify(fc)); // установить fc.features[ind].ind - порядковый номер фигуры в fc\n\n      for (var ind = 0; ind < fc.features.length; ind++) {\n        fc.features[ind].ind = ind;\n      } // отфильтровать с допустимыми датами\n\n\n      var range_ts = this.MAP_GET_RANGE_SEL;\n\n      if (range_ts[0] > 0 && range_ts[1] > 0) {\n        var item_date;\n        var features = fc.features.filter(function (item) {\n          if (!item.properties.date) return true;\n          item_date = Object(_plugins_sys__WEBPACK_IMPORTED_MODULE_13__[\"datesql_to_ts\"])(item.properties.date);\n          return item_date >= range_ts[0] && item_date <= range_ts[1];\n        });\n        fc.features = features;\n      }\n\n      return fc;\n    },\n    cluster_options: function cluster_options(map_ind) {\n      return {\n        // область при наведении курсора на кластер\n        showCoverageOnHover: true,\n        polygonOptions: {\n          color: this.SCRIPT_GET_ITEM_COLOR(map_ind)\n        },\n        // для последующей коррекции цвета маркеров\n        cluster_color: this.SCRIPT_GET_ITEM_COLOR(map_ind),\n        // увеличение, при котором создавать кластеры\n        disableClusteringAtZoom: this.MAP_GET_CLUSTER ? 17 : 0,\n        // подмена иконки кластера\n        iconCreateFunction: function iconCreateFunction(cluster) {\n          return new L.DivIcon({\n            html: '<div style=\"background-color:' + this.cluster_color + ';\"><span>' + cluster.getChildCount() + '</span></div>',\n            className: 'marker-cluster marker-cluster-small marker-cluster-bg-new',\n            iconSize: new L.Point(40, 40)\n          });\n        },\n        // цвет региона сгруппированного кластера\n        spiderLegPolylineOptions: {\n          weight: 1.5,\n          color: this.cluster_color,\n          opacity: 0.5\n        } // несгрупированные и сгруппированные маркеры одинаковы\n        // singleMarkerMode: true,\n\n      };\n    },\n    geojson_options: function geojson_options(map_ind) {\n      var self = this;\n      return {\n        // для каждого маркера / фигуры\n        onEachFeature: function (feature, layer) {\n          // control-легенда: установка onHover\n          // события повторно вызывают this.data_normalize_color\n          var self = this;\n          layer.on('mouseover', function (e) {\n            self.hover_map_ind = map_ind;\n            self.hover_feature_ind = feature.ind;\n          });\n          layer.on('mouseout', function (e) {\n            if (!e.originalEvent.ctrlKey) self.hover_map_ind = -1;\n            self.hover_feature_ind = -1;\n          }); // подсказка\n\n          if (self.MAP_GET_HINT && feature.properties.hint && feature.properties.hint != '') layer.bindTooltip(\"<div>\" + feature.properties.hint + \"</div>\", {\n            permanent: false,\n            sticky: true\n          }); // тип линии: бегущая пунктирная\n\n          var line = self.SCRIPT_GET_ITEM_LINE(map_ind);\n\n          if (['LineString'].indexOf(feature.geometry.type) > -1 && line != _components_Map_Leaflet_L_Const__WEBPACK_IMPORTED_MODULE_6__[\"MAP_ITEM\"].LINE.DEFAULT) {\n            // 'Polygon'\n            layer.setStyle({\n              'className': line\n            });\n          } // редактирование запрещено - удалить pm - для уменьшения объема вычислений\n\n\n          if (layer.pm) {\n            delete layer.pm;\n          } // тип полигона: color\n          // let polygon = self.SCRIPT_GET_ITEM_POLYGON(map_ind);\n          // if ((['Polygon', ].indexOf(feature.geometry.type)>-1) && (polygon!=POLYGON.DEFAULT)) {\n          // }\n\n        }.bind(this),\n        // стиль маркеров\n        pointToLayer: function pointToLayer(feature, latlng) {\n          return Object(_components_Map_Leaflet_L_Marker__WEBPACK_IMPORTED_MODULE_7__[\"marker_get\"])(latlng, {\n            name: self.SCRIPT_GET_ITEM_MARKER(map_ind),\n            color: self.SCRIPT_GET_ITEM_COLOR(map_ind),\n            icon: self.SCRIPT_GET_ITEM_ICON(map_ind) // size:  self.SCRIPT_GET_ITEM_ICON(map_ind), не реализовано за ненадобностью\n\n          });\n        },\n        // стиль фигур\n        style: function style(feature) {\n          return {\n            weight: 2,\n            opacity: .5,\n            fillOpacity: .3,\n            color: self.SCRIPT_GET_ITEM_COLOR(map_ind),\n            fillColor: feature.color // set in mixin\n\n          };\n        }\n      };\n    },\n    // ===============\n    // СОБЫТИЯ\n    // ===============\n    onMapReady: function onMapReady() {\n      this.map = this.$refs.map.mapObject; //this.onEditReady();\n    },\n    onClick: function onClick(event) {\n      console.log(event.latlng);\n    },\n    onTest2: function onTest2(event) {\n      // var fg = L.featureGroup();\n      // this.map.eachLayer((layer)=>{\n      //   if((layer instanceof L.Path || layer instanceof L.Marker) && layer.pm && layer.pm.edited){\n      //     fg.addLayer(layer);\n      //   }\n      // });\n      // console.log(fg.toGeoJSON());\n      // this.map.pm.getGeomanLayers().forEach(function(layer){\n      //   console.log(1, layer)\n      // });\n      // console.log(2, this.map.pm.getGeomanLayers(true))\n      // this.map.pm.enableDraw('Polygon', {});\n      this.editor_data_set();\n    },\n    // GET BUTTON\n    btn_get_click: function btn_get_click(event) {\n      console.log(this.getDataAsGeoJSON());\n    },\n    getDataAsGeoJSON: function getDataAsGeoJSON() {\n      // create FeatureCollection\n      var geoJSON = {\n        type: 'FeatureCollection',\n        features: []\n      }; // export each layer\n\n      this.map.eachLayer(function (layer) {\n        if (layer._leaflet_id && (layer instanceof L.Path || layer instanceof L.Marker)) {\n          var geoJSONShape = layer.toGeoJSON(16); // для точности\n\n          geoJSONShape.properties = layer.properties;\n          geoJSONShape.id = layer._leaflet_id;\n          geoJSON.features.push(geoJSONShape); // normalize coordinates (> 180/>90)\n          // TODO\n        }\n      });\n      return geoJSON;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vc3JjL2NvbXBvbmVudHMvTWFwL0xlYWZsZXQvTGVhZmxldC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL0xlYWZsZXQudnVlP2QwODIiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTtcIj5cbiAgICA8bC1tYXBcbiAgICAgIHJlZj1cIm1hcFwiXG4gICAgICA6b3B0aW9ucz1cIm1hcE9wdGlvbnNcIlxuICAgICAgc3R5bGU9XCJoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDA7XCJcbiAgICAgIEByZWFkeT1cIm9uTWFwUmVhZHlcIlxuICAgICAgQGNsaWNrPVwib25DbGlja1wiXG4gICAgICBAY29udGV4dG1lbnU9XCJtZW51X3Nob3dcIlxuICAgID5cblxuICAgICAgPCEtLSDQn9Ce0JTQm9Ce0JbQmtCQIC0tPlxuICAgICAgPGwtdGlsZS1sYXllclxuICAgICAgICA6dXJsPVwiTUFQX0dFVF9USUxFU1tNQVBfR0VUX1RJTEVdLnVybFwiXG4gICAgICAgIDphdHRyaWJ1dGlvbj1cIk1BUF9HRVRfVElMRVNbTUFQX0dFVF9USUxFXS5hdHRyXCJcbiAgICAgICAgOnRtcz1cIk1BUF9HRVRfVElMRVNbTUFQX0dFVF9USUxFXS50bXNcIlxuICAgICAgLz5cblxuXG4gICAgICA8IS0tINCk0JjQk9Cj0KDQqyDQmNCXIHN0YXRlLm1hcCAtLT5cbiAgICAgIDxsLWxheWVyLWdyb3VwXG4gICAgICAgIHYtZm9yPVwiKG1hcF9pdGVtLCBtYXBfaW5kKSBpbiBTQ1JJUFRfR0VUXCJcbiAgICAgICAgdi1iaW5kOmtleT1cIk1BUF9HRVRfS0VZKG1hcF9pbmQpXCJcbiAgICAgID5cbiAgICAgICAgPGwtbWFya2VyLWNsdXN0ZXJcbiAgICAgICAgICA6a2V5PVwiTUFQX0dFVF9LRVkobWFwX2luZClcIlxuICAgICAgICAgIDpvcHRpb25zPVwiY2x1c3Rlcl9vcHRpb25zKG1hcF9pbmQpXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxsLWdlby1qc29uXG4gICAgICAgICAgICA6Z2VvanNvbj1cImRhdGFfbm9ybWFsaXplKG1hcF9pbmQpXCJcbiAgICAgICAgICAgIDpvcHRpb25zPVwiZ2VvanNvbl9vcHRpb25zKG1hcF9pbmQpXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L2wtbWFya2VyLWNsdXN0ZXI+XG4gICAgICA8L2wtbGF5ZXItZ3JvdXA+XG5cblxuICAgICAgPCEtLSDQoNCV0JTQkNCa0KLQntCgIC0tPlxuICAgICAgPEVkaXQvPlxuXG4gICAgICA8IS0tINCc0JDQodCo0KLQkNCRIC0tPlxuICAgICAgPGwtY29udHJvbC1zY2FsZVxuICAgICAgICB2LWlmPVwiTUFQX0dFVF9TQ0FMRVwiXG4gICAgICAgIHBvc2l0aW9uPVwiYm90dG9tcmlnaHRcIlxuICAgICAgICA6aW1wZXJpYWw9XCJmYWxzZVwiXG4gICAgICAgIDptZXRyaWM9XCJ0cnVlXCJcbiAgICAgIC8+XG5cbiAgICAgIDwhLS0g0JvQmNCd0JXQmdCa0JAgLS0+XG4gICAgICA8bC1jb250cm9sLXBvbHlsaW5lLW1lYXN1cmVcbiAgICAgICAgdi1pZj1cIk1BUF9HRVRfTUVBU1VSRVwiXG4gICAgICAgIDpvcHRpb25zPVwibWVhc3VyZV9vcHRpb25zKClcIlxuICAgICAgLz5cblxuICAgICAgPCEtLSDQktCg0JXQnNCV0J3QndCe0Jkg0KTQmNCb0KzQotCgIC0tPlxuICAgICAgPFJhbmdlIDpvcHRpb25zPVwicmFuZ2Vfb3B0aW9ucygpXCIvPlxuXG4gICAgICA8IS0tINCb0JXQk9CV0J3QlNCQIC0tPlxuICAgICAgPExlZ2VuZCA6b3B0aW9ucz1cImxlZ2VuZF9vcHRpb25zKClcIi8+XG5cbiAgICAgIDwhLS0g0JvQntCT0J7QotCY0J8gLS0+XG4gICAgICA8TG9nby8+XG5cbiAgICAgIDwhLS0g0KLQldCh0KIgLS0+XG4gICAgICA8IS0tXG4gICAgICA8bC1jb250cm9sXG4gICAgICAgIHYtaWY9XCJ0cnVlXCJcbiAgICAgICAgcG9zaXRpb249XCJ0b3BsZWZ0XCJcbiAgICAgID5cbiAgICAgICAgPHYtYnRuIGNsYXNzPVwiYnV0dG9uLWNvbnRhaW5lciBsZWFmbGV0LWJ1dHRvbnMtY29udHJvbC1idXR0b25cIiBAY2xpY2s9XCJlZGl0b3Jfb25cIj5UZXN0IDE8L3YtYnRuPlxuICAgICAgICA8di1idG4gY2xhc3M9XCJidXR0b24tY29udGFpbmVyIGxlYWZsZXQtYnV0dG9ucy1jb250cm9sLWJ1dHRvblwiIEBjbGljaz1cIm9uVGVzdDJcIj5UZXN0IDI8L3YtYnRuPlxuICAgICAgPC9sLWNvbnRyb2w+XG4gICAgICAtLT5cblxuICAgIDwvbC1tYXA+XG5cbiAgICA8TWVudVxuICAgICAgOm9wdGlvbnM9XCJtZW51X29wdGlvbnMoKVwiXG4gICAgICBAZXZlbnRfZ2V0PVwiYnRuX2dldF9jbGlja1wiXG4gICAgICBAbGVnZW5kX2hpZGU9XCJsZWdlbmRfaGlkZVwiXG4gICAgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG5cblxuPHNjcmlwdD5cblxuaW1wb3J0IHtcbiAgbWFwR2V0dGVycyxcbiAgLy9tYXBBY3Rpb25zLFxufSBmcm9tICd2dWV4JztcblxuaW1wb3J0IHtcbiAgLy9MLFxuICBJY29uLFxuICBsYXRMbmcsXG59IGZyb20gXCJsZWFmbGV0XCI7XG5cbmltcG9ydCB7XG4gIExNYXAsXG4gIExUaWxlTGF5ZXIsXG4gIExNYXJrZXIsXG4gIExQb3B1cCxcbiAgTFRvb2x0aXAsXG4gIExGZWF0dXJlR3JvdXAsXG4gIExMYXllckdyb3VwLFxuICBMR2VvSnNvbixcbiAgTFBvbHlsaW5lLFxuICBMUG9seWdvbixcbiAgTENvbnRyb2xTY2FsZSxcbiAgTENvbnRyb2wsXG4gIExJY29uLFxufSBmcm9tIFwidnVlMi1sZWFmbGV0XCI7XG5cbmltcG9ydCB7IE1BUF9JVEVNIH0gICAgICAgICAgICAgICAgIGZyb20gJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLkNvbnN0JztcbmltcG9ydCB7IG1hcmtlcl9nZXQgfSAgICAgICAgICAgICAgIGZyb20gJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLk1hcmtlcic7XG5cbmltcG9ydCBWdWUyTGVhZmxldE1hcmtlckNsdXN0ZXIgICAgIGZyb20gJ3Z1ZTItbGVhZmxldC1tYXJrZXJjbHVzdGVyJztcbmltcG9ydCBMQ29udHJvbFBvbHlsaW5lTWVhc3VyZSAgICAgIGZyb20gJ3Z1ZTItbGVhZmxldC1wb2x5bGluZS1tZWFzdXJlJztcblxuXG5pbXBvcnQgJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLk1hcmtlci5QdWxzZSc7XG5pbXBvcnQgJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9wcm9qNCdcbmltcG9ydCAnQC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0wuUHJvajRsZWFmbGV0J1xuXG5pbXBvcnQgeyBkYXRlc3FsX3RvX3RzLCB9IGZyb20gJ0AvcGx1Z2lucy9zeXMnO1xuXG5pbXBvcnQgRWRpdCAgICAgICAgICAgIGZyb20gJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9FZGl0JztcbmltcG9ydCBNZW51ICAgICAgICAgICAgZnJvbSAnQC9jb21wb25lbnRzL01hcC9MZWFmbGV0L01lbnUnO1xuaW1wb3J0IFJhbmdlICAgICAgICAgICBmcm9tICdAL2NvbXBvbmVudHMvTWFwL0xlYWZsZXQvUmFuZ2UnO1xuaW1wb3J0IExlZ2VuZCAgICAgICAgICBmcm9tICdAL2NvbXBvbmVudHMvTWFwL0xlYWZsZXQvTGVnZW5kJztcbmltcG9ydCBMb2dvICAgICAgICAgICAgZnJvbSAnQC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0xvZ28nO1xuaW1wb3J0IE1peEtleSAgICAgICAgICBmcm9tICdAL2NvbXBvbmVudHMvTWFwL0xlYWZsZXQvTC5NaXguS2V5JztcbmltcG9ydCBNaXhGZWF0dXJlQ29sb3IgZnJvbSAnQC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0wuTWl4LkZlYXR1cmVDb2xvcic7XG5pbXBvcnQgTWl4Q29udHJvbCAgICAgIGZyb20gJ0AvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLk1peC5Db250cm9sJztcblxuXG4vLyDRg9GB0YLRgNCw0L3QtdC90LjQtSDQsdCw0LPQsCDRgSDQv9GD0YLRj9C80LhcbmRlbGV0ZSBJY29uLkRlZmF1bHQucHJvdG90eXBlLl9nZXRJY29uVXJsO1xuSWNvbi5EZWZhdWx0Lm1lcmdlT3B0aW9ucyh7XG4gIGljb25SZXRpbmFVcmw6IHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24tMngucG5nJyksXG4gIGljb25Vcmw6ICAgICAgIHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nJyksXG4gIHNoYWRvd1VybDogICAgIHJlcXVpcmUoJ2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmcnKSxcbn0pO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJMZWFmbGV0XCIsXG5cblxuICBtaXhpbnM6IFtcbiAgICBNaXhLZXksXG4gICAgTWl4RmVhdHVyZUNvbG9yLFxuICAgIE1peENvbnRyb2wsXG4gIF0sXG5cblxuICBjb21wb25lbnRzOiB7XG4gICAgTE1hcCxcbiAgICBMVGlsZUxheWVyLFxuICAgIExNYXJrZXIsXG4gICAgTFBvcHVwLFxuICAgIExUb29sdGlwLFxuICAgIExGZWF0dXJlR3JvdXAsXG4gICAgTExheWVyR3JvdXAsXG4gICAgTEdlb0pzb24sXG4gICAgTFBvbHlsaW5lLFxuICAgIExQb2x5Z29uLFxuICAgIExDb250cm9sU2NhbGUsXG4gICAgTENvbnRyb2wsXG4gICAgTEljb24sXG4gICAgJ2wtbWFya2VyLWNsdXN0ZXInOiBWdWUyTGVhZmxldE1hcmtlckNsdXN0ZXIsXG4gICAgTENvbnRyb2xQb2x5bGluZU1lYXN1cmUsXG5cbiAgICBFZGl0LFxuICAgIE1lbnUsXG4gICAgUmFuZ2UsXG4gICAgTGVnZW5kLFxuICAgIExvZ28sXG4gIH0sXG5cblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZW51OiB7XG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB4OiAgICAgICAwLFxuICAgICAgICB5OiAgICAgICAwLFxuICAgICAgfSxcblxuICAgICAgaG92ZXJfbWFwX2luZDogICAgIC0xLCAgICAgIC8vIE1BUF9JVEVNW2hvdmVyX21hcF9pbmRdICAgICAgICAgICAgICAgICAgIC0g0LHQu9C+0LosINC90LDQtCDQutC+0YLQvtGA0YvQvCDQvdCw0YXQvtC00LjRgtGB0Y8g0LrRg9GA0YHQvtGAXG4gICAgICBob3Zlcl9mZWF0dXJlX2luZDogLTEsICAgICAgLy8gTUFQX0lURU1bXS5GQy5mZWF0dXJlc1tob3Zlcl9mZWF0dXJlX2luZF0gLSDRhNC40LPRg9GA0LAsINC90LDQtCDQutC+0YLQvtGA0L7QuSDQvdCw0YXQvtC00LjRgtGB0Y8g0LrRg9GA0YHQvtGAXG5cbiAgICAgIG1hcE9wdGlvbnM6IHtcbiAgICAgICAgem9vbUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICB6b29tU25hcDogMC41LFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICAuLi5tYXBHZXR0ZXJzKFtcbiAgICAgICdNQVBfR0VUX0tFWScsXG4gICAgICAnTUFQX0dFVF9SQU5HRV9TRUwnLFxuICAgICAgJ01BUF9HRVRfVElMRVMnLFxuICAgICAgJ01BUF9HRVRfVElMRScsXG4gICAgICAnTUFQX0dFVF9TQ0FMRScsXG4gICAgICAnTUFQX0dFVF9NRUFTVVJFJyxcbiAgICAgICdNQVBfR0VUX0NMVVNURVInLFxuICAgICAgJ01BUF9HRVRfSElOVCcsXG5cbiAgICAgICdTQ1JJUFRfR0VUJyxcbiAgICAgICdTQ1JJUFRfR0VUX0lURU1fQ09MT1InLFxuICAgICAgJ1NDUklQVF9HRVRfSVRFTV9NQVJLRVInLFxuICAgICAgJ1NDUklQVF9HRVRfSVRFTV9MSU5FJyxcbiAgICAgICdTQ1JJUFRfR0VUX0lURU1fUE9MWUdPTicsXG4gICAgICAnU0NSSVBUX0dFVF9JVEVNX0lDT04nLFxuICAgIF0pLFxuICAgIC8vZm9ybTogdm0gPT4gdm0sXG4gIH0sXG5cblxuICBtZXRob2RzOiB7XG4gICAgLy8gLi4ubWFwQWN0aW9ucyhbXG4gICAgLy8gICAnTUFQX0FDVF9SQU5HRV9UUycsXG4gICAgLy8gXSksXG5cbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvLyBNRU5VXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgbWVudV9zaG93KGUpIHtcbiAgICAgIGUub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5tZW51LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubWVudS54ID0gZS5vcmlnaW5hbEV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1lbnUueSA9IGUub3JpZ2luYWxFdmVudC5jbGllbnRZO1xuICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4geyB0aGlzLm1lbnUudmlzaWJsZSA9IHRydWUgfSlcbiAgICB9LFxuXG4gICAgbWVudV9vcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlzaWJsZSA6IHRoaXMubWVudS52aXNpYmxlLFxuICAgICAgICB4ICAgICAgIDogdGhpcy5tZW51LngsXG4gICAgICAgIHkgICAgICAgOiB0aGlzLm1lbnUueSxcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvLyBNRUFTVVJFXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgbWVhc3VyZV9vcHRpb25zKCkge1xuICAgICAgbGV0IENPTE9SID0gJyM0OTQnOyAgIC8vINGG0LLQtdGCINC80LDRgNC60LXRgNC+0LIg0Lgg0LvQuNC90LjQuVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3NpdGlvbjogICAgICAgICAgICAgICAgJ3RvcGxlZnQnLFxuICAgICAgICAgIHVuaXQ6ICAgICAgICAgICAgICAgICAgICAnbWV0cmVzJyxcbiAgICAgICAgICBtZWFzdXJlQ29udHJvbENsYXNzZXM6ICAgWydzZWxlY3Rfb2ZmJ10sXG4gICAgICAgICAgY2xlYXJNZWFzdXJlbWVudHNPblN0b3A6IHRydWUsXG4gICAgICAgICAgbWVhc3VyZUNvbnRyb2xUaXRsZU9uOiAgICfQoNGD0LvQtdGC0LrQsDog0LLQutC70Y7Rh9C40YLRjCcsXG4gICAgICAgICAgbWVhc3VyZUNvbnRyb2xUaXRsZU9mZjogICfQoNGD0LvQtdGC0LrQsDog0LLRi9C60LvRjtGH0LjRgtGMJyxcbiAgICAgICAgICB0b29sdGlwVGV4dERlbGV0ZTogICAgICAgJ9Cd0LDQttC80LjRgtC1ICBTSElGVCDQuCDQutC70LjQutC90LjRgtC1INC80YvRiNC60L7QuSDQtNC70Y8gPGI+0YPQtNCw0LvQtdC90LjRjyDRgtC+0YfQutC4PC9iPicsXG4gICAgICAgICAgdG9vbHRpcFRleHRSZXN1bWU6ICAgICAgICc8YnI+0J3QsNC20LzQuNGC0LUgQ1RSTCDQuCDQutC70LjQutC90LjRgtC1INC80YvRiNC60L7QuSDQtNC70Y8gPGI+0L/RgNC+0LTQvtC70LbQtdC90LjRjyDQu9C40L3QuNC4PC9iPicsXG4gICAgICAgICAgdG9vbHRpcFRleHRBZGQ6ICAgICAgICAgICfQndCw0LbQvNC40YLQtSBDVFJMINC4INC60LvQuNC60L3QuNGC0LUg0LzRi9GI0LrQvtC5INC00LvRjyA8Yj7QtNC+0LHQsNCy0LvQtdC90LjRjyDRgtC+0YfQutC4PC9iPicsXG4gICAgICAgICAgdG9vbHRpcFRleHRGaW5pc2g6ICAgICAgICcnLFxuICAgICAgICAgIHRvb2x0aXBUZXh0TW92ZTogICAgICAgICAnJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgJyNkZmQnLFxuICAgICAgICAgIHRlbXBMaW5lOiAgICAgICAgICAgICAgICB7IGNvbG9yOiBDT0xPUiwgd2VpZ2h0OiAyLCB9LFxuICAgICAgICAgIGZpeGVkTGluZTogICAgICAgICAgICAgICB7IGNvbG9yOiBDT0xPUiwgd2VpZ2h0OiAyLCB9LFxuICAgICAgICAgIHN0YXJ0Q2lyY2xlOiAgICAgICAgICAgICB7IGNvbG9yOiBDT0xPUiwgd2VpZ2h0OiAxLCBmaWxsQ29sb3I6ICcjMGYwJywgZmlsbE9wYWNpdHk6IDEsIHJhZGl1czogNSwgfSxcbiAgICAgICAgICBpbnRlcm1lZENpcmNsZTogICAgICAgICAgeyBjb2xvcjogQ09MT1IsIHdlaWdodDogMSwgZmlsbENvbG9yOiAnI2ZmMCcsIGZpbGxPcGFjaXR5OiAxLCByYWRpdXM6IDUsIH0sXG4gICAgICAgICAgY3VycmVudENpcmNsZTogICAgICAgICAgIHsgY29sb3I6IENPTE9SLCB3ZWlnaHQ6IDEsIGZpbGxDb2xvcjogJyNmMGYnLCBmaWxsT3BhY2l0eTogMSwgcmFkaXVzOiA1LCB9LFxuICAgICAgICAgIGVuZENpcmNsZTogICAgICAgICAgICAgICB7IGNvbG9yOiBDT0xPUiwgd2VpZ2h0OiAxLCBmaWxsQ29sb3I6ICcjZjAwJywgZmlsbE9wYWNpdHk6IDEsIHJhZGl1czogNSwgfSxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgLy8gUkFOR0VcbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICByYW5nZV9vcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHsgfVxuICAgIH0sXG5cblxuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIC8vIExFR0VORFxuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIGxlZ2VuZF9vcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG92ZXJfbWFwX2luZCAgICAgOiB0aGlzLmhvdmVyX21hcF9pbmQsXG4gICAgICAgIGhvdmVyX2ZlYXR1cmVfaW5kIDogdGhpcy5ob3Zlcl9mZWF0dXJlX2luZCxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGVnZW5kX2hpZGUoKSB7XG4gICAgICB0aGlzLmhvdmVyX21hcF9pbmQgICAgID0gLTE7XG4gICAgICB0aGlzLmhvdmVyX2ZlYXR1cmVfaW5kID0gLTE7XG4gICAgfSxcblxuXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgLy8gTUFQXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgLy8g0LrQvtGA0YDQtdC60YLQuNGA0L7QstCw0YLRjCDQtNCw0L3QvdGL0LVcbiAgICBkYXRhX25vcm1hbGl6ZShtYXBfaW5kKSB7XG4gICAgICAvLyDRgNCw0YHRgdGH0LjRgtCw0YLRjCDRhtCy0LXRgtCwICjQu9C10LPQtdC90LTQsCwg0YbQstC10YIg0L7RgiDQt9C90LDRh9C10L3QuNGPINCyINCz0YDRg9C/0L/QtSlcbiAgICAgIHRoaXMuZGF0YV9ub3JtYWxpemVfY29sb3IobWFwX2luZCk7XG5cbiAgICAgIC8vIGRlZXAgY29weVxuICAgICAgbGV0IGl0ZW0gPSB0aGlzLlNDUklQVF9HRVRfSVRFTShtYXBfaW5kKTtcbiAgICAgIGxldCBmYyAgID0gaXRlbVtNQVBfSVRFTS5GQ107XG4gICAgICBmYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZmMpKTtcblxuICAgICAgLy8g0YPRgdGC0LDQvdC+0LLQuNGC0YwgZmMuZmVhdHVyZXNbaW5kXS5pbmQgLSDQv9C+0YDRj9C00LrQvtCy0YvQuSDQvdC+0LzQtdGAINGE0LjQs9GD0YDRiyDQsiBmY1xuICAgICAgZm9yKGxldCBpbmQ9MDsgaW5kPGZjLmZlYXR1cmVzLmxlbmd0aDsgaW5kKyspIHsgZmMuZmVhdHVyZXNbaW5kXS5pbmQgPSBpbmQ7IH1cblxuICAgICAgLy8g0L7RgtGE0LjQu9GM0YLRgNC+0LLQsNGC0Ywg0YEg0LTQvtC/0YPRgdGC0LjQvNGL0LzQuCDQtNCw0YLQsNC80LhcbiAgICAgIGxldCByYW5nZV90cyAgPSB0aGlzLk1BUF9HRVRfUkFOR0VfU0VMO1xuICAgICAgaWYgKChyYW5nZV90c1swXT4wKSAmJiAocmFuZ2VfdHNbMV0+MCkpIHtcbiAgICAgICAgbGV0IGl0ZW1fZGF0ZTtcbiAgICAgICAgbGV0IGZlYXR1cmVzID0gZmMuZmVhdHVyZXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIWl0ZW0ucHJvcGVydGllcy5kYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpdGVtX2RhdGUgPSBkYXRlc3FsX3RvX3RzKGl0ZW0ucHJvcGVydGllcy5kYXRlKTtcbiAgICAgICAgICByZXR1cm4gKChpdGVtX2RhdGUgPj0gcmFuZ2VfdHNbMF0pICYmIChpdGVtX2RhdGUgPD0gcmFuZ2VfdHNbMV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZjLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYztcbiAgICB9LFxuXG4gICAgY2x1c3Rlcl9vcHRpb25zKG1hcF9pbmQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vINC+0LHQu9Cw0YHRgtGMINC/0YDQuCDQvdCw0LLQtdC00LXQvdC40Lgg0LrRg9GA0YHQvtGA0LAg0L3QsCDQutC70LDRgdGC0LXRgFxuICAgICAgICBzaG93Q292ZXJhZ2VPbkhvdmVyOiB0cnVlLFxuICAgICAgICBwb2x5Z29uT3B0aW9uczogeyBjb2xvcjogdGhpcy5TQ1JJUFRfR0VUX0lURU1fQ09MT1IobWFwX2luZCksIH0sXG5cbiAgICAgICAgLy8g0LTQu9GPINC/0L7RgdC70LXQtNGD0Y7RidC10Lkg0LrQvtGA0YDQtdC60YbQuNC4INGG0LLQtdGC0LAg0LzQsNGA0LrQtdGA0L7QslxuICAgICAgICBjbHVzdGVyX2NvbG9yOiB0aGlzLlNDUklQVF9HRVRfSVRFTV9DT0xPUihtYXBfaW5kKSxcblxuICAgICAgICAvLyDRg9Cy0LXQu9C40YfQtdC90LjQtSwg0L/RgNC4INC60L7RgtC+0YDQvtC8INGB0L7Qt9C00LDQstCw0YLRjCDQutC70LDRgdGC0LXRgNGLXG4gICAgICAgIGRpc2FibGVDbHVzdGVyaW5nQXRab29tOiB0aGlzLk1BUF9HRVRfQ0xVU1RFUj8xNzowLFxuXG4gICAgICAgIC8vINC/0L7QtNC80LXQvdCwINC40LrQvtC90LrQuCDQutC70LDRgdGC0LXRgNCwXG4gICAgICAgIGljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEwuRGl2SWNvbih7XG4gICAgICAgICAgICBodG1sOiAnPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6Jyt0aGlzLmNsdXN0ZXJfY29sb3IrJztcIj48c3Bhbj4nICsgY2x1c3Rlci5nZXRDaGlsZENvdW50KCkgKyAnPC9zcGFuPjwvZGl2PicsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdtYXJrZXItY2x1c3RlciBtYXJrZXItY2x1c3Rlci1zbWFsbCBtYXJrZXItY2x1c3Rlci1iZy1uZXcnLFxuICAgICAgICAgICAgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g0YbQstC10YIg0YDQtdCz0LjQvtC90LAg0YHQs9GA0YPQv9C/0LjRgNC+0LLQsNC90L3QvtCz0L4g0LrQu9Cw0YHRgtC10YDQsFxuICAgICAgICBzcGlkZXJMZWdQb2x5bGluZU9wdGlvbnM6IHsgd2VpZ2h0OiAxLjUsIGNvbG9yOiB0aGlzLmNsdXN0ZXJfY29sb3IsIG9wYWNpdHk6IDAuNSB9LFxuXG4gICAgICAgIC8vINC90LXRgdCz0YDRg9C/0LjRgNC+0LLQsNC90L3Ri9C1INC4INGB0LPRgNGD0L/Qv9C40YDQvtCy0LDQvdC90YvQtSDQvNCw0YDQutC10YDRiyDQvtC00LjQvdCw0LrQvtCy0YtcbiAgICAgICAgLy8gc2luZ2xlTWFya2VyTW9kZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgfSxcblxuXG4gICAgZ2VvanNvbl9vcHRpb25zKG1hcF9pbmQpIHtcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vINC00LvRjyDQutCw0LbQtNC+0LPQviDQvNCw0YDQutC10YDQsCAvINGE0LjQs9GD0YDRi1xuICAgICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuICAgICAgICAgIC8vIGNvbnRyb2wt0LvQtdCz0LXQvdC00LA6INGD0YHRgtCw0L3QvtCy0LrQsCBvbkhvdmVyXG4gICAgICAgICAgLy8g0YHQvtCx0YvRgtC40Y8g0L/QvtCy0YLQvtGA0L3QviDQstGL0LfRi9Cy0LDRjtGCIHRoaXMuZGF0YV9ub3JtYWxpemVfY29sb3JcbiAgICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgbGF5ZXIub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGUpIHsgc2VsZi5ob3Zlcl9tYXBfaW5kID0gbWFwX2luZDsgIHNlbGYuaG92ZXJfZmVhdHVyZV9pbmQgPSBmZWF0dXJlLmluZDsgfSk7XG4gICAgICAgICAgbGF5ZXIub24oJ21vdXNlb3V0JywgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LmN0cmxLZXkpIHNlbGYuaG92ZXJfbWFwX2luZCA9IC0xO1xuICAgICAgICAgICAgc2VsZi5ob3Zlcl9mZWF0dXJlX2luZCA9IC0xO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8g0L/QvtC00YHQutCw0LfQutCwXG4gICAgICAgICAgaWYgKHNlbGYuTUFQX0dFVF9ISU5UICYmIGZlYXR1cmUucHJvcGVydGllcy5oaW50ICYmIGZlYXR1cmUucHJvcGVydGllcy5oaW50IT0nJykgbGF5ZXIuYmluZFRvb2x0aXAoXG4gICAgICAgICAgICBcIjxkaXY+XCIrZmVhdHVyZS5wcm9wZXJ0aWVzLmhpbnQrXCI8L2Rpdj5cIixcbiAgICAgICAgICAgIHsgcGVybWFuZW50OiBmYWxzZSwgc3RpY2t5OiB0cnVlLCB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vINGC0LjQvyDQu9C40L3QuNC4OiDQsdC10LPRg9GJ0LDRjyDQv9GD0L3QutGC0LjRgNC90LDRj1xuICAgICAgICAgIGxldCBsaW5lID0gc2VsZi5TQ1JJUFRfR0VUX0lURU1fTElORShtYXBfaW5kKTtcbiAgICAgICAgICBpZiAoKFsnTGluZVN0cmluZycsIF0uaW5kZXhPZihmZWF0dXJlLmdlb21ldHJ5LnR5cGUpPi0xKSAmJiAobGluZSE9TUFQX0lURU0uTElORS5ERUZBVUxUKSkgeyAgIC8vICdQb2x5Z29uJ1xuICAgICAgICAgICAgbGF5ZXIuc2V0U3R5bGUoeydjbGFzc05hbWUnOiBsaW5lLCB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyDRgNC10LTQsNC60YLQuNGA0L7QstCw0L3QuNC1INC30LDQv9GA0LXRidC10L3QviAtINGD0LTQsNC70LjRgtGMIHBtIC0g0LTQu9GPINGD0LzQtdC90YzRiNC10L3QuNGPINC+0LHRitC10LzQsCDQstGL0YfQuNGB0LvQtdC90LjQuVxuICAgICAgICAgIGlmIChsYXllci5wbSkgeyBkZWxldGUgbGF5ZXIucG07IH1cblxuICAgICAgICAgIC8vINGC0LjQvyDQv9C+0LvQuNCz0L7QvdCwOiBjb2xvclxuICAgICAgICAgIC8vIGxldCBwb2x5Z29uID0gc2VsZi5TQ1JJUFRfR0VUX0lURU1fUE9MWUdPTihtYXBfaW5kKTtcbiAgICAgICAgICAvLyBpZiAoKFsnUG9seWdvbicsIF0uaW5kZXhPZihmZWF0dXJlLmdlb21ldHJ5LnR5cGUpPi0xKSAmJiAocG9seWdvbiE9UE9MWUdPTi5ERUZBVUxUKSkge1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLFxuXG5cbiAgICAgICAgLy8g0YHRgtC40LvRjCDQvNCw0YDQutC10YDQvtCyXG4gICAgICAgIHBvaW50VG9MYXllcjogZnVuY3Rpb24oZmVhdHVyZSwgbGF0bG5nKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcmtlcl9nZXQobGF0bG5nLCB7XG4gICAgICAgICAgICBuYW1lOiAgc2VsZi5TQ1JJUFRfR0VUX0lURU1fTUFSS0VSKG1hcF9pbmQpLFxuICAgICAgICAgICAgY29sb3I6IHNlbGYuU0NSSVBUX0dFVF9JVEVNX0NPTE9SIChtYXBfaW5kKSxcbiAgICAgICAgICAgIGljb246ICBzZWxmLlNDUklQVF9HRVRfSVRFTV9JQ09OICAobWFwX2luZCksXG4gICAgICAgICAgICAvLyBzaXplOiAgc2VsZi5TQ1JJUFRfR0VUX0lURU1fSUNPTihtYXBfaW5kKSwg0L3QtSDRgNC10LDQu9C40LfQvtCy0LDQvdC+INC30LAg0L3QtdC90LDQtNC+0LHQvdC+0YHRgtGM0Y5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8vINGB0YLQuNC70Ywg0YTQuNCz0YPRgFxuICAgICAgICBzdHlsZTogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWlnaHQ6ICAgICAgMixcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAuNSxcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAuMyxcbiAgICAgICAgICAgIGNvbG9yOiAgICAgICBzZWxmLlNDUklQVF9HRVRfSVRFTV9DT0xPUihtYXBfaW5kKSxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogICBmZWF0dXJlLmNvbG9yLCAvLyBzZXQgaW4gbWl4aW5cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuXG5cblxuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIC8vINCh0J7QkdCr0KLQmNCvXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgb25NYXBSZWFkeSgpIHtcbiAgICAgIHRoaXMubWFwID0gdGhpcy4kcmVmcy5tYXAubWFwT2JqZWN0O1xuICAgICAgLy90aGlzLm9uRWRpdFJlYWR5KCk7XG4gICAgfSxcblxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmxhdGxuZyk7XG4gICAgfSxcblxuICAgIG9uVGVzdDIoZXZlbnQpIHtcbiAgICAgIC8vIHZhciBmZyA9IEwuZmVhdHVyZUdyb3VwKCk7XG4gICAgICAvLyB0aGlzLm1hcC5lYWNoTGF5ZXIoKGxheWVyKT0+e1xuICAgICAgLy8gICBpZigobGF5ZXIgaW5zdGFuY2VvZiBMLlBhdGggfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikgJiYgbGF5ZXIucG0gJiYgbGF5ZXIucG0uZWRpdGVkKXtcbiAgICAgIC8vICAgICBmZy5hZGRMYXllcihsYXllcik7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coZmcudG9HZW9KU09OKCkpO1xuXG4gICAgICAvLyB0aGlzLm1hcC5wbS5nZXRHZW9tYW5MYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKXtcbiAgICAgIC8vICAgY29uc29sZS5sb2coMSwgbGF5ZXIpXG4gICAgICAvLyB9KTtcblxuICAgICAgLy8gY29uc29sZS5sb2coMiwgdGhpcy5tYXAucG0uZ2V0R2VvbWFuTGF5ZXJzKHRydWUpKVxuICAgICAgLy8gdGhpcy5tYXAucG0uZW5hYmxlRHJhdygnUG9seWdvbicsIHt9KTtcblxuICAgICAgdGhpcy5lZGl0b3JfZGF0YV9zZXQoKTtcbiAgICB9LFxuXG5cblxuXG5cbiAgICAvLyBHRVQgQlVUVE9OXG4gICAgYnRuX2dldF9jbGljayhldmVudCkge1xuICAgICAgY29uc29sZS5sb2codGhpcy5nZXREYXRhQXNHZW9KU09OKCkpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhQXNHZW9KU09OICgpIHtcbiAgICAgIC8vIGNyZWF0ZSBGZWF0dXJlQ29sbGVjdGlvblxuICAgICAgY29uc3QgZ2VvSlNPTiA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBleHBvcnQgZWFjaCBsYXllclxuICAgICAgdGhpcy5tYXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIuX2xlYWZsZXRfaWQgJiYgKGxheWVyIGluc3RhbmNlb2YgTC5QYXRoIHx8IGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIpKSB7XG4gICAgICAgICAgY29uc3QgZ2VvSlNPTlNoYXBlICAgICAgPSBsYXllci50b0dlb0pTT04oMTYpOyAvLyDQtNC70Y8g0YLQvtGH0L3QvtGB0YLQuFxuICAgICAgICAgIGdlb0pTT05TaGFwZS5wcm9wZXJ0aWVzID0gbGF5ZXIucHJvcGVydGllcztcbiAgICAgICAgICBnZW9KU09OU2hhcGUuaWQgICAgICAgICA9IGxheWVyLl9sZWFmbGV0X2lkO1xuICAgICAgICAgIGdlb0pTT04uZmVhdHVyZXMucHVzaChnZW9KU09OU2hhcGUpO1xuXG4gICAgICAgICAgLy8gbm9ybWFsaXplIGNvb3JkaW5hdGVzICg+IDE4MC8+OTApXG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdlb0pTT047XG4gICAgfSxcblxuXG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAubGVhZmxldC1jZW50ZXIge1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAwJSk7XG4gIH1cbiAgLnBvbHlsaW5lLW1lYXN1cmUtdG9vbHRpcC1kaWZmZXJlbmNlIHtcbiAgICBjb2xvcjogIzA2MDtcbiAgICBmb250LXN0eWxlOiBub3JtYWwhaW1wb3J0YW50O1xuICB9XG5cbiAgLyoqKiDQutC90L7Qv9C60LAgKioqL1xuICAucG9seWxpbmUtbWVhc3VyZS11bmljb2RlLWljb24ge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNTQpIWltcG9ydGFudDtcbiAgfVxuICAucG9seWxpbmUtbWVhc3VyZS1jb250cm9sT25CZ0NvbG9yIHtcbiAgICBjb2xvcjogcmVkIWltcG9ydGFudDtcbiAgfVxuPC9zdHlsZT5cbjxzdHlsZSBzY29wZWQgbGFuZz1cInNjc3NcIj5cbiAgQGltcG9ydCBcIn5sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3NcIjtcbiAgQGltcG9ydCBcIn5sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvZGlzdC9NYXJrZXJDbHVzdGVyLmNzc1wiO1xuICBAaW1wb3J0IFwifmxlYWZsZXQubWFya2VyY2x1c3Rlci9kaXN0L01hcmtlckNsdXN0ZXIuRGVmYXVsdC5jc3NcIjtcblxuICBAaW1wb3J0IFwifkAvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLmNzc1wiO1xuXG4gIEBpbXBvcnQgXCJ+QC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0wuTWFya2VyLkNsdXN0ZXIuY3NzXCI7XG4gIEBpbXBvcnQgXCJ+QC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0wuTWFya2VyLlB1bHNlLmNzc1wiO1xuICBAaW1wb3J0IFwifkAvY29tcG9uZW50cy9NYXAvTGVhZmxldC9MLk1hcmtlci5Gb250LmNzc1wiO1xuXG4gIEBpbXBvcnQgXCJ+QC9jb21wb25lbnRzL01hcC9MZWFmbGV0L0wuTWl4LkNvbnRyb2wuY3NzXCI7XG48L3N0eWxlPlxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUZBO0FBT0E7QUFJQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQVZBO0FBZUE7QUFHQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFsQkE7QUFvQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBekJBO0FBMEJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BO0FBdERBO0FBd0RBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQXJRQTtBQTdFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Map/Leaflet/Leaflet.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./src/components/Map/Leaflet/proj4.js":
/*!*********************************************!*\
  !*** ./src/components/Map/Leaflet/proj4.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _typeof = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\").default;\n\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"./node_modules/core-js/modules/es.string.split.js\");\n\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"./node_modules/core-js/modules/es.regexp.exec.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"./node_modules/core-js/modules/es.array.map.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"./node_modules/core-js/modules/es.array.reduce.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"./node_modules/core-js/modules/es.array.filter.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"./node_modules/core-js/modules/es.string.trim.js\");\n\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"./node_modules/core-js/modules/es.number.constructor.js\");\n\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"./node_modules/core-js/modules/es.function.name.js\");\n\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"./node_modules/core-js/modules/es.array.slice.js\");\n\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"./node_modules/core-js/modules/es.string.replace.js\");\n\n!function (e) {\n  if (\"object\" == ( false ? undefined : _typeof(exports))) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var f; }\n}(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return require(o, !0);\n          if (i) return i(o, !0);\n          throw new Error(\"Cannot find module '\" + o + \"'\");\n        }\n\n        var f = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(f.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, f, f.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      var mgrs = _dereq_('mgrs');\n\n      function Point(x, y, z) {\n        if (!(this instanceof Point)) {\n          return new Point(x, y, z);\n        }\n\n        if (Array.isArray(x)) {\n          this.x = x[0];\n          this.y = x[1];\n          this.z = x[2] || 0.0;\n        } else if (_typeof(x) === 'object') {\n          this.x = x.x;\n          this.y = x.y;\n          this.z = x.z || 0.0;\n        } else if (typeof x === 'string' && typeof y === 'undefined') {\n          var coords = x.split(',');\n          this.x = parseFloat(coords[0], 10);\n          this.y = parseFloat(coords[1], 10);\n          this.z = parseFloat(coords[2], 10) || 0.0;\n        } else {\n          this.x = x;\n          this.y = y;\n          this.z = z || 0.0;\n        }\n\n        console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n      }\n\n      Point.fromMGRS = function (mgrsStr) {\n        return new Point(mgrs.toPoint(mgrsStr));\n      };\n\n      Point.prototype.toMGRS = function (accuracy) {\n        return mgrs.forward([this.x, this.y], accuracy);\n      };\n\n      module.exports = Point;\n    }, {\n      \"mgrs\": 67\n    }],\n    2: [function (_dereq_, module, exports) {\n      var parseCode = _dereq_(\"./parseCode\");\n\n      var extend = _dereq_('./extend');\n\n      var projections = _dereq_('./projections');\n\n      var deriveConstants = _dereq_('./deriveConstants');\n\n      function Projection(srsCode, callback) {\n        if (!(this instanceof Projection)) {\n          return new Projection(srsCode);\n        }\n\n        callback = callback || function (error) {\n          if (error) {\n            throw error;\n          }\n        };\n\n        var json = parseCode(srsCode);\n\n        if (_typeof(json) !== 'object') {\n          callback(srsCode);\n          return;\n        }\n\n        var modifiedJSON = deriveConstants(json);\n        var ourProj = Projection.projections.get(modifiedJSON.projName);\n\n        if (ourProj) {\n          extend(this, modifiedJSON);\n          extend(this, ourProj);\n          this.init();\n          callback(null, this);\n        } else {\n          callback(srsCode);\n        }\n      }\n\n      Projection.projections = projections;\n      Projection.projections.start();\n      module.exports = Projection;\n    }, {\n      \"./deriveConstants\": 33,\n      \"./extend\": 34,\n      \"./parseCode\": 37,\n      \"./projections\": 39\n    }],\n    3: [function (_dereq_, module, exports) {\n      module.exports = function (crs, denorm, point) {\n        var xin = point.x,\n            yin = point.y,\n            zin = point.z || 0.0;\n        var v, t, i;\n\n        for (i = 0; i < 3; i++) {\n          if (denorm && i === 2 && point.z === undefined) {\n            continue;\n          }\n\n          if (i === 0) {\n            v = xin;\n            t = 'x';\n          } else if (i === 1) {\n            v = yin;\n            t = 'y';\n          } else {\n            v = zin;\n            t = 'z';\n          }\n\n          switch (crs.axis[i]) {\n            case 'e':\n              point[t] = v;\n              break;\n\n            case 'w':\n              point[t] = -v;\n              break;\n\n            case 'n':\n              point[t] = v;\n              break;\n\n            case 's':\n              point[t] = -v;\n              break;\n\n            case 'u':\n              if (point[t] !== undefined) {\n                point.z = v;\n              }\n\n              break;\n\n            case 'd':\n              if (point[t] !== undefined) {\n                point.z = -v;\n              }\n\n              break;\n\n            default:\n              //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n              return null;\n          }\n        }\n\n        return point;\n      };\n    }, {}],\n    4: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n\n      var sign = _dereq_('./sign');\n\n      module.exports = function (x) {\n        return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;\n      };\n    }, {\n      \"./sign\": 21\n    }],\n    5: [function (_dereq_, module, exports) {\n      var TWO_PI = Math.PI * 2; // SPI is slightly greater than Math.PI, so values that exceed the -180..180\n      // degree range by a tiny amount don't get wrapped. This prevents points that\n      // have drifted from their original location along the 180th meridian (due to\n      // floating point error) from changing their sign.\n\n      var SPI = 3.14159265359;\n\n      var sign = _dereq_('./sign');\n\n      module.exports = function (x) {\n        return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;\n      };\n    }, {\n      \"./sign\": 21\n    }],\n    6: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        if (Math.abs(x) > 1) {\n          x = x > 1 ? 1 : -1;\n        }\n\n        return Math.asin(x);\n      };\n    }, {}],\n    7: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));\n      };\n    }, {}],\n    8: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));\n      };\n    }, {}],\n    9: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        return 0.05859375 * x * x * (1 + 0.75 * x);\n      };\n    }, {}],\n    10: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        return x * x * x * (35 / 3072);\n      };\n    }, {}],\n    11: [function (_dereq_, module, exports) {\n      module.exports = function (a, e, sinphi) {\n        var temp = e * sinphi;\n        return a / Math.sqrt(1 - temp * temp);\n      };\n    }, {}],\n    12: [function (_dereq_, module, exports) {\n      module.exports = function (ml, e0, e1, e2, e3) {\n        var phi;\n        var dphi;\n        phi = ml / e0;\n\n        for (var i = 0; i < 15; i++) {\n          dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n          phi += dphi;\n\n          if (Math.abs(dphi) <= 0.0000000001) {\n            return phi;\n          }\n        } //..reportError(\"IMLFN-CONV:Latitude failed to converge after 15 iterations\");\n\n\n        return NaN;\n      };\n    }, {}],\n    13: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n\n      module.exports = function (eccent, q) {\n        var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n\n        if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n          if (q < 0) {\n            return -1 * HALF_PI;\n          } else {\n            return HALF_PI;\n          }\n        } //var phi = 0.5* q/(1-eccent*eccent);\n\n\n        var phi = Math.asin(0.5 * q);\n        var dphi;\n        var sin_phi;\n        var cos_phi;\n        var con;\n\n        for (var i = 0; i < 30; i++) {\n          sin_phi = Math.sin(phi);\n          cos_phi = Math.cos(phi);\n          con = eccent * sin_phi;\n          dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n          phi += dphi;\n\n          if (Math.abs(dphi) <= 0.0000000001) {\n            return phi;\n          }\n        } //console.log(\"IQSFN-CONV:Latitude failed to converge after 30 iterations\");\n\n\n        return NaN;\n      };\n    }, {}],\n    14: [function (_dereq_, module, exports) {\n      module.exports = function (e0, e1, e2, e3, phi) {\n        return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);\n      };\n    }, {}],\n    15: [function (_dereq_, module, exports) {\n      module.exports = function (eccent, sinphi, cosphi) {\n        var con = eccent * sinphi;\n        return cosphi / Math.sqrt(1 - con * con);\n      };\n    }, {}],\n    16: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n\n      module.exports = function (eccent, ts) {\n        var eccnth = 0.5 * eccent;\n        var con, dphi;\n        var phi = HALF_PI - 2 * Math.atan(ts);\n\n        for (var i = 0; i <= 15; i++) {\n          con = eccent * Math.sin(phi);\n          dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;\n          phi += dphi;\n\n          if (Math.abs(dphi) <= 0.0000000001) {\n            return phi;\n          }\n        } //console.log(\"phi2z has NoConvergence\");\n\n\n        return -9999;\n      };\n    }, {}],\n    17: [function (_dereq_, module, exports) {\n      var C00 = 1;\n      var C02 = 0.25;\n      var C04 = 0.046875;\n      var C06 = 0.01953125;\n      var C08 = 0.01068115234375;\n      var C22 = 0.75;\n      var C44 = 0.46875;\n      var C46 = 0.01302083333333333333;\n      var C48 = 0.00712076822916666666;\n      var C66 = 0.36458333333333333333;\n      var C68 = 0.00569661458333333333;\n      var C88 = 0.3076171875;\n\n      module.exports = function (es) {\n        var en = [];\n        en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n        en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n        var t = es * es;\n        en[2] = t * (C44 - es * (C46 + es * C48));\n        t *= es;\n        en[3] = t * (C66 - es * C68);\n        en[4] = t * es * C88;\n        return en;\n      };\n    }, {}],\n    18: [function (_dereq_, module, exports) {\n      var pj_mlfn = _dereq_(\"./pj_mlfn\");\n\n      var EPSLN = 1.0e-10;\n      var MAX_ITER = 20;\n\n      module.exports = function (arg, es, en) {\n        var k = 1 / (1 - es);\n        var phi = arg;\n\n        for (var i = MAX_ITER; i; --i) {\n          /* rarely goes over 2 iterations */\n          var s = Math.sin(phi);\n          var t = 1 - es * s * s; //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n          //phi -= t * (t * Math.sqrt(t)) * k;\n\n          t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n          phi -= t;\n\n          if (Math.abs(t) < EPSLN) {\n            return phi;\n          }\n        } //..reportError(\"cass:pj_inv_mlfn: Convergence error\");\n\n\n        return phi;\n      };\n    }, {\n      \"./pj_mlfn\": 19\n    }],\n    19: [function (_dereq_, module, exports) {\n      module.exports = function (phi, sphi, cphi, en) {\n        cphi *= sphi;\n        sphi *= sphi;\n        return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));\n      };\n    }, {}],\n    20: [function (_dereq_, module, exports) {\n      module.exports = function (eccent, sinphi) {\n        var con;\n\n        if (eccent > 1.0e-7) {\n          con = eccent * sinphi;\n          return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n        } else {\n          return 2 * sinphi;\n        }\n      };\n    }, {}],\n    21: [function (_dereq_, module, exports) {\n      module.exports = function (x) {\n        return x < 0 ? -1 : 1;\n      };\n    }, {}],\n    22: [function (_dereq_, module, exports) {\n      module.exports = function (esinp, exp) {\n        return Math.pow((1 - esinp) / (1 + esinp), exp);\n      };\n    }, {}],\n    23: [function (_dereq_, module, exports) {\n      module.exports = function (array) {\n        var out = {\n          x: array[0],\n          y: array[1]\n        };\n\n        if (array.length > 2) {\n          out.z = array[2];\n        }\n\n        if (array.length > 3) {\n          out.m = array[3];\n        }\n\n        return out;\n      };\n    }, {}],\n    24: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n\n      module.exports = function (eccent, phi, sinphi) {\n        var con = eccent * sinphi;\n        var com = 0.5 * eccent;\n        con = Math.pow((1 - con) / (1 + con), com);\n        return Math.tan(0.5 * (HALF_PI - phi)) / con;\n      };\n    }, {}],\n    25: [function (_dereq_, module, exports) {\n      exports.wgs84 = {\n        towgs84: \"0,0,0\",\n        ellipse: \"WGS84\",\n        datumName: \"WGS84\"\n      };\n      exports.ch1903 = {\n        towgs84: \"674.374,15.056,405.346\",\n        ellipse: \"bessel\",\n        datumName: \"swiss\"\n      };\n      exports.ggrs87 = {\n        towgs84: \"-199.87,74.79,246.62\",\n        ellipse: \"GRS80\",\n        datumName: \"Greek_Geodetic_Reference_System_1987\"\n      };\n      exports.nad83 = {\n        towgs84: \"0,0,0\",\n        ellipse: \"GRS80\",\n        datumName: \"North_American_Datum_1983\"\n      };\n      exports.nad27 = {\n        nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n        ellipse: \"clrk66\",\n        datumName: \"North_American_Datum_1927\"\n      };\n      exports.potsdam = {\n        towgs84: \"606.0,23.0,413.0\",\n        ellipse: \"bessel\",\n        datumName: \"Potsdam Rauenberg 1950 DHDN\"\n      };\n      exports.carthage = {\n        towgs84: \"-263.0,6.0,431.0\",\n        ellipse: \"clark80\",\n        datumName: \"Carthage 1934 Tunisia\"\n      };\n      exports.hermannskogel = {\n        towgs84: \"653.0,-212.0,449.0\",\n        ellipse: \"bessel\",\n        datumName: \"Hermannskogel\"\n      };\n      exports.ire65 = {\n        towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n        ellipse: \"mod_airy\",\n        datumName: \"Ireland 1965\"\n      };\n      exports.rassadiran = {\n        towgs84: \"-133.63,-157.5,-158.62\",\n        ellipse: \"intl\",\n        datumName: \"Rassadiran\"\n      };\n      exports.nzgd49 = {\n        towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n        ellipse: \"intl\",\n        datumName: \"New Zealand Geodetic Datum 1949\"\n      };\n      exports.osgb36 = {\n        towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n        ellipse: \"airy\",\n        datumName: \"Airy 1830\"\n      };\n      exports.s_jtsk = {\n        towgs84: \"589,76,480\",\n        ellipse: 'bessel',\n        datumName: 'S-JTSK (Ferro)'\n      };\n      exports.beduaram = {\n        towgs84: '-106,-87,188',\n        ellipse: 'clrk80',\n        datumName: 'Beduaram'\n      };\n      exports.gunung_segara = {\n        towgs84: '-403,684,41',\n        ellipse: 'bessel',\n        datumName: 'Gunung Segara Jakarta'\n      };\n      exports.rnb72 = {\n        towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n        ellipse: \"intl\",\n        datumName: \"Reseau National Belge 1972\"\n      };\n    }, {}],\n    26: [function (_dereq_, module, exports) {\n      exports.MERIT = {\n        a: 6378137.0,\n        rf: 298.257,\n        ellipseName: \"MERIT 1983\"\n      };\n      exports.SGS85 = {\n        a: 6378136.0,\n        rf: 298.257,\n        ellipseName: \"Soviet Geodetic System 85\"\n      };\n      exports.GRS80 = {\n        a: 6378137.0,\n        rf: 298.257222101,\n        ellipseName: \"GRS 1980(IUGG, 1980)\"\n      };\n      exports.IAU76 = {\n        a: 6378140.0,\n        rf: 298.257,\n        ellipseName: \"IAU 1976\"\n      };\n      exports.airy = {\n        a: 6377563.396,\n        b: 6356256.910,\n        ellipseName: \"Airy 1830\"\n      };\n      exports.APL4 = {\n        a: 6378137,\n        rf: 298.25,\n        ellipseName: \"Appl. Physics. 1965\"\n      };\n      exports.NWL9D = {\n        a: 6378145.0,\n        rf: 298.25,\n        ellipseName: \"Naval Weapons Lab., 1965\"\n      };\n      exports.mod_airy = {\n        a: 6377340.189,\n        b: 6356034.446,\n        ellipseName: \"Modified Airy\"\n      };\n      exports.andrae = {\n        a: 6377104.43,\n        rf: 300.0,\n        ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n      };\n      exports.aust_SA = {\n        a: 6378160.0,\n        rf: 298.25,\n        ellipseName: \"Australian Natl & S. Amer. 1969\"\n      };\n      exports.GRS67 = {\n        a: 6378160.0,\n        rf: 298.2471674270,\n        ellipseName: \"GRS 67(IUGG 1967)\"\n      };\n      exports.bessel = {\n        a: 6377397.155,\n        rf: 299.1528128,\n        ellipseName: \"Bessel 1841\"\n      };\n      exports.bess_nam = {\n        a: 6377483.865,\n        rf: 299.1528128,\n        ellipseName: \"Bessel 1841 (Namibia)\"\n      };\n      exports.clrk66 = {\n        a: 6378206.4,\n        b: 6356583.8,\n        ellipseName: \"Clarke 1866\"\n      };\n      exports.clrk80 = {\n        a: 6378249.145,\n        rf: 293.4663,\n        ellipseName: \"Clarke 1880 mod.\"\n      };\n      exports.clrk58 = {\n        a: 6378293.645208759,\n        rf: 294.2606763692654,\n        ellipseName: \"Clarke 1858\"\n      };\n      exports.CPM = {\n        a: 6375738.7,\n        rf: 334.29,\n        ellipseName: \"Comm. des Poids et Mesures 1799\"\n      };\n      exports.delmbr = {\n        a: 6376428.0,\n        rf: 311.5,\n        ellipseName: \"Delambre 1810 (Belgium)\"\n      };\n      exports.engelis = {\n        a: 6378136.05,\n        rf: 298.2566,\n        ellipseName: \"Engelis 1985\"\n      };\n      exports.evrst30 = {\n        a: 6377276.345,\n        rf: 300.8017,\n        ellipseName: \"Everest 1830\"\n      };\n      exports.evrst48 = {\n        a: 6377304.063,\n        rf: 300.8017,\n        ellipseName: \"Everest 1948\"\n      };\n      exports.evrst56 = {\n        a: 6377301.243,\n        rf: 300.8017,\n        ellipseName: \"Everest 1956\"\n      };\n      exports.evrst69 = {\n        a: 6377295.664,\n        rf: 300.8017,\n        ellipseName: \"Everest 1969\"\n      };\n      exports.evrstSS = {\n        a: 6377298.556,\n        rf: 300.8017,\n        ellipseName: \"Everest (Sabah & Sarawak)\"\n      };\n      exports.fschr60 = {\n        a: 6378166.0,\n        rf: 298.3,\n        ellipseName: \"Fischer (Mercury Datum) 1960\"\n      };\n      exports.fschr60m = {\n        a: 6378155.0,\n        rf: 298.3,\n        ellipseName: \"Fischer 1960\"\n      };\n      exports.fschr68 = {\n        a: 6378150.0,\n        rf: 298.3,\n        ellipseName: \"Fischer 1968\"\n      };\n      exports.helmert = {\n        a: 6378200.0,\n        rf: 298.3,\n        ellipseName: \"Helmert 1906\"\n      };\n      exports.hough = {\n        a: 6378270.0,\n        rf: 297.0,\n        ellipseName: \"Hough\"\n      };\n      exports.intl = {\n        a: 6378388.0,\n        rf: 297.0,\n        ellipseName: \"International 1909 (Hayford)\"\n      };\n      exports.kaula = {\n        a: 6378163.0,\n        rf: 298.24,\n        ellipseName: \"Kaula 1961\"\n      };\n      exports.lerch = {\n        a: 6378139.0,\n        rf: 298.257,\n        ellipseName: \"Lerch 1979\"\n      };\n      exports.mprts = {\n        a: 6397300.0,\n        rf: 191.0,\n        ellipseName: \"Maupertius 1738\"\n      };\n      exports.new_intl = {\n        a: 6378157.5,\n        b: 6356772.2,\n        ellipseName: \"New International 1967\"\n      };\n      exports.plessis = {\n        a: 6376523.0,\n        rf: 6355863.0,\n        ellipseName: \"Plessis 1817 (France)\"\n      };\n      exports.krass = {\n        a: 6378245.0,\n        rf: 298.3,\n        ellipseName: \"Krassovsky, 1942\"\n      };\n      exports.SEasia = {\n        a: 6378155.0,\n        b: 6356773.3205,\n        ellipseName: \"Southeast Asia\"\n      };\n      exports.walbeck = {\n        a: 6376896.0,\n        b: 6355834.8467,\n        ellipseName: \"Walbeck\"\n      };\n      exports.WGS60 = {\n        a: 6378165.0,\n        rf: 298.3,\n        ellipseName: \"WGS 60\"\n      };\n      exports.WGS66 = {\n        a: 6378145.0,\n        rf: 298.25,\n        ellipseName: \"WGS 66\"\n      };\n      exports.WGS7 = {\n        a: 6378135.0,\n        rf: 298.26,\n        ellipseName: \"WGS 72\"\n      };\n      exports.WGS84 = {\n        a: 6378137.0,\n        rf: 298.257223563,\n        ellipseName: \"WGS 84\"\n      };\n      exports.sphere = {\n        a: 6370997.0,\n        b: 6370997.0,\n        ellipseName: \"Normal Sphere (r=6370997)\"\n      };\n    }, {}],\n    27: [function (_dereq_, module, exports) {\n      exports.greenwich = 0.0; //\"0dE\",\n\n      exports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\n\n      exports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\n\n      exports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\n\n      exports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\n\n      exports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\n\n      exports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\n\n      exports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\n\n      exports.ferro = -17.666666666667; //\"17d40'W\",\n\n      exports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\n\n      exports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\n\n      exports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\n\n      exports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n    }, {}],\n    28: [function (_dereq_, module, exports) {\n      exports.ft = {\n        to_meter: 0.3048\n      };\n      exports['us-ft'] = {\n        to_meter: 1200 / 3937\n      };\n    }, {}],\n    29: [function (_dereq_, module, exports) {\n      var proj = _dereq_('./Proj');\n\n      var transform = _dereq_('./transform');\n\n      var wgs84 = proj('WGS84');\n\n      function transformer(from, to, coords) {\n        var transformedArray;\n\n        if (Array.isArray(coords)) {\n          transformedArray = transform(from, to, coords);\n\n          if (coords.length === 3) {\n            return [transformedArray.x, transformedArray.y, transformedArray.z];\n          } else {\n            return [transformedArray.x, transformedArray.y];\n          }\n        } else {\n          return transform(from, to, coords);\n        }\n      }\n\n      function checkProj(item) {\n        if (item instanceof proj) {\n          return item;\n        }\n\n        if (item.oProj) {\n          return item.oProj;\n        }\n\n        return proj(item);\n      }\n\n      function proj4(fromProj, toProj, coord) {\n        fromProj = checkProj(fromProj);\n        var single = false;\n        var obj;\n\n        if (typeof toProj === 'undefined') {\n          toProj = fromProj;\n          fromProj = wgs84;\n          single = true;\n        } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n          coord = toProj;\n          toProj = fromProj;\n          fromProj = wgs84;\n          single = true;\n        }\n\n        toProj = checkProj(toProj);\n\n        if (coord) {\n          return transformer(fromProj, toProj, coord);\n        } else {\n          obj = {\n            forward: function forward(coords) {\n              return transformer(fromProj, toProj, coords);\n            },\n            inverse: function inverse(coords) {\n              return transformer(toProj, fromProj, coords);\n            }\n          };\n\n          if (single) {\n            obj.oProj = toProj;\n          }\n\n          return obj;\n        }\n      }\n\n      module.exports = proj4;\n    }, {\n      \"./Proj\": 2,\n      \"./transform\": 65\n    }],\n    30: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n      var PJD_3PARAM = 1;\n      var PJD_7PARAM = 2;\n      var PJD_GRIDSHIFT = 3;\n      var PJD_WGS84 = 4; // WGS84 or equivalent\n\n      var PJD_NODATUM = 5; // WGS84 or equivalent\n\n      var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n      var AD_C = 1.0026000;\n      var COS_67P5 = 0.38268343236508977;\n\n      var datum = function datum(proj) {\n        if (!(this instanceof datum)) {\n          return new datum(proj);\n        }\n\n        this.datum_type = PJD_WGS84; //default setting\n\n        if (!proj) {\n          return;\n        }\n\n        if (proj.datumCode && proj.datumCode === 'none') {\n          this.datum_type = PJD_NODATUM;\n        }\n\n        if (proj.datum_params) {\n          this.datum_params = proj.datum_params.map(parseFloat);\n\n          if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {\n            this.datum_type = PJD_3PARAM;\n          }\n\n          if (this.datum_params.length > 3) {\n            if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {\n              this.datum_type = PJD_7PARAM;\n              this.datum_params[3] *= SEC_TO_RAD;\n              this.datum_params[4] *= SEC_TO_RAD;\n              this.datum_params[5] *= SEC_TO_RAD;\n              this.datum_params[6] = this.datum_params[6] / 1000000.0 + 1.0;\n            }\n          }\n        } // DGR 2011-03-21 : nadgrids support\n\n\n        this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;\n        this.a = proj.a; //datum object also uses these values\n\n        this.b = proj.b;\n        this.es = proj.es;\n        this.ep2 = proj.ep2;\n\n        if (this.datum_type === PJD_GRIDSHIFT) {\n          this.grids = proj.grids;\n        }\n      };\n\n      datum.prototype = {\n        /****************************************************************/\n        // cs_compare_datums()\n        //   Returns TRUE if the two datums match, otherwise FALSE.\n        compare_datums: function compare_datums(dest) {\n          if (this.datum_type !== dest.datum_type) {\n            return false; // false, datums are not equal\n          } else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {\n            // the tolerence for es is to ensure that GRS80 and WGS84\n            // are considered identical\n            return false;\n          } else if (this.datum_type === PJD_3PARAM) {\n            return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2];\n          } else if (this.datum_type === PJD_7PARAM) {\n            return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6];\n          } else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {\n            //alert(\"ERROR: Grid shift transformations are not implemented.\");\n            //return false\n            //DGR 2012-07-29 lazy ...\n            return this.nadgrids === dest.nadgrids;\n          } else {\n            return true; // datums are equal\n          }\n        },\n        // cs_compare_datums()\n\n        /*\n         * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n         * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n         * according to the current ellipsoid parameters.\n         *\n         *    Latitude  : Geodetic latitude in radians                     (input)\n         *    Longitude : Geodetic longitude in radians                    (input)\n         *    Height    : Geodetic height, in meters                       (input)\n         *    X         : Calculated Geocentric X coordinate, in meters    (output)\n         *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n         *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n         *\n         */\n        geodetic_to_geocentric: function geodetic_to_geocentric(p) {\n          var Longitude = p.x;\n          var Latitude = p.y;\n          var Height = p.z ? p.z : 0; //Z value not always supplied\n\n          var X; // output\n\n          var Y;\n          var Z;\n          var Error_Code = 0; //  GEOCENT_NO_ERROR;\n\n          var Rn;\n          /*  Earth radius at location  */\n\n          var Sin_Lat;\n          /*  Math.sin(Latitude)  */\n\n          var Sin2_Lat;\n          /*  Square of Math.sin(Latitude)  */\n\n          var Cos_Lat;\n          /*  Math.cos(Latitude)  */\n\n          /*\n           ** Don't blow up if Latitude is just a little out of the value\n           ** range as it may just be a rounding issue.  Also removed longitude\n           ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n           */\n\n          if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n            Latitude = -HALF_PI;\n          } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n            Latitude = HALF_PI;\n          } else if (Latitude < -HALF_PI || Latitude > HALF_PI) {\n            /* Latitude out of range */\n            //..reportError('geocent:lat out of range:' + Latitude);\n            return null;\n          }\n\n          if (Longitude > Math.PI) {\n            Longitude -= 2 * Math.PI;\n          }\n\n          Sin_Lat = Math.sin(Latitude);\n          Cos_Lat = Math.cos(Latitude);\n          Sin2_Lat = Sin_Lat * Sin_Lat;\n          Rn = this.a / Math.sqrt(1.0e0 - this.es * Sin2_Lat);\n          X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);\n          Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);\n          Z = (Rn * (1 - this.es) + Height) * Sin_Lat;\n          p.x = X;\n          p.y = Y;\n          p.z = Z;\n          return Error_Code;\n        },\n        // cs_geodetic_to_geocentric()\n        geocentric_to_geodetic: function geocentric_to_geodetic(p) {\n          /* local defintions and variables */\n\n          /* end-criterium of loop, accuracy of sin(Latitude) */\n          var genau = 1e-12;\n          var genau2 = genau * genau;\n          var maxiter = 30;\n          var P;\n          /* distance between semi-minor axis and location */\n\n          var RR;\n          /* distance between center and location */\n\n          var CT;\n          /* sin of geocentric latitude */\n\n          var ST;\n          /* cos of geocentric latitude */\n\n          var RX;\n          var RK;\n          var RN;\n          /* Earth radius at location */\n\n          var CPHI0;\n          /* cos of start or old geodetic latitude in iterations */\n\n          var SPHI0;\n          /* sin of start or old geodetic latitude in iterations */\n\n          var CPHI;\n          /* cos of searched geodetic latitude */\n\n          var SPHI;\n          /* sin of searched geodetic latitude */\n\n          var SDPHI;\n          /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n\n          var At_Pole;\n          /* indicates location is in polar region */\n\n          var iter;\n          /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n          var X = p.x;\n          var Y = p.y;\n          var Z = p.z ? p.z : 0.0; //Z value not always supplied\n\n          var Longitude;\n          var Latitude;\n          var Height;\n          At_Pole = false;\n          P = Math.sqrt(X * X + Y * Y);\n          RR = Math.sqrt(X * X + Y * Y + Z * Z);\n          /*      special cases for latitude and longitude */\n\n          if (P / this.a < genau) {\n            /*  special case, if P=0. (X=0., Y=0.) */\n            At_Pole = true;\n            Longitude = 0.0;\n            /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n             *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n\n            if (RR / this.a < genau) {\n              Latitude = HALF_PI;\n              Height = -this.b;\n              return;\n            }\n          } else {\n            /*  ellipsoidal (geodetic) longitude\n             *  interval: -PI < Longitude <= +PI */\n            Longitude = Math.atan2(Y, X);\n          }\n          /* --------------------------------------------------------------\n           * Following iterative algorithm was developped by\n           * \"Institut for Erdmessung\", University of Hannover, July 1988.\n           * Internet: www.ife.uni-hannover.de\n           * Iterative computation of CPHI,SPHI and Height.\n           * Iteration of CPHI and SPHI to 10**-12 radian resp.\n           * 2*10**-7 arcsec.\n           * --------------------------------------------------------------\n           */\n\n\n          CT = Z / RR;\n          ST = P / RR;\n          RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);\n          CPHI0 = ST * (1.0 - this.es) * RX;\n          SPHI0 = CT * RX;\n          iter = 0;\n          /* loop to find sin(Latitude) resp. Latitude\n           * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n\n          do {\n            iter++;\n            RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);\n            /*  ellipsoidal (geodetic) height */\n\n            Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);\n            RK = this.es * RN / (RN + Height);\n            RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n            CPHI = ST * (1.0 - RK) * RX;\n            SPHI = CT * RX;\n            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n            CPHI0 = CPHI;\n            SPHI0 = SPHI;\n          } while (SDPHI * SDPHI > genau2 && iter < maxiter);\n          /*      ellipsoidal (geodetic) latitude */\n\n\n          Latitude = Math.atan(SPHI / Math.abs(CPHI));\n          p.x = Longitude;\n          p.y = Latitude;\n          p.z = Height;\n          return p;\n        },\n        // cs_geocentric_to_geodetic()\n\n        /** Convert_Geocentric_To_Geodetic\n         * The method used here is derived from 'An Improved Algorithm for\n         * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996\n         */\n        geocentric_to_geodetic_noniter: function geocentric_to_geodetic_noniter(p) {\n          var X = p.x;\n          var Y = p.y;\n          var Z = p.z ? p.z : 0; //Z value not always supplied\n\n          var Longitude;\n          var Latitude;\n          var Height;\n          var W;\n          /* distance from Z axis */\n\n          var W2;\n          /* square of distance from Z axis */\n\n          var T0;\n          /* initial estimate of vertical component */\n\n          var T1;\n          /* corrected estimate of vertical component */\n\n          var S0;\n          /* initial estimate of horizontal component */\n\n          var S1;\n          /* corrected estimate of horizontal component */\n\n          var Sin_B0;\n          /* Math.sin(B0), B0 is estimate of Bowring aux variable */\n\n          var Sin3_B0;\n          /* cube of Math.sin(B0) */\n\n          var Cos_B0;\n          /* Math.cos(B0) */\n\n          var Sin_p1;\n          /* Math.sin(phi1), phi1 is estimated latitude */\n\n          var Cos_p1;\n          /* Math.cos(phi1) */\n\n          var Rn;\n          /* Earth radius at location */\n\n          var Sum;\n          /* numerator of Math.cos(phi1) */\n\n          var At_Pole;\n          /* indicates location is in polar region */\n\n          X = parseFloat(X); // cast from string to float\n\n          Y = parseFloat(Y);\n          Z = parseFloat(Z);\n          At_Pole = false;\n\n          if (X !== 0.0) {\n            Longitude = Math.atan2(Y, X);\n          } else {\n            if (Y > 0) {\n              Longitude = HALF_PI;\n            } else if (Y < 0) {\n              Longitude = -HALF_PI;\n            } else {\n              At_Pole = true;\n              Longitude = 0.0;\n\n              if (Z > 0.0) {\n                /* north pole */\n                Latitude = HALF_PI;\n              } else if (Z < 0.0) {\n                /* south pole */\n                Latitude = -HALF_PI;\n              } else {\n                /* center of earth */\n                Latitude = HALF_PI;\n                Height = -this.b;\n                return;\n              }\n            }\n          }\n\n          W2 = X * X + Y * Y;\n          W = Math.sqrt(W2);\n          T0 = Z * AD_C;\n          S0 = Math.sqrt(T0 * T0 + W2);\n          Sin_B0 = T0 / S0;\n          Cos_B0 = W / S0;\n          Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;\n          T1 = Z + this.b * this.ep2 * Sin3_B0;\n          Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;\n          S1 = Math.sqrt(T1 * T1 + Sum * Sum);\n          Sin_p1 = T1 / S1;\n          Cos_p1 = Sum / S1;\n          Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);\n\n          if (Cos_p1 >= COS_67P5) {\n            Height = W / Cos_p1 - Rn;\n          } else if (Cos_p1 <= -COS_67P5) {\n            Height = W / -Cos_p1 - Rn;\n          } else {\n            Height = Z / Sin_p1 + Rn * (this.es - 1.0);\n          }\n\n          if (At_Pole === false) {\n            Latitude = Math.atan(Sin_p1 / Cos_p1);\n          }\n\n          p.x = Longitude;\n          p.y = Latitude;\n          p.z = Height;\n          return p;\n        },\n        // geocentric_to_geodetic_noniter()\n\n        /****************************************************************/\n        // pj_geocentic_to_wgs84( p )\n        //  p = point to transform in geocentric coordinates (x,y,z)\n        geocentric_to_wgs84: function geocentric_to_wgs84(p) {\n          if (this.datum_type === PJD_3PARAM) {\n            // if( x[io] === HUGE_VAL )\n            //    continue;\n            p.x += this.datum_params[0];\n            p.y += this.datum_params[1];\n            p.z += this.datum_params[2];\n          } else if (this.datum_type === PJD_7PARAM) {\n            var Dx_BF = this.datum_params[0];\n            var Dy_BF = this.datum_params[1];\n            var Dz_BF = this.datum_params[2];\n            var Rx_BF = this.datum_params[3];\n            var Ry_BF = this.datum_params[4];\n            var Rz_BF = this.datum_params[5];\n            var M_BF = this.datum_params[6]; // if( x[io] === HUGE_VAL )\n            //    continue;\n\n            var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;\n            var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;\n            var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;\n            p.x = x_out;\n            p.y = y_out;\n            p.z = z_out;\n          }\n        },\n        // cs_geocentric_to_wgs84\n\n        /****************************************************************/\n        // pj_geocentic_from_wgs84()\n        //  coordinate system definition,\n        //  point to transform in geocentric coordinates (x,y,z)\n        geocentric_from_wgs84: function geocentric_from_wgs84(p) {\n          if (this.datum_type === PJD_3PARAM) {\n            //if( x[io] === HUGE_VAL )\n            //    continue;\n            p.x -= this.datum_params[0];\n            p.y -= this.datum_params[1];\n            p.z -= this.datum_params[2];\n          } else if (this.datum_type === PJD_7PARAM) {\n            var Dx_BF = this.datum_params[0];\n            var Dy_BF = this.datum_params[1];\n            var Dz_BF = this.datum_params[2];\n            var Rx_BF = this.datum_params[3];\n            var Ry_BF = this.datum_params[4];\n            var Rz_BF = this.datum_params[5];\n            var M_BF = this.datum_params[6];\n            var x_tmp = (p.x - Dx_BF) / M_BF;\n            var y_tmp = (p.y - Dy_BF) / M_BF;\n            var z_tmp = (p.z - Dz_BF) / M_BF; //if( x[io] === HUGE_VAL )\n            //    continue;\n\n            p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;\n            p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;\n            p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;\n          } //cs_geocentric_from_wgs84()\n\n        }\n      };\n      /** point object, nothing fancy, just allows values to be\n          passed back and forth by reference rather than by value.\n          Other point classes may be used as long as they have\n          x and y properties, which will get modified in the transform method.\n      */\n\n      module.exports = datum;\n    }, {}],\n    31: [function (_dereq_, module, exports) {\n      var PJD_3PARAM = 1;\n      var PJD_7PARAM = 2;\n      var PJD_GRIDSHIFT = 3;\n      var PJD_NODATUM = 5; // WGS84 or equivalent\n\n      var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms\n\n      var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29\n\n      module.exports = function (source, dest, point) {\n        var wp, i, l;\n\n        function checkParams(fallback) {\n          return fallback === PJD_3PARAM || fallback === PJD_7PARAM;\n        } // Short cut if the datums are identical.\n\n\n        if (source.compare_datums(dest)) {\n          return point; // in this case, zero is sucess,\n          // whereas cs_compare_datums returns 1 to indicate TRUE\n          // confusing, should fix this\n        } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n\n\n        if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n          return point;\n        } //DGR: 2012-07-29 : add nadgrids support (begin)\n\n\n        var src_a = source.a;\n        var src_es = source.es;\n        var dst_a = dest.a;\n        var dst_es = dest.es;\n        var fallback = source.datum_type; // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n        if (fallback === PJD_GRIDSHIFT) {\n          if (this.apply_gridshift(source, 0, point) === 0) {\n            source.a = SRS_WGS84_SEMIMAJOR;\n            source.es = SRS_WGS84_ESQUARED;\n          } else {\n            // try 3 or 7 params transformation or nothing ?\n            if (!source.datum_params) {\n              source.a = src_a;\n              source.es = source.es;\n              return point;\n            }\n\n            wp = 1;\n\n            for (i = 0, l = source.datum_params.length; i < l; i++) {\n              wp *= source.datum_params[i];\n            }\n\n            if (wp === 0) {\n              source.a = src_a;\n              source.es = source.es;\n              return point;\n            }\n\n            if (source.datum_params.length > 3) {\n              fallback = PJD_7PARAM;\n            } else {\n              fallback = PJD_3PARAM;\n            }\n          }\n        }\n\n        if (dest.datum_type === PJD_GRIDSHIFT) {\n          dest.a = SRS_WGS84_SEMIMAJOR;\n          dest.es = SRS_WGS84_ESQUARED;\n        } // Do we need to go through geocentric coordinates?\n\n\n        if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {\n          //DGR: 2012-07-29 : add nadgrids support (end)\n          // Convert to geocentric coordinates.\n          source.geodetic_to_geocentric(point); // CHECK_RETURN;\n          // Convert between datums\n\n          if (checkParams(source.datum_type)) {\n            source.geocentric_to_wgs84(point); // CHECK_RETURN;\n          }\n\n          if (checkParams(dest.datum_type)) {\n            dest.geocentric_from_wgs84(point); // CHECK_RETURN;\n          } // Convert back to geodetic coordinates\n\n\n          dest.geocentric_to_geodetic(point); // CHECK_RETURN;\n        } // Apply grid shift to destination if required\n\n\n        if (dest.datum_type === PJD_GRIDSHIFT) {\n          this.apply_gridshift(dest, 1, point); // CHECK_RETURN;\n        }\n\n        source.a = src_a;\n        source.es = src_es;\n        dest.a = dst_a;\n        dest.es = dst_es;\n        return point;\n      };\n    }, {}],\n    32: [function (_dereq_, module, exports) {\n      var globals = _dereq_('./global');\n\n      var parseProj = _dereq_('./projString');\n\n      var wkt = _dereq_('./wkt');\n\n      function defs(name) {\n        /*global console*/\n        var that = this;\n\n        if (arguments.length === 2) {\n          var def = arguments[1];\n\n          if (typeof def === 'string') {\n            if (def.charAt(0) === '+') {\n              defs[name] = parseProj(arguments[1]);\n            } else {\n              defs[name] = wkt(arguments[1]);\n            }\n          } else {\n            defs[name] = def;\n          }\n        } else if (arguments.length === 1) {\n          if (Array.isArray(name)) {\n            return name.map(function (v) {\n              if (Array.isArray(v)) {\n                defs.apply(that, v);\n              } else {\n                defs(v);\n              }\n            });\n          } else if (typeof name === 'string') {\n            if (name in defs) {\n              return defs[name];\n            }\n          } else if ('EPSG' in name) {\n            defs['EPSG:' + name.EPSG] = name;\n          } else if ('ESRI' in name) {\n            defs['ESRI:' + name.ESRI] = name;\n          } else if ('IAU2000' in name) {\n            defs['IAU2000:' + name.IAU2000] = name;\n          } else {\n            console.log(name);\n          }\n\n          return;\n        }\n      }\n\n      globals(defs);\n      module.exports = defs;\n    }, {\n      \"./global\": 35,\n      \"./projString\": 38,\n      \"./wkt\": 66\n    }],\n    33: [function (_dereq_, module, exports) {\n      var Datum = _dereq_('./constants/Datum');\n\n      var Ellipsoid = _dereq_('./constants/Ellipsoid');\n\n      var extend = _dereq_('./extend');\n\n      var datum = _dereq_('./datum');\n\n      var EPSLN = 1.0e-10; // ellipoid pj_set_ell.c\n\n      var SIXTH = 0.1666666666666666667;\n      /* 1/6 */\n\n      var RA4 = 0.04722222222222222222;\n      /* 17/360 */\n\n      var RA6 = 0.02215608465608465608;\n\n      module.exports = function (json) {\n        // DGR 2011-03-20 : nagrids -> nadgrids\n        if (json.datumCode && json.datumCode !== 'none') {\n          var datumDef = Datum[json.datumCode];\n\n          if (datumDef) {\n            json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n            json.ellps = datumDef.ellipse;\n            json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n          }\n        }\n\n        if (!json.a) {\n          // do we have an ellipsoid?\n          var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;\n          extend(json, ellipse);\n        }\n\n        if (json.rf && !json.b) {\n          json.b = (1.0 - 1.0 / json.rf) * json.a;\n        }\n\n        if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {\n          json.sphere = true;\n          json.b = json.a;\n        }\n\n        json.a2 = json.a * json.a; // used in geocentric\n\n        json.b2 = json.b * json.b; // used in geocentric\n\n        json.es = (json.a2 - json.b2) / json.a2; // e ^ 2\n\n        json.e = Math.sqrt(json.es); // eccentricity\n\n        if (json.R_A) {\n          json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));\n          json.a2 = json.a * json.a;\n          json.b2 = json.b * json.b;\n          json.es = 0;\n        }\n\n        json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric\n\n        if (!json.k0) {\n          json.k0 = 1.0; //default value\n        } //DGR 2010-11-12: axis\n\n\n        if (!json.axis) {\n          json.axis = \"enu\";\n        }\n\n        if (!json.datum) {\n          json.datum = datum(json);\n        }\n\n        return json;\n      };\n    }, {\n      \"./constants/Datum\": 25,\n      \"./constants/Ellipsoid\": 26,\n      \"./datum\": 30,\n      \"./extend\": 34\n    }],\n    34: [function (_dereq_, module, exports) {\n      module.exports = function (destination, source) {\n        destination = destination || {};\n        var value, property;\n\n        if (!source) {\n          return destination;\n        }\n\n        for (property in source) {\n          value = source[property];\n\n          if (value !== undefined) {\n            destination[property] = value;\n          }\n        }\n\n        return destination;\n      };\n    }, {}],\n    35: [function (_dereq_, module, exports) {\n      module.exports = function (defs) {\n        defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n        defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n        defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n        defs.WGS84 = defs['EPSG:4326'];\n        defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n\n        defs.GOOGLE = defs['EPSG:3857'];\n        defs['EPSG:900913'] = defs['EPSG:3857'];\n        defs['EPSG:102113'] = defs['EPSG:3857'];\n      };\n    }, {}],\n    36: [function (_dereq_, module, exports) {\n      var proj4 = _dereq_('./core');\n\n      proj4.defaultDatum = 'WGS84'; //default datum\n\n      proj4.Proj = _dereq_('./Proj');\n      proj4.WGS84 = new proj4.Proj('WGS84');\n      proj4.Point = _dereq_('./Point');\n      proj4.toPoint = _dereq_(\"./common/toPoint\");\n      proj4.defs = _dereq_('./defs');\n      proj4.transform = _dereq_('./transform');\n      proj4.mgrs = _dereq_('mgrs');\n      proj4.version = _dereq_('../package.json').version;\n\n      _dereq_('./includedProjections')(proj4);\n\n      module.exports = proj4;\n    }, {\n      \"../package.json\": 68,\n      \"./Point\": 1,\n      \"./Proj\": 2,\n      \"./common/toPoint\": 23,\n      \"./core\": 29,\n      \"./defs\": 32,\n      \"./includedProjections\": \"hTEDpn\",\n      \"./transform\": 65,\n      \"mgrs\": 67\n    }],\n    37: [function (_dereq_, module, exports) {\n      var defs = _dereq_('./defs');\n\n      var wkt = _dereq_('./wkt');\n\n      var projStr = _dereq_('./projString');\n\n      function testObj(code) {\n        return typeof code === 'string';\n      }\n\n      function testDef(code) {\n        return code in defs;\n      }\n\n      function testWKT(code) {\n        var codeWords = ['GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS'];\n        return codeWords.reduce(function (a, b) {\n          return a + 1 + code.indexOf(b);\n        }, 0);\n      }\n\n      function testProj(code) {\n        return code[0] === '+';\n      }\n\n      function parse(code) {\n        if (testObj(code)) {\n          //check to see if this is a WKT string\n          if (testDef(code)) {\n            return defs[code];\n          } else if (testWKT(code)) {\n            return wkt(code);\n          } else if (testProj(code)) {\n            return projStr(code);\n          }\n        } else {\n          return code;\n        }\n      }\n\n      module.exports = parse;\n    }, {\n      \"./defs\": 32,\n      \"./projString\": 38,\n      \"./wkt\": 66\n    }],\n    38: [function (_dereq_, module, exports) {\n      var D2R = 0.01745329251994329577;\n\n      var PrimeMeridian = _dereq_('./constants/PrimeMeridian');\n\n      var _units = _dereq_('./constants/units');\n\n      module.exports = function (defData) {\n        var self = {};\n        var paramObj = {};\n        defData.split(\"+\").map(function (v) {\n          return v.trim();\n        }).filter(function (a) {\n          return a;\n        }).forEach(function (a) {\n          var split = a.split(\"=\");\n          split.push(true);\n          paramObj[split[0].toLowerCase()] = split[1];\n        });\n        var paramName, paramVal, paramOutname;\n        var params = {\n          proj: 'projName',\n          datum: 'datumCode',\n          rf: function rf(v) {\n            self.rf = parseFloat(v);\n          },\n          lat_0: function lat_0(v) {\n            self.lat0 = v * D2R;\n          },\n          lat_1: function lat_1(v) {\n            self.lat1 = v * D2R;\n          },\n          lat_2: function lat_2(v) {\n            self.lat2 = v * D2R;\n          },\n          lat_ts: function lat_ts(v) {\n            self.lat_ts = v * D2R;\n          },\n          lon_0: function lon_0(v) {\n            self.long0 = v * D2R;\n          },\n          lon_1: function lon_1(v) {\n            self.long1 = v * D2R;\n          },\n          lon_2: function lon_2(v) {\n            self.long2 = v * D2R;\n          },\n          alpha: function alpha(v) {\n            self.alpha = parseFloat(v) * D2R;\n          },\n          lonc: function lonc(v) {\n            self.longc = v * D2R;\n          },\n          x_0: function x_0(v) {\n            self.x0 = parseFloat(v);\n          },\n          y_0: function y_0(v) {\n            self.y0 = parseFloat(v);\n          },\n          k_0: function k_0(v) {\n            self.k0 = parseFloat(v);\n          },\n          k: function k(v) {\n            self.k0 = parseFloat(v);\n          },\n          a: function a(v) {\n            self.a = parseFloat(v);\n          },\n          b: function b(v) {\n            self.b = parseFloat(v);\n          },\n          r_a: function r_a() {\n            self.R_A = true;\n          },\n          zone: function zone(v) {\n            self.zone = parseInt(v, 10);\n          },\n          south: function south() {\n            self.utmSouth = true;\n          },\n          towgs84: function towgs84(v) {\n            self.datum_params = v.split(\",\").map(function (a) {\n              return parseFloat(a);\n            });\n          },\n          to_meter: function to_meter(v) {\n            self.to_meter = parseFloat(v);\n          },\n          units: function units(v) {\n            self.units = v;\n\n            if (_units[v]) {\n              self.to_meter = _units[v].to_meter;\n            }\n          },\n          from_greenwich: function from_greenwich(v) {\n            self.from_greenwich = v * D2R;\n          },\n          pm: function pm(v) {\n            self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;\n          },\n          nadgrids: function nadgrids(v) {\n            if (v === '@null') {\n              self.datumCode = 'none';\n            } else {\n              self.nadgrids = v;\n            }\n          },\n          axis: function axis(v) {\n            var legalAxis = \"ewnsud\";\n\n            if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n              self.axis = v;\n            }\n          }\n        };\n\n        for (paramName in paramObj) {\n          paramVal = paramObj[paramName];\n\n          if (paramName in params) {\n            paramOutname = params[paramName];\n\n            if (typeof paramOutname === 'function') {\n              paramOutname(paramVal);\n            } else {\n              self[paramOutname] = paramVal;\n            }\n          } else {\n            self[paramName] = paramVal;\n          }\n        }\n\n        if (typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\") {\n          self.datumCode = self.datumCode.toLowerCase();\n        }\n\n        return self;\n      };\n    }, {\n      \"./constants/PrimeMeridian\": 27,\n      \"./constants/units\": 28\n    }],\n    39: [function (_dereq_, module, exports) {\n      var projs = [_dereq_('./projections/merc'), _dereq_('./projections/longlat')];\n      var names = {};\n      var projStore = [];\n\n      function add(proj, i) {\n        var len = projStore.length;\n\n        if (!proj.names) {\n          console.log(i);\n          return true;\n        }\n\n        projStore[len] = proj;\n        proj.names.forEach(function (n) {\n          names[n.toLowerCase()] = len;\n        });\n        return this;\n      }\n\n      exports.add = add;\n\n      exports.get = function (name) {\n        if (!name) {\n          return false;\n        }\n\n        var n = name.toLowerCase();\n\n        if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n          return projStore[names[n]];\n        }\n      };\n\n      exports.start = function () {\n        projs.forEach(add);\n      };\n    }, {\n      \"./projections/longlat\": 51,\n      \"./projections/merc\": 52\n    }],\n    40: [function (_dereq_, module, exports) {\n      var EPSLN = 1.0e-10;\n\n      var msfnz = _dereq_('../common/msfnz');\n\n      var qsfnz = _dereq_('../common/qsfnz');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var asinz = _dereq_('../common/asinz');\n\n      exports.init = function () {\n        if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n          return;\n        }\n\n        this.temp = this.b / this.a;\n        this.es = 1 - Math.pow(this.temp, 2);\n        this.e3 = Math.sqrt(this.es);\n        this.sin_po = Math.sin(this.lat1);\n        this.cos_po = Math.cos(this.lat1);\n        this.t1 = this.sin_po;\n        this.con = this.sin_po;\n        this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n        this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n        this.sin_po = Math.sin(this.lat2);\n        this.cos_po = Math.cos(this.lat2);\n        this.t2 = this.sin_po;\n        this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n        this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n        this.sin_po = Math.sin(this.lat0);\n        this.cos_po = Math.cos(this.lat0);\n        this.t3 = this.sin_po;\n        this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n        if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n          this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n        } else {\n          this.ns0 = this.con;\n        }\n\n        this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n        this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n      };\n      /* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n        -------------------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        this.sin_phi = Math.sin(lat);\n        this.cos_phi = Math.cos(lat);\n        var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n        var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n        var theta = this.ns0 * adjust_lon(lon - this.long0);\n        var x = rh1 * Math.sin(theta) + this.x0;\n        var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var rh1, qs, con, theta, lon, lat;\n        p.x -= this.x0;\n        p.y = this.rh - p.y + this.y0;\n\n        if (this.ns0 >= 0) {\n          rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n          con = 1;\n        } else {\n          rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n          con = -1;\n        }\n\n        theta = 0;\n\n        if (rh1 !== 0) {\n          theta = Math.atan2(con * p.x, con * p.y);\n        }\n\n        con = rh1 * this.ns0 / this.a;\n\n        if (this.sphere) {\n          lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n        } else {\n          qs = (this.c - con * con) / this.ns0;\n          lat = this.phi1z(this.e3, qs);\n        }\n\n        lon = adjust_lon(theta / this.ns0 + this.long0);\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n      /* Function to compute phi1, the latitude for the inverse of the\n         Albers Conical Equal-Area projection.\n      -------------------------------------------*/\n\n\n      exports.phi1z = function (eccent, qs) {\n        var sinphi, cosphi, con, com, dphi;\n        var phi = asinz(0.5 * qs);\n\n        if (eccent < EPSLN) {\n          return phi;\n        }\n\n        var eccnts = eccent * eccent;\n\n        for (var i = 1; i <= 25; i++) {\n          sinphi = Math.sin(phi);\n          cosphi = Math.cos(phi);\n          con = eccent * sinphi;\n          com = 1 - con * con;\n          dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n          phi = phi + dphi;\n\n          if (Math.abs(dphi) <= 1e-7) {\n            return phi;\n          }\n        }\n\n        return null;\n      };\n\n      exports.names = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6,\n      \"../common/msfnz\": 15,\n      \"../common/qsfnz\": 20\n    }],\n    41: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      var mlfn = _dereq_('../common/mlfn');\n\n      var e0fn = _dereq_('../common/e0fn');\n\n      var e1fn = _dereq_('../common/e1fn');\n\n      var e2fn = _dereq_('../common/e2fn');\n\n      var e3fn = _dereq_('../common/e3fn');\n\n      var gN = _dereq_('../common/gN');\n\n      var asinz = _dereq_('../common/asinz');\n\n      var imlfn = _dereq_('../common/imlfn');\n\n      exports.init = function () {\n        this.sin_p12 = Math.sin(this.lat0);\n        this.cos_p12 = Math.cos(this.lat0);\n      };\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var sinphi = Math.sin(p.y);\n        var cosphi = Math.cos(p.y);\n        var dlon = adjust_lon(lon - this.long0);\n        var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n\n        if (this.sphere) {\n          if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n            //North Pole case\n            p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n            p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n            return p;\n          } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n            //South Pole case\n            p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n            p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n            return p;\n          } else {\n            //default case\n            cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n            c = Math.acos(cos_c);\n            kp = c / Math.sin(c);\n            p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n            p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n            return p;\n          }\n        } else {\n          e0 = e0fn(this.es);\n          e1 = e1fn(this.es);\n          e2 = e2fn(this.es);\n          e3 = e3fn(this.es);\n\n          if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n            //North Pole case\n            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n            Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n            p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n            p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n            return p;\n          } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n            //South Pole case\n            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n            Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n            p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n            p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n            return p;\n          } else {\n            //Default case\n            tanphi = sinphi / cosphi;\n            Nl1 = gN(this.a, this.e, this.sin_p12);\n            Nl = gN(this.a, this.e, sinphi);\n            psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n            Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n\n            if (Az === 0) {\n              s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n            } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n              s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n            } else {\n              s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n            }\n\n            G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n            H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n            GH = G * H;\n            Hs = H * H;\n            s2 = s * s;\n            s3 = s2 * s;\n            s4 = s3 * s;\n            s5 = s4 * s;\n            c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n            p.x = this.x0 + c * Math.sin(Az);\n            p.y = this.y0 + c * Math.cos(Az);\n            return p;\n          }\n        }\n      };\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n\n        if (this.sphere) {\n          rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\n          if (rh > 2 * HALF_PI * this.a) {\n            return;\n          }\n\n          z = rh / this.a;\n          sinz = Math.sin(z);\n          cosz = Math.cos(z);\n          lon = this.long0;\n\n          if (Math.abs(rh) <= EPSLN) {\n            lat = this.lat0;\n          } else {\n            lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);\n            con = Math.abs(this.lat0) - HALF_PI;\n\n            if (Math.abs(con) <= EPSLN) {\n              if (this.lat0 >= 0) {\n                lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));\n              } else {\n                lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n              }\n            } else {\n              /*con = cosz - this.sin_p12 * Math.sin(lat);\n              if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n                //no-op, just keep the lon value as is\n              } else {\n                var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n                lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n              }*/\n              lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n            }\n          }\n\n          p.x = lon;\n          p.y = lat;\n          return p;\n        } else {\n          e0 = e0fn(this.es);\n          e1 = e1fn(this.es);\n          e2 = e2fn(this.es);\n          e3 = e3fn(this.es);\n\n          if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n            //North pole case\n            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n            rh = Math.sqrt(p.x * p.x + p.y * p.y);\n            M = Mlp - rh;\n            lat = imlfn(M / this.a, e0, e1, e2, e3);\n            lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));\n            p.x = lon;\n            p.y = lat;\n            return p;\n          } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n            //South pole case\n            Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n            rh = Math.sqrt(p.x * p.x + p.y * p.y);\n            M = rh - Mlp;\n            lat = imlfn(M / this.a, e0, e1, e2, e3);\n            lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n            p.x = lon;\n            p.y = lat;\n            return p;\n          } else {\n            //default case\n            rh = Math.sqrt(p.x * p.x + p.y * p.y);\n            Az = Math.atan2(p.x, p.y);\n            N1 = gN(this.a, this.e, this.sin_p12);\n            cosAz = Math.cos(Az);\n            tmp = this.e * this.cos_p12 * cosAz;\n            A = -tmp * tmp / (1 - this.es);\n            B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n            D = rh / N1;\n            Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n            F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n            psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n            lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n            lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n            p.x = lon;\n            p.y = lat;\n            return p;\n          }\n        }\n      };\n\n      exports.names = [\"Azimuthal_Equidistant\", \"aeqd\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6,\n      \"../common/e0fn\": 7,\n      \"../common/e1fn\": 8,\n      \"../common/e2fn\": 9,\n      \"../common/e3fn\": 10,\n      \"../common/gN\": 11,\n      \"../common/imlfn\": 12,\n      \"../common/mlfn\": 14\n    }],\n    42: [function (_dereq_, module, exports) {\n      var mlfn = _dereq_('../common/mlfn');\n\n      var e0fn = _dereq_('../common/e0fn');\n\n      var e1fn = _dereq_('../common/e1fn');\n\n      var e2fn = _dereq_('../common/e2fn');\n\n      var e3fn = _dereq_('../common/e3fn');\n\n      var gN = _dereq_('../common/gN');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var adjust_lat = _dereq_('../common/adjust_lat');\n\n      var imlfn = _dereq_('../common/imlfn');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      exports.init = function () {\n        if (!this.sphere) {\n          this.e0 = e0fn(this.es);\n          this.e1 = e1fn(this.es);\n          this.e2 = e2fn(this.es);\n          this.e3 = e3fn(this.es);\n          this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n        }\n      };\n      /* Cassini forward equations--mapping lat,long to x,y\n        -----------------------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        /* Forward equations\n            -----------------*/\n        var x, y;\n        var lam = p.x;\n        var phi = p.y;\n        lam = adjust_lon(lam - this.long0);\n\n        if (this.sphere) {\n          x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n          y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n        } else {\n          //ellipsoid\n          var sinphi = Math.sin(phi);\n          var cosphi = Math.cos(phi);\n          var nl = gN(this.a, this.e, sinphi);\n          var tl = Math.tan(phi) * Math.tan(phi);\n          var al = lam * Math.cos(phi);\n          var asq = al * al;\n          var cl = this.es * cosphi * cosphi / (1 - this.es);\n          var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n          x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n          y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n        }\n\n        p.x = x + this.x0;\n        p.y = y + this.y0;\n        return p;\n      };\n      /* Inverse equations\n        -----------------*/\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var x = p.x / this.a;\n        var y = p.y / this.a;\n        var phi, lam;\n\n        if (this.sphere) {\n          var dd = y + this.lat0;\n          phi = Math.asin(Math.sin(dd) * Math.cos(x));\n          lam = Math.atan2(Math.tan(x), Math.cos(dd));\n        } else {\n          /* ellipsoid */\n          var ml1 = this.ml0 / this.a + y;\n          var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n\n          if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n            p.x = this.long0;\n            p.y = HALF_PI;\n\n            if (y < 0) {\n              p.y *= -1;\n            }\n\n            return p;\n          }\n\n          var nl1 = gN(this.a, this.e, Math.sin(phi1));\n          var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n          var tl1 = Math.pow(Math.tan(phi1), 2);\n          var dl = x * this.a / nl1;\n          var dsq = dl * dl;\n          phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n          lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n        }\n\n        p.x = adjust_lon(lam + this.long0);\n        p.y = adjust_lat(phi);\n        return p;\n      };\n\n      exports.names = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\n    }, {\n      \"../common/adjust_lat\": 4,\n      \"../common/adjust_lon\": 5,\n      \"../common/e0fn\": 7,\n      \"../common/e1fn\": 8,\n      \"../common/e2fn\": 9,\n      \"../common/e3fn\": 10,\n      \"../common/gN\": 11,\n      \"../common/imlfn\": 12,\n      \"../common/mlfn\": 14\n    }],\n    43: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var qsfnz = _dereq_('../common/qsfnz');\n\n      var msfnz = _dereq_('../common/msfnz');\n\n      var iqsfnz = _dereq_('../common/iqsfnz');\n      /*\n        reference:  \n          \"Cartographic Projection Procedures for the UNIX Environment-\n          A User's Manual\" by Gerald I. Evenden,\n          USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n      */\n\n\n      exports.init = function () {\n        //no-op\n        if (!this.sphere) {\n          this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n        }\n      };\n      /* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n          ------------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var x, y;\n        /* Forward equations\n            -----------------*/\n\n        var dlon = adjust_lon(lon - this.long0);\n\n        if (this.sphere) {\n          x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n          y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n        } else {\n          var qs = qsfnz(this.e, Math.sin(lat));\n          x = this.x0 + this.a * this.k0 * dlon;\n          y = this.y0 + this.a * qs * 0.5 / this.k0;\n        }\n\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n      /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n          ------------------------------------------------------------*/\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var lon, lat;\n\n        if (this.sphere) {\n          lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));\n          lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));\n        } else {\n          lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n          lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"cea\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/iqsfnz\": 13,\n      \"../common/msfnz\": 15,\n      \"../common/qsfnz\": 20\n    }],\n    44: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var adjust_lat = _dereq_('../common/adjust_lat');\n\n      exports.init = function () {\n        this.x0 = this.x0 || 0;\n        this.y0 = this.y0 || 0;\n        this.lat0 = this.lat0 || 0;\n        this.long0 = this.long0 || 0;\n        this.lat_ts = this.lat_ts || 0;\n        this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n        this.rc = Math.cos(this.lat_ts);\n      }; // forward equations--mapping lat,long to x,y\n      // -----------------------------------------------------------------\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var dlon = adjust_lon(lon - this.long0);\n        var dlat = adjust_lat(lat - this.lat0);\n        p.x = this.x0 + this.a * dlon * this.rc;\n        p.y = this.y0 + this.a * dlat;\n        return p;\n      }; // inverse equations--mapping x,y to lat/long\n      // -----------------------------------------------------------------\n\n\n      exports.inverse = function (p) {\n        var x = p.x;\n        var y = p.y;\n        p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));\n        p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);\n        return p;\n      };\n\n      exports.names = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\n    }, {\n      \"../common/adjust_lat\": 4,\n      \"../common/adjust_lon\": 5\n    }],\n    45: [function (_dereq_, module, exports) {\n      var e0fn = _dereq_('../common/e0fn');\n\n      var e1fn = _dereq_('../common/e1fn');\n\n      var e2fn = _dereq_('../common/e2fn');\n\n      var e3fn = _dereq_('../common/e3fn');\n\n      var msfnz = _dereq_('../common/msfnz');\n\n      var mlfn = _dereq_('../common/mlfn');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var adjust_lat = _dereq_('../common/adjust_lat');\n\n      var imlfn = _dereq_('../common/imlfn');\n\n      var EPSLN = 1.0e-10;\n\n      exports.init = function () {\n        /* Place parameters in static storage for common use\n            -------------------------------------------------*/\n        // Standard Parallels cannot be equal and on opposite sides of the equator\n        if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n          return;\n        }\n\n        this.lat2 = this.lat2 || this.lat1;\n        this.temp = this.b / this.a;\n        this.es = 1 - Math.pow(this.temp, 2);\n        this.e = Math.sqrt(this.es);\n        this.e0 = e0fn(this.es);\n        this.e1 = e1fn(this.es);\n        this.e2 = e2fn(this.es);\n        this.e3 = e3fn(this.es);\n        this.sinphi = Math.sin(this.lat1);\n        this.cosphi = Math.cos(this.lat1);\n        this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n        this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n        if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n          this.ns = this.sinphi;\n        } else {\n          this.sinphi = Math.sin(this.lat2);\n          this.cosphi = Math.cos(this.lat2);\n          this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n          this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n          this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n        }\n\n        this.g = this.ml1 + this.ms1 / this.ns;\n        this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n        this.rh = this.a * (this.g - this.ml0);\n      };\n      /* Equidistant Conic forward equations--mapping lat,long to x,y\n        -----------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var rh1;\n        /* Forward equations\n            -----------------*/\n\n        if (this.sphere) {\n          rh1 = this.a * (this.g - lat);\n        } else {\n          var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n          rh1 = this.a * (this.g - ml);\n        }\n\n        var theta = this.ns * adjust_lon(lon - this.long0);\n        var x = this.x0 + rh1 * Math.sin(theta);\n        var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n      /* Inverse equations\n        -----------------*/\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y = this.rh - p.y + this.y0;\n        var con, rh1, lat, lon;\n\n        if (this.ns >= 0) {\n          rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n          con = 1;\n        } else {\n          rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n          con = -1;\n        }\n\n        var theta = 0;\n\n        if (rh1 !== 0) {\n          theta = Math.atan2(con * p.x, con * p.y);\n        }\n\n        if (this.sphere) {\n          lon = adjust_lon(this.long0 + theta / this.ns);\n          lat = adjust_lat(this.g - rh1 / this.a);\n          p.x = lon;\n          p.y = lat;\n          return p;\n        } else {\n          var ml = this.g - rh1 / this.a;\n          lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n          lon = adjust_lon(this.long0 + theta / this.ns);\n          p.x = lon;\n          p.y = lat;\n          return p;\n        }\n      };\n\n      exports.names = [\"Equidistant_Conic\", \"eqdc\"];\n    }, {\n      \"../common/adjust_lat\": 4,\n      \"../common/adjust_lon\": 5,\n      \"../common/e0fn\": 7,\n      \"../common/e1fn\": 8,\n      \"../common/e2fn\": 9,\n      \"../common/e3fn\": 10,\n      \"../common/imlfn\": 12,\n      \"../common/mlfn\": 14,\n      \"../common/msfnz\": 15\n    }],\n    46: [function (_dereq_, module, exports) {\n      var FORTPI = Math.PI / 4;\n\n      var srat = _dereq_('../common/srat');\n\n      var HALF_PI = Math.PI / 2;\n      var MAX_ITER = 20;\n\n      exports.init = function () {\n        var sphi = Math.sin(this.lat0);\n        var cphi = Math.cos(this.lat0);\n        cphi *= cphi;\n        this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n        this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n        this.phic0 = Math.asin(sphi / this.C);\n        this.ratexp = 0.5 * this.C * this.e;\n        this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n      };\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n        p.x = this.C * lon;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var DEL_TOL = 1e-14;\n        var lon = p.x / this.C;\n        var lat = p.y;\n        var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n\n        for (var i = MAX_ITER; i > 0; --i) {\n          lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;\n\n          if (Math.abs(lat - p.y) < DEL_TOL) {\n            break;\n          }\n\n          p.y = lat;\n        }\n        /* convergence failed */\n\n\n        if (!i) {\n          return null;\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"gauss\"];\n    }, {\n      \"../common/srat\": 22\n    }],\n    47: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var EPSLN = 1.0e-10;\n\n      var asinz = _dereq_('../common/asinz');\n      /*\n        reference:\n          Wolfram Mathworld \"Gnomonic Projection\"\n          http://mathworld.wolfram.com/GnomonicProjection.html\n          Accessed: 12th November 2009\n        */\n\n\n      exports.init = function () {\n        /* Place parameters in static storage for common use\n            -------------------------------------------------*/\n        this.sin_p14 = Math.sin(this.lat0);\n        this.cos_p14 = Math.cos(this.lat0); // Approximation for projecting points to the horizon (infinity)\n\n        this.infinity_dist = 1000 * this.a;\n        this.rc = 1;\n      };\n      /* Gnomonic forward equations--mapping lat,long to x,y\n          ---------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var sinphi, cosphi;\n        /* sin and cos value        */\n\n        var dlon;\n        /* delta longitude value      */\n\n        var coslon;\n        /* cos of longitude        */\n\n        var ksp;\n        /* scale factor          */\n\n        var g;\n        var x, y;\n        var lon = p.x;\n        var lat = p.y;\n        /* Forward equations\n            -----------------*/\n\n        dlon = adjust_lon(lon - this.long0);\n        sinphi = Math.sin(lat);\n        cosphi = Math.cos(lat);\n        coslon = Math.cos(dlon);\n        g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n        ksp = 1;\n\n        if (g > 0 || Math.abs(g) <= EPSLN) {\n          x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n          y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n        } else {\n          // Point is in the opposing hemisphere and is unprojectable\n          // We still need to return a reasonable point, so we project \n          // to infinity, on a bearing \n          // equivalent to the northern hemisphere equivalent\n          // This is a reasonable approximation for short shapes and lines that \n          // straddle the horizon.\n          x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n          y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n        }\n\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var rh;\n        /* Rho */\n\n        var sinc, cosc;\n        var c;\n        var lon, lat;\n        /* Inverse equations\n            -----------------*/\n\n        p.x = (p.x - this.x0) / this.a;\n        p.y = (p.y - this.y0) / this.a;\n        p.x /= this.k0;\n        p.y /= this.k0;\n\n        if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {\n          c = Math.atan2(rh, this.rc);\n          sinc = Math.sin(c);\n          cosc = Math.cos(c);\n          lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);\n          lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n          lon = adjust_lon(this.long0 + lon);\n        } else {\n          lat = this.phic0;\n          lon = 0;\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"gnom\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6\n    }],\n    48: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      exports.init = function () {\n        this.a = 6377397.155;\n        this.es = 0.006674372230614;\n        this.e = Math.sqrt(this.es);\n\n        if (!this.lat0) {\n          this.lat0 = 0.863937979737193;\n        }\n\n        if (!this.long0) {\n          this.long0 = 0.7417649320975901 - 0.308341501185665;\n        }\n        /* if scale not set default to 0.9999 */\n\n\n        if (!this.k0) {\n          this.k0 = 0.9999;\n        }\n\n        this.s45 = 0.785398163397448;\n        /* 45 */\n\n        this.s90 = 2 * this.s45;\n        this.fi0 = this.lat0;\n        this.e2 = this.es;\n        this.e = Math.sqrt(this.e2);\n        this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));\n        this.uq = 1.04216856380474;\n        this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n        this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n        this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n        this.k1 = this.k0;\n        this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n        this.s0 = 1.37008346281555;\n        this.n = Math.sin(this.s0);\n        this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n        this.ad = this.s90 - this.uq;\n      };\n      /* ellipsoid */\n\n      /* calculate xy from lat/lon */\n\n      /* Constants, identical to inverse transform function */\n\n\n      exports.forward = function (p) {\n        var gfi, u, deltav, s, d, eps, ro;\n        var lon = p.x;\n        var lat = p.y;\n        var delta_lon = adjust_lon(lon - this.long0);\n        /* Transformation */\n\n        gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);\n        u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n        deltav = -delta_lon * this.alfa;\n        s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n        d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n        eps = this.n * d;\n        ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n        p.y = ro * Math.cos(eps) / 1;\n        p.x = ro * Math.sin(eps) / 1;\n\n        if (!this.czech) {\n          p.y *= -1;\n          p.x *= -1;\n        }\n\n        return p;\n      };\n      /* calculate lat/lon from xy */\n\n\n      exports.inverse = function (p) {\n        var u, deltav, s, d, eps, ro, fi1;\n        var ok;\n        /* Transformation */\n\n        /* revert y, x*/\n\n        var tmp = p.x;\n        p.x = p.y;\n        p.y = tmp;\n\n        if (!this.czech) {\n          p.y *= -1;\n          p.x *= -1;\n        }\n\n        ro = Math.sqrt(p.x * p.x + p.y * p.y);\n        eps = Math.atan2(p.y, p.x);\n        d = eps / Math.sin(this.s0);\n        s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n        u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n        deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n        p.x = this.long0 - deltav / this.alfa;\n        fi1 = u;\n        ok = 0;\n        var iter = 0;\n\n        do {\n          p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n\n          if (Math.abs(fi1 - p.y) < 0.0000000001) {\n            ok = 1;\n          }\n\n          fi1 = p.y;\n          iter += 1;\n        } while (ok === 0 && iter < 15);\n\n        if (iter >= 15) {\n          return null;\n        }\n\n        return p;\n      };\n\n      exports.names = [\"Krovak\", \"krovak\"];\n    }, {\n      \"../common/adjust_lon\": 5\n    }],\n    49: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n      var FORTPI = Math.PI / 4;\n      var EPSLN = 1.0e-10;\n\n      var qsfnz = _dereq_('../common/qsfnz');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n      /*\n        reference\n          \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n          The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n        */\n\n\n      exports.S_POLE = 1;\n      exports.N_POLE = 2;\n      exports.EQUIT = 3;\n      exports.OBLIQ = 4;\n      /* Initialize the Lambert Azimuthal Equal Area projection\n        ------------------------------------------------------*/\n\n      exports.init = function () {\n        var t = Math.abs(this.lat0);\n\n        if (Math.abs(t - HALF_PI) < EPSLN) {\n          this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n        } else if (Math.abs(t) < EPSLN) {\n          this.mode = this.EQUIT;\n        } else {\n          this.mode = this.OBLIQ;\n        }\n\n        if (this.es > 0) {\n          var sinphi;\n          this.qp = qsfnz(this.e, 1);\n          this.mmf = 0.5 / (1 - this.es);\n          this.apa = this.authset(this.es);\n\n          switch (this.mode) {\n            case this.N_POLE:\n              this.dd = 1;\n              break;\n\n            case this.S_POLE:\n              this.dd = 1;\n              break;\n\n            case this.EQUIT:\n              this.rq = Math.sqrt(0.5 * this.qp);\n              this.dd = 1 / this.rq;\n              this.xmf = 1;\n              this.ymf = 0.5 * this.qp;\n              break;\n\n            case this.OBLIQ:\n              this.rq = Math.sqrt(0.5 * this.qp);\n              sinphi = Math.sin(this.lat0);\n              this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n              this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n              this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n              this.ymf = (this.xmf = this.rq) / this.dd;\n              this.xmf *= this.dd;\n              break;\n          }\n        } else {\n          if (this.mode === this.OBLIQ) {\n            this.sinph0 = Math.sin(this.lat0);\n            this.cosph0 = Math.cos(this.lat0);\n          }\n        }\n      };\n      /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n        -----------------------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        /* Forward equations\n            -----------------*/\n        var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n        var lam = p.x;\n        var phi = p.y;\n        lam = adjust_lon(lam - this.long0);\n\n        if (this.sphere) {\n          sinphi = Math.sin(phi);\n          cosphi = Math.cos(phi);\n          coslam = Math.cos(lam);\n\n          if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n            y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n\n            if (y <= EPSLN) {\n              return null;\n            }\n\n            y = Math.sqrt(2 / y);\n            x = y * cosphi * Math.sin(lam);\n            y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n            if (this.mode === this.N_POLE) {\n              coslam = -coslam;\n            }\n\n            if (Math.abs(phi + this.phi0) < EPSLN) {\n              return null;\n            }\n\n            y = FORTPI - phi * 0.5;\n            y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));\n            x = y * Math.sin(lam);\n            y *= coslam;\n          }\n        } else {\n          sinb = 0;\n          cosb = 0;\n          b = 0;\n          coslam = Math.cos(lam);\n          sinlam = Math.sin(lam);\n          sinphi = Math.sin(phi);\n          q = qsfnz(this.e, sinphi);\n\n          if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n            sinb = q / this.qp;\n            cosb = Math.sqrt(1 - sinb * sinb);\n          }\n\n          switch (this.mode) {\n            case this.OBLIQ:\n              b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n              break;\n\n            case this.EQUIT:\n              b = 1 + cosb * coslam;\n              break;\n\n            case this.N_POLE:\n              b = HALF_PI + phi;\n              q = this.qp - q;\n              break;\n\n            case this.S_POLE:\n              b = phi - HALF_PI;\n              q = this.qp + q;\n              break;\n          }\n\n          if (Math.abs(b) < EPSLN) {\n            return null;\n          }\n\n          switch (this.mode) {\n            case this.OBLIQ:\n            case this.EQUIT:\n              b = Math.sqrt(2 / b);\n\n              if (this.mode === this.OBLIQ) {\n                y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n              } else {\n                y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n              }\n\n              x = this.xmf * b * cosb * sinlam;\n              break;\n\n            case this.N_POLE:\n            case this.S_POLE:\n              if (q >= 0) {\n                x = (b = Math.sqrt(q)) * sinlam;\n                y = coslam * (this.mode === this.S_POLE ? b : -b);\n              } else {\n                x = y = 0;\n              }\n\n              break;\n          }\n        }\n\n        p.x = this.a * x + this.x0;\n        p.y = this.a * y + this.y0;\n        return p;\n      };\n      /* Inverse equations\n        -----------------*/\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var x = p.x / this.a;\n        var y = p.y / this.a;\n        var lam, phi, cCe, sCe, q, rho, ab;\n\n        if (this.sphere) {\n          var cosz = 0,\n              rh,\n              sinz = 0;\n          rh = Math.sqrt(x * x + y * y);\n          phi = rh * 0.5;\n\n          if (phi > 1) {\n            return null;\n          }\n\n          phi = 2 * Math.asin(phi);\n\n          if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n            sinz = Math.sin(phi);\n            cosz = Math.cos(phi);\n          }\n\n          switch (this.mode) {\n            case this.EQUIT:\n              phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);\n              x *= sinz;\n              y = cosz * rh;\n              break;\n\n            case this.OBLIQ:\n              phi = Math.abs(rh) <= EPSLN ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n              x *= sinz * this.cosph0;\n              y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n              break;\n\n            case this.N_POLE:\n              y = -y;\n              phi = HALF_PI - phi;\n              break;\n\n            case this.S_POLE:\n              phi -= HALF_PI;\n              break;\n          }\n\n          lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);\n        } else {\n          ab = 0;\n\n          if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n            x /= this.dd;\n            y *= this.dd;\n            rho = Math.sqrt(x * x + y * y);\n\n            if (rho < EPSLN) {\n              p.x = 0;\n              p.y = this.phi0;\n              return p;\n            }\n\n            sCe = 2 * Math.asin(0.5 * rho / this.rq);\n            cCe = Math.cos(sCe);\n            x *= sCe = Math.sin(sCe);\n\n            if (this.mode === this.OBLIQ) {\n              ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n              q = this.qp * ab;\n              y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n            } else {\n              ab = y * sCe / rho;\n              q = this.qp * ab;\n              y = rho * cCe;\n            }\n          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n            if (this.mode === this.N_POLE) {\n              y = -y;\n            }\n\n            q = x * x + y * y;\n\n            if (!q) {\n              p.x = 0;\n              p.y = this.phi0;\n              return p;\n            }\n\n            ab = 1 - q / this.qp;\n\n            if (this.mode === this.S_POLE) {\n              ab = -ab;\n            }\n          }\n\n          lam = Math.atan2(x, y);\n          phi = this.authlat(Math.asin(ab), this.apa);\n        }\n\n        p.x = adjust_lon(this.long0 + lam);\n        p.y = phi;\n        return p;\n      };\n      /* determine latitude from authalic latitude */\n\n\n      exports.P00 = 0.33333333333333333333;\n      exports.P01 = 0.17222222222222222222;\n      exports.P02 = 0.10257936507936507936;\n      exports.P10 = 0.06388888888888888888;\n      exports.P11 = 0.06640211640211640211;\n      exports.P20 = 0.01641501294219154443;\n\n      exports.authset = function (es) {\n        var t;\n        var APA = [];\n        APA[0] = es * this.P00;\n        t = es * es;\n        APA[0] += t * this.P01;\n        APA[1] = t * this.P10;\n        t *= es;\n        APA[0] += t * this.P02;\n        APA[1] += t * this.P11;\n        APA[2] = t * this.P20;\n        return APA;\n      };\n\n      exports.authlat = function (beta, APA) {\n        var t = beta + beta;\n        return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);\n      };\n\n      exports.names = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/qsfnz\": 20\n    }],\n    50: [function (_dereq_, module, exports) {\n      var EPSLN = 1.0e-10;\n\n      var msfnz = _dereq_('../common/msfnz');\n\n      var tsfnz = _dereq_('../common/tsfnz');\n\n      var HALF_PI = Math.PI / 2;\n\n      var sign = _dereq_('../common/sign');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var phi2z = _dereq_('../common/phi2z');\n\n      exports.init = function () {\n        // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n        //double c_lat;                   /* center latitude                      */\n        //double c_lon;                   /* center longitude                     */\n        //double lat1;                    /* first standard parallel              */\n        //double lat2;                    /* second standard parallel             */\n        //double r_maj;                   /* major axis                           */\n        //double r_min;                   /* minor axis                           */\n        //double false_east;              /* x offset in meters                   */\n        //double false_north;             /* y offset in meters                   */\n        if (!this.lat2) {\n          this.lat2 = this.lat1;\n        } //if lat2 is not defined\n\n\n        if (!this.k0) {\n          this.k0 = 1;\n        }\n\n        this.x0 = this.x0 || 0;\n        this.y0 = this.y0 || 0; // Standard Parallels cannot be equal and on opposite sides of the equator\n\n        if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n          return;\n        }\n\n        var temp = this.b / this.a;\n        this.e = Math.sqrt(1 - temp * temp);\n        var sin1 = Math.sin(this.lat1);\n        var cos1 = Math.cos(this.lat1);\n        var ms1 = msfnz(this.e, sin1, cos1);\n        var ts1 = tsfnz(this.e, this.lat1, sin1);\n        var sin2 = Math.sin(this.lat2);\n        var cos2 = Math.cos(this.lat2);\n        var ms2 = msfnz(this.e, sin2, cos2);\n        var ts2 = tsfnz(this.e, this.lat2, sin2);\n        var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n        if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n          this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n        } else {\n          this.ns = sin1;\n        }\n\n        if (isNaN(this.ns)) {\n          this.ns = sin1;\n        }\n\n        this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n        this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n\n        if (!this.title) {\n          this.title = \"Lambert Conformal Conic\";\n        }\n      }; // Lambert Conformal conic forward equations--mapping lat,long to x,y\n      // -----------------------------------------------------------------\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y; // singular cases :\n\n        if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n          lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n        }\n\n        var con = Math.abs(Math.abs(lat) - HALF_PI);\n        var ts, rh1;\n\n        if (con > EPSLN) {\n          ts = tsfnz(this.e, lat, Math.sin(lat));\n          rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n        } else {\n          con = lat * this.ns;\n\n          if (con <= 0) {\n            return null;\n          }\n\n          rh1 = 0;\n        }\n\n        var theta = this.ns * adjust_lon(lon - this.long0);\n        p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n        p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n        return p;\n      }; // Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n      // -----------------------------------------------------------------\n\n\n      exports.inverse = function (p) {\n        var rh1, con, ts;\n        var lat, lon;\n        var x = (p.x - this.x0) / this.k0;\n        var y = this.rh - (p.y - this.y0) / this.k0;\n\n        if (this.ns > 0) {\n          rh1 = Math.sqrt(x * x + y * y);\n          con = 1;\n        } else {\n          rh1 = -Math.sqrt(x * x + y * y);\n          con = -1;\n        }\n\n        var theta = 0;\n\n        if (rh1 !== 0) {\n          theta = Math.atan2(con * x, con * y);\n        }\n\n        if (rh1 !== 0 || this.ns > 0) {\n          con = 1 / this.ns;\n          ts = Math.pow(rh1 / (this.a * this.f0), con);\n          lat = phi2z(this.e, ts);\n\n          if (lat === -9999) {\n            return null;\n          }\n        } else {\n          lat = -HALF_PI;\n        }\n\n        lon = adjust_lon(theta / this.ns + this.long0);\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_2SP\", \"lcc\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/msfnz\": 15,\n      \"../common/phi2z\": 16,\n      \"../common/sign\": 21,\n      \"../common/tsfnz\": 24\n    }],\n    51: [function (_dereq_, module, exports) {\n      exports.init = function () {//no-op for longlat\n      };\n\n      function identity(pt) {\n        return pt;\n      }\n\n      exports.forward = identity;\n      exports.inverse = identity;\n      exports.names = [\"longlat\", \"identity\"];\n    }, {}],\n    52: [function (_dereq_, module, exports) {\n      var msfnz = _dereq_('../common/msfnz');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n      var R2D = 57.29577951308232088;\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var FORTPI = Math.PI / 4;\n\n      var tsfnz = _dereq_('../common/tsfnz');\n\n      var phi2z = _dereq_('../common/phi2z');\n\n      exports.init = function () {\n        var con = this.b / this.a;\n        this.es = 1 - con * con;\n\n        if (!('x0' in this)) {\n          this.x0 = 0;\n        }\n\n        if (!('y0' in this)) {\n          this.y0 = 0;\n        }\n\n        this.e = Math.sqrt(this.es);\n\n        if (this.lat_ts) {\n          if (this.sphere) {\n            this.k0 = Math.cos(this.lat_ts);\n          } else {\n            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n          }\n        } else {\n          if (!this.k0) {\n            if (this.k) {\n              this.k0 = this.k;\n            } else {\n              this.k0 = 1;\n            }\n          }\n        }\n      };\n      /* Mercator forward equations--mapping lat,long to x,y\n        --------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y; // convert to radians\n\n        if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n          return null;\n        }\n\n        var x, y;\n\n        if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n          return null;\n        } else {\n          if (this.sphere) {\n            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n            y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n          } else {\n            var sinphi = Math.sin(lat);\n            var ts = tsfnz(this.e, lat, sinphi);\n            x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n            y = this.y0 - this.a * this.k0 * Math.log(ts);\n          }\n\n          p.x = x;\n          p.y = y;\n          return p;\n        }\n      };\n      /* Mercator inverse equations--mapping x,y to lat/long\n        --------------------------------------------------*/\n\n\n      exports.inverse = function (p) {\n        var x = p.x - this.x0;\n        var y = p.y - this.y0;\n        var lon, lat;\n\n        if (this.sphere) {\n          lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n        } else {\n          var ts = Math.exp(-y / (this.a * this.k0));\n          lat = phi2z(this.e, ts);\n\n          if (lat === -9999) {\n            return null;\n          }\n        }\n\n        lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/msfnz\": 15,\n      \"../common/phi2z\": 16,\n      \"../common/tsfnz\": 24\n    }],\n    53: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n      /*\n        reference\n          \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n          The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n        */\n\n      /* Initialize the Miller Cylindrical projection\n        -------------------------------------------*/\n\n\n      exports.init = function () {//no-op\n      };\n      /* Miller Cylindrical forward equations--mapping lat,long to x,y\n          ------------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        /* Forward equations\n            -----------------*/\n\n        var dlon = adjust_lon(lon - this.long0);\n        var x = this.x0 + this.a * dlon;\n        var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n      /* Miller Cylindrical inverse equations--mapping x,y to lat/long\n          ------------------------------------------------------------*/\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var lon = adjust_lon(this.long0 + p.x / this.a);\n        var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Miller_Cylindrical\", \"mill\"];\n    }, {\n      \"../common/adjust_lon\": 5\n    }],\n    54: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var EPSLN = 1.0e-10;\n\n      exports.init = function () {};\n      /* Mollweide forward equations--mapping lat,long to x,y\n          ----------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        /* Forward equations\n            -----------------*/\n        var lon = p.x;\n        var lat = p.y;\n        var delta_lon = adjust_lon(lon - this.long0);\n        var theta = lat;\n        var con = Math.PI * Math.sin(lat);\n        /* Iterate using the Newton-Raphson method to find theta\n            -----------------------------------------------------*/\n\n        for (var i = 0; true; i++) {\n          var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n          theta += delta_theta;\n\n          if (Math.abs(delta_theta) < EPSLN) {\n            break;\n          }\n        }\n\n        theta /= 2;\n        /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n             this is done here because of precision problems with \"cos(theta)\"\n             --------------------------------------------------------------------------*/\n\n        if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n          delta_lon = 0;\n        }\n\n        var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n        var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var theta;\n        var arg;\n        /* Inverse equations\n            -----------------*/\n\n        p.x -= this.x0;\n        p.y -= this.y0;\n        arg = p.y / (1.4142135623731 * this.a);\n        /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n             a number very close to one is used instead.\n             -------------------------------------------------------------------*/\n\n        if (Math.abs(arg) > 0.999999999999) {\n          arg = 0.999999999999;\n        }\n\n        theta = Math.asin(arg);\n        var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));\n\n        if (lon < -Math.PI) {\n          lon = -Math.PI;\n        }\n\n        if (lon > Math.PI) {\n          lon = Math.PI;\n        }\n\n        arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n\n        if (Math.abs(arg) > 1) {\n          arg = 1;\n        }\n\n        var lat = Math.asin(arg);\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Mollweide\", \"moll\"];\n    }, {\n      \"../common/adjust_lon\": 5\n    }],\n    55: [function (_dereq_, module, exports) {\n      var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n      /*\n        reference\n          Department of Land and Survey Technical Circular 1973/32\n            http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n          OSG Technical Report 4.1\n            http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n        */\n\n      /**\n       * iterations: Number of iterations to refine inverse transform.\n       *     0 -> km accuracy\n       *     1 -> m accuracy -- suitable for most mapping applications\n       *     2 -> mm accuracy\n       */\n\n      exports.iterations = 1;\n\n      exports.init = function () {\n        this.A = [];\n        this.A[1] = 0.6399175073;\n        this.A[2] = -0.1358797613;\n        this.A[3] = 0.063294409;\n        this.A[4] = -0.02526853;\n        this.A[5] = 0.0117879;\n        this.A[6] = -0.0055161;\n        this.A[7] = 0.0026906;\n        this.A[8] = -0.001333;\n        this.A[9] = 0.00067;\n        this.A[10] = -0.00034;\n        this.B_re = [];\n        this.B_im = [];\n        this.B_re[1] = 0.7557853228;\n        this.B_im[1] = 0;\n        this.B_re[2] = 0.249204646;\n        this.B_im[2] = 0.003371507;\n        this.B_re[3] = -0.001541739;\n        this.B_im[3] = 0.041058560;\n        this.B_re[4] = -0.10162907;\n        this.B_im[4] = 0.01727609;\n        this.B_re[5] = -0.26623489;\n        this.B_im[5] = -0.36249218;\n        this.B_re[6] = -0.6870983;\n        this.B_im[6] = -1.1651967;\n        this.C_re = [];\n        this.C_im = [];\n        this.C_re[1] = 1.3231270439;\n        this.C_im[1] = 0;\n        this.C_re[2] = -0.577245789;\n        this.C_im[2] = -0.007809598;\n        this.C_re[3] = 0.508307513;\n        this.C_im[3] = -0.112208952;\n        this.C_re[4] = -0.15094762;\n        this.C_im[4] = 0.18200602;\n        this.C_re[5] = 1.01418179;\n        this.C_im[5] = 1.64497696;\n        this.C_re[6] = 1.9660549;\n        this.C_im[6] = 2.5127645;\n        this.D = [];\n        this.D[1] = 1.5627014243;\n        this.D[2] = 0.5185406398;\n        this.D[3] = -0.03333098;\n        this.D[4] = -0.1052906;\n        this.D[5] = -0.0368594;\n        this.D[6] = 0.007317;\n        this.D[7] = 0.01220;\n        this.D[8] = 0.00394;\n        this.D[9] = -0.0013;\n      };\n      /**\n          New Zealand Map Grid Forward  - long/lat to x/y\n          long/lat in radians\n        */\n\n\n      exports.forward = function (p) {\n        var n;\n        var lon = p.x;\n        var lat = p.y;\n        var delta_lat = lat - this.lat0;\n        var delta_lon = lon - this.long0; // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n        // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n\n        var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n        var d_lambda = delta_lon;\n        var d_phi_n = 1; // d_phi^0\n\n        var d_psi = 0;\n\n        for (n = 1; n <= 10; n++) {\n          d_phi_n = d_phi_n * d_phi;\n          d_psi = d_psi + this.A[n] * d_phi_n;\n        } // 2. Calculate theta\n\n\n        var th_re = d_psi;\n        var th_im = d_lambda; // 3. Calculate z\n\n        var th_n_re = 1;\n        var th_n_im = 0; // theta^0\n\n        var th_n_re1;\n        var th_n_im1;\n        var z_re = 0;\n        var z_im = 0;\n\n        for (n = 1; n <= 6; n++) {\n          th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n          th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n          th_n_re = th_n_re1;\n          th_n_im = th_n_im1;\n          z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n          z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n        } // 4. Calculate easting and northing\n\n\n        p.x = z_im * this.a + this.x0;\n        p.y = z_re * this.a + this.y0;\n        return p;\n      };\n      /**\n          New Zealand Map Grid Inverse  -  x/y to long/lat\n        */\n\n\n      exports.inverse = function (p) {\n        var n;\n        var x = p.x;\n        var y = p.y;\n        var delta_x = x - this.x0;\n        var delta_y = y - this.y0; // 1. Calculate z\n\n        var z_re = delta_y / this.a;\n        var z_im = delta_x / this.a; // 2a. Calculate theta - first approximation gives km accuracy\n\n        var z_n_re = 1;\n        var z_n_im = 0; // z^0\n\n        var z_n_re1;\n        var z_n_im1;\n        var th_re = 0;\n        var th_im = 0;\n\n        for (n = 1; n <= 6; n++) {\n          z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n          z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n          z_n_re = z_n_re1;\n          z_n_im = z_n_im1;\n          th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n          th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n        } // 2b. Iterate to refine the accuracy of the calculation\n        //        0 iterations gives km accuracy\n        //        1 iteration gives m accuracy -- good enough for most mapping applications\n        //        2 iterations bives mm accuracy\n\n\n        for (var i = 0; i < this.iterations; i++) {\n          var th_n_re = th_re;\n          var th_n_im = th_im;\n          var th_n_re1;\n          var th_n_im1;\n          var num_re = z_re;\n          var num_im = z_im;\n\n          for (n = 2; n <= 6; n++) {\n            th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n            th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n            th_n_re = th_n_re1;\n            th_n_im = th_n_im1;\n            num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n            num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n          }\n\n          th_n_re = 1;\n          th_n_im = 0;\n          var den_re = this.B_re[1];\n          var den_im = this.B_im[1];\n\n          for (n = 2; n <= 6; n++) {\n            th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n            th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n            th_n_re = th_n_re1;\n            th_n_im = th_n_im1;\n            den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n            den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n          } // Complex division\n\n\n          var den2 = den_re * den_re + den_im * den_im;\n          th_re = (num_re * den_re + num_im * den_im) / den2;\n          th_im = (num_im * den_re - num_re * den_im) / den2;\n        } // 3. Calculate d_phi              ...                                    // and d_lambda\n\n\n        var d_psi = th_re;\n        var d_lambda = th_im;\n        var d_psi_n = 1; // d_psi^0\n\n        var d_phi = 0;\n\n        for (n = 1; n <= 9; n++) {\n          d_psi_n = d_psi_n * d_psi;\n          d_phi = d_phi + this.D[n] * d_psi_n;\n        } // 4. Calculate latitude and longitude\n        // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n\n\n        var lat = this.lat0 + d_phi * SEC_TO_RAD * 1E5;\n        var lon = this.long0 + d_lambda;\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"New_Zealand_Map_Grid\", \"nzmg\"];\n    }, {}],\n    56: [function (_dereq_, module, exports) {\n      var tsfnz = _dereq_('../common/tsfnz');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var phi2z = _dereq_('../common/phi2z');\n\n      var HALF_PI = Math.PI / 2;\n      var FORTPI = Math.PI / 4;\n      var EPSLN = 1.0e-10;\n      /* Initialize the Oblique Mercator  projection\n          ------------------------------------------*/\n\n      exports.init = function () {\n        this.no_off = this.no_off || false;\n        this.no_rot = this.no_rot || false;\n\n        if (isNaN(this.k0)) {\n          this.k0 = 1;\n        }\n\n        var sinlat = Math.sin(this.lat0);\n        var coslat = Math.cos(this.lat0);\n        var con = this.e * sinlat;\n        this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n        this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n        var t0 = tsfnz(this.e, this.lat0, sinlat);\n        var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n\n        if (dl * dl < 1) {\n          dl = 1;\n        }\n\n        var fl;\n        var gl;\n\n        if (!isNaN(this.longc)) {\n          //Central point and azimuth method\n          if (this.lat0 >= 0) {\n            fl = dl + Math.sqrt(dl * dl - 1);\n          } else {\n            fl = dl - Math.sqrt(dl * dl - 1);\n          }\n\n          this.el = fl * Math.pow(t0, this.bl);\n          gl = 0.5 * (fl - 1 / fl);\n          this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n          this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n        } else {\n          //2 points method\n          var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));\n          var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));\n\n          if (this.lat0 >= 0) {\n            this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n          } else {\n            this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n          }\n\n          var hl = Math.pow(t1, this.bl);\n          var ll = Math.pow(t2, this.bl);\n          fl = this.el / hl;\n          gl = 0.5 * (fl - 1 / fl);\n          var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n          var pl = (ll - hl) / (ll + hl);\n          var dlon12 = adjust_lon(this.long1 - this.long2);\n          this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * dlon12) / pl) / this.bl;\n          this.long0 = adjust_lon(this.long0);\n          var dlon10 = adjust_lon(this.long1 - this.long0);\n          this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl);\n          this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n        }\n\n        if (this.no_off) {\n          this.uc = 0;\n        } else {\n          if (this.lat0 >= 0) {\n            this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n          } else {\n            this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n          }\n        }\n      };\n      /* Oblique Mercator forward equations--mapping lat,long to x,y\n          ----------------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var dlon = adjust_lon(lon - this.long0);\n        var us, vs;\n        var con;\n\n        if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n          if (lat > 0) {\n            con = -1;\n          } else {\n            con = 1;\n          }\n\n          vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));\n          us = -1 * con * HALF_PI * this.al / this.bl;\n        } else {\n          var t = tsfnz(this.e, lat, Math.sin(lat));\n          var ql = this.el / Math.pow(t, this.bl);\n          var sl = 0.5 * (ql - 1 / ql);\n          var tl = 0.5 * (ql + 1 / ql);\n          var vl = Math.sin(this.bl * dlon);\n          var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n\n          if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {\n            vs = Number.POSITIVE_INFINITY;\n          } else {\n            vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n          }\n\n          if (Math.abs(Math.cos(this.bl * dlon)) <= EPSLN) {\n            us = this.al * this.bl * dlon;\n          } else {\n            us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n          }\n        }\n\n        if (this.no_rot) {\n          p.x = this.x0 + us;\n          p.y = this.y0 + vs;\n        } else {\n          us -= this.uc;\n          p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n          p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n        }\n\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var us, vs;\n\n        if (this.no_rot) {\n          vs = p.y - this.y0;\n          us = p.x - this.x0;\n        } else {\n          vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n          us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n          us += this.uc;\n        }\n\n        var qp = Math.exp(-1 * this.bl * vs / this.al);\n        var sp = 0.5 * (qp - 1 / qp);\n        var tp = 0.5 * (qp + 1 / qp);\n        var vp = Math.sin(this.bl * us / this.al);\n        var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n        var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n\n        if (Math.abs(up - 1) < EPSLN) {\n          p.x = this.long0;\n          p.y = HALF_PI;\n        } else if (Math.abs(up + 1) < EPSLN) {\n          p.x = this.long0;\n          p.y = -1 * HALF_PI;\n        } else {\n          p.y = phi2z(this.e, ts);\n          p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n        }\n\n        return p;\n      };\n\n      exports.names = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"omerc\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/phi2z\": 16,\n      \"../common/tsfnz\": 24\n    }],\n    57: [function (_dereq_, module, exports) {\n      var e0fn = _dereq_('../common/e0fn');\n\n      var e1fn = _dereq_('../common/e1fn');\n\n      var e2fn = _dereq_('../common/e2fn');\n\n      var e3fn = _dereq_('../common/e3fn');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var adjust_lat = _dereq_('../common/adjust_lat');\n\n      var mlfn = _dereq_('../common/mlfn');\n\n      var EPSLN = 1.0e-10;\n\n      var gN = _dereq_('../common/gN');\n\n      var MAX_ITER = 20;\n\n      exports.init = function () {\n        /* Place parameters in static storage for common use\n            -------------------------------------------------*/\n        this.temp = this.b / this.a;\n        this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n\n        this.e = Math.sqrt(this.es);\n        this.e0 = e0fn(this.es);\n        this.e1 = e1fn(this.es);\n        this.e2 = e2fn(this.es);\n        this.e3 = e3fn(this.es);\n        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n      };\n      /* Polyconic forward equations--mapping lat,long to x,y\n          ---------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var x, y, el;\n        var dlon = adjust_lon(lon - this.long0);\n        el = dlon * Math.sin(lat);\n\n        if (this.sphere) {\n          if (Math.abs(lat) <= EPSLN) {\n            x = this.a * dlon;\n            y = -1 * this.a * this.lat0;\n          } else {\n            x = this.a * Math.sin(el) / Math.tan(lat);\n            y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n          }\n        } else {\n          if (Math.abs(lat) <= EPSLN) {\n            x = this.a * dlon;\n            y = -1 * this.ml0;\n          } else {\n            var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n            x = nl * Math.sin(el);\n            y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n          }\n        }\n\n        p.x = x + this.x0;\n        p.y = y + this.y0;\n        return p;\n      };\n      /* Inverse equations\n        -----------------*/\n\n\n      exports.inverse = function (p) {\n        var lon, lat, x, y, i;\n        var al, bl;\n        var phi, dphi;\n        x = p.x - this.x0;\n        y = p.y - this.y0;\n\n        if (this.sphere) {\n          if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n            lon = adjust_lon(x / this.a + this.long0);\n            lat = 0;\n          } else {\n            al = this.lat0 + y / this.a;\n            bl = x * x / this.a / this.a + al * al;\n            phi = al;\n            var tanphi;\n\n            for (i = MAX_ITER; i; --i) {\n              tanphi = Math.tan(phi);\n              dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n              phi += dphi;\n\n              if (Math.abs(dphi) <= EPSLN) {\n                lat = phi;\n                break;\n              }\n            }\n\n            lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));\n          }\n        } else {\n          if (Math.abs(y + this.ml0) <= EPSLN) {\n            lat = 0;\n            lon = adjust_lon(this.long0 + x / this.a);\n          } else {\n            al = (this.ml0 + y) / this.a;\n            bl = x * x / this.a / this.a + al * al;\n            phi = al;\n            var cl, mln, mlnp, ma;\n            var con;\n\n            for (i = MAX_ITER; i; --i) {\n              con = this.e * Math.sin(phi);\n              cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n              mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n              mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n              ma = mln / this.a;\n              dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n              phi -= dphi;\n\n              if (Math.abs(dphi) <= EPSLN) {\n                lat = phi;\n                break;\n              }\n            } //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n\n\n            cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n            lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n          }\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Polyconic\", \"poly\"];\n    }, {\n      \"../common/adjust_lat\": 4,\n      \"../common/adjust_lon\": 5,\n      \"../common/e0fn\": 7,\n      \"../common/e1fn\": 8,\n      \"../common/e2fn\": 9,\n      \"../common/e3fn\": 10,\n      \"../common/gN\": 11,\n      \"../common/mlfn\": 14\n    }],\n    58: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var adjust_lat = _dereq_('../common/adjust_lat');\n\n      var pj_enfn = _dereq_('../common/pj_enfn');\n\n      var MAX_ITER = 20;\n\n      var pj_mlfn = _dereq_('../common/pj_mlfn');\n\n      var pj_inv_mlfn = _dereq_('../common/pj_inv_mlfn');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      var asinz = _dereq_('../common/asinz');\n\n      exports.init = function () {\n        /* Place parameters in static storage for common use\n          -------------------------------------------------*/\n        if (!this.sphere) {\n          this.en = pj_enfn(this.es);\n        } else {\n          this.n = 1;\n          this.m = 0;\n          this.es = 0;\n          this.C_y = Math.sqrt((this.m + 1) / this.n);\n          this.C_x = this.C_y / (this.m + 1);\n        }\n      };\n      /* Sinusoidal forward equations--mapping lat,long to x,y\n        -----------------------------------------------------*/\n\n\n      exports.forward = function (p) {\n        var x, y;\n        var lon = p.x;\n        var lat = p.y;\n        /* Forward equations\n          -----------------*/\n\n        lon = adjust_lon(lon - this.long0);\n\n        if (this.sphere) {\n          if (!this.m) {\n            lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n          } else {\n            var k = this.n * Math.sin(lat);\n\n            for (var i = MAX_ITER; i; --i) {\n              var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n              lat -= V;\n\n              if (Math.abs(V) < EPSLN) {\n                break;\n              }\n            }\n          }\n\n          x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n          y = this.a * this.C_y * lat;\n        } else {\n          var s = Math.sin(lat);\n          var c = Math.cos(lat);\n          y = this.a * pj_mlfn(lat, s, c, this.en);\n          x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n        }\n\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var lat, temp, lon, s;\n        p.x -= this.x0;\n        lon = p.x / this.a;\n        p.y -= this.y0;\n        lat = p.y / this.a;\n\n        if (this.sphere) {\n          lat /= this.C_y;\n          lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n\n          if (this.m) {\n            lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n          } else if (this.n !== 1) {\n            lat = asinz(Math.sin(lat) / this.n);\n          }\n\n          lon = adjust_lon(lon + this.long0);\n          lat = adjust_lat(lat);\n        } else {\n          lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n          s = Math.abs(lat);\n\n          if (s < HALF_PI) {\n            s = Math.sin(lat);\n            temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)); //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n\n            lon = adjust_lon(temp);\n          } else if (s - EPSLN < HALF_PI) {\n            lon = this.long0;\n          }\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Sinusoidal\", \"sinu\"];\n    }, {\n      \"../common/adjust_lat\": 4,\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6,\n      \"../common/pj_enfn\": 17,\n      \"../common/pj_inv_mlfn\": 18,\n      \"../common/pj_mlfn\": 19\n    }],\n    59: [function (_dereq_, module, exports) {\n      /*\n        references:\n          Formules et constantes pour le Calcul pour la\n          projection cylindrique conforme à axe oblique et pour la transformation entre\n          des systèmes de référence.\n          http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n        */\n      exports.init = function () {\n        var phy0 = this.lat0;\n        this.lambda0 = this.long0;\n        var sinPhy0 = Math.sin(phy0);\n        var semiMajorAxis = this.a;\n        var invF = this.rf;\n        var flattening = 1 / invF;\n        var e2 = 2 * flattening - Math.pow(flattening, 2);\n        var e = this.e = Math.sqrt(e2);\n        this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n        this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n        this.b0 = Math.asin(sinPhy0 / this.alpha);\n        var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n        var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n        var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n        this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n      };\n\n      exports.forward = function (p) {\n        var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n        var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n        var S = -this.alpha * (Sa1 + Sa2) + this.K; // spheric latitude\n\n        var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4); // spheric longitude\n\n        var I = this.alpha * (p.x - this.lambda0); // psoeudo equatorial rotation\n\n        var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n        var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n        p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n        p.x = this.R * rotI + this.x0;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var Y = p.x - this.x0;\n        var X = p.y - this.y0;\n        var rotI = Y / this.R;\n        var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n        var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n        var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n        var lambda = this.lambda0 + I / this.alpha;\n        var S = 0;\n        var phy = b;\n        var prevPhy = -1000;\n        var iteration = 0;\n\n        while (Math.abs(phy - prevPhy) > 0.0000001) {\n          if (++iteration > 20) {\n            //...reportError(\"omercFwdInfinity\");\n            return;\n          } //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n\n\n          S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n          prevPhy = phy;\n          phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n        }\n\n        p.x = lambda;\n        p.y = phy;\n        return p;\n      };\n\n      exports.names = [\"somerc\"];\n    }, {}],\n    60: [function (_dereq_, module, exports) {\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      var sign = _dereq_('../common/sign');\n\n      var msfnz = _dereq_('../common/msfnz');\n\n      var tsfnz = _dereq_('../common/tsfnz');\n\n      var phi2z = _dereq_('../common/phi2z');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      exports.ssfn_ = function (phit, sinphi, eccen) {\n        sinphi *= eccen;\n        return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);\n      };\n\n      exports.init = function () {\n        this.coslat0 = Math.cos(this.lat0);\n        this.sinlat0 = Math.sin(this.lat0);\n\n        if (this.sphere) {\n          if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n            this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n          }\n        } else {\n          if (Math.abs(this.coslat0) <= EPSLN) {\n            if (this.lat0 > 0) {\n              //North pole\n              //trace('stere:north pole');\n              this.con = 1;\n            } else {\n              //South pole\n              //trace('stere:south pole');\n              this.con = -1;\n            }\n          }\n\n          this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n\n          if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n            this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n          }\n\n          this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n          this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n          this.cosX0 = Math.cos(this.X0);\n          this.sinX0 = Math.sin(this.X0);\n        }\n      }; // Stereographic forward equations--mapping lat,long to x,y\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var sinlat = Math.sin(lat);\n        var coslat = Math.cos(lat);\n        var A, X, sinX, cosX, ts, rh;\n        var dlon = adjust_lon(lon - this.long0);\n\n        if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n          //case of the origine point\n          //trace('stere:this is the origin point');\n          p.x = NaN;\n          p.y = NaN;\n          return p;\n        }\n\n        if (this.sphere) {\n          //trace('stere:sphere case');\n          A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n          p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n          p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n          return p;\n        } else {\n          X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n          cosX = Math.cos(X);\n          sinX = Math.sin(X);\n\n          if (Math.abs(this.coslat0) <= EPSLN) {\n            ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n            rh = 2 * this.a * this.k0 * ts / this.cons;\n            p.x = this.x0 + rh * Math.sin(lon - this.long0);\n            p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0); //trace(p.toString());\n\n            return p;\n          } else if (Math.abs(this.sinlat0) < EPSLN) {\n            //Eq\n            //trace('stere:equateur');\n            A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n            p.y = A * sinX;\n          } else {\n            //other case\n            //trace('stere:normal case');\n            A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n            p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n          }\n\n          p.x = A * cosX * Math.sin(dlon) + this.x0;\n        } //trace(p.toString());\n\n\n        return p;\n      }; //* Stereographic inverse equations--mapping x,y to lat/long\n\n\n      exports.inverse = function (p) {\n        p.x -= this.x0;\n        p.y -= this.y0;\n        var lon, lat, ts, ce, Chi;\n        var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\n        if (this.sphere) {\n          var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));\n          lon = this.long0;\n          lat = this.lat0;\n\n          if (rh <= EPSLN) {\n            p.x = lon;\n            p.y = lat;\n            return p;\n          }\n\n          lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n\n          if (Math.abs(this.coslat0) < EPSLN) {\n            if (this.lat0 > 0) {\n              lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));\n            } else {\n              lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n            }\n          } else {\n            lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n          }\n\n          p.x = lon;\n          p.y = lat;\n          return p;\n        } else {\n          if (Math.abs(this.coslat0) <= EPSLN) {\n            if (rh <= EPSLN) {\n              lat = this.lat0;\n              lon = this.long0;\n              p.x = lon;\n              p.y = lat; //trace(p.toString());\n\n              return p;\n            }\n\n            p.x *= this.con;\n            p.y *= this.con;\n            ts = rh * this.cons / (2 * this.a * this.k0);\n            lat = this.con * phi2z(this.e, ts);\n            lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));\n          } else {\n            ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n            lon = this.long0;\n\n            if (rh <= EPSLN) {\n              Chi = this.X0;\n            } else {\n              Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n              lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n            }\n\n            lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n          }\n        }\n\n        p.x = lon;\n        p.y = lat; //trace(p.toString());\n\n        return p;\n      };\n\n      exports.names = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/msfnz\": 15,\n      \"../common/phi2z\": 16,\n      \"../common/sign\": 21,\n      \"../common/tsfnz\": 24\n    }],\n    61: [function (_dereq_, module, exports) {\n      var gauss = _dereq_('./gauss');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      exports.init = function () {\n        gauss.init.apply(this);\n\n        if (!this.rc) {\n          return;\n        }\n\n        this.sinc0 = Math.sin(this.phic0);\n        this.cosc0 = Math.cos(this.phic0);\n        this.R2 = 2 * this.rc;\n\n        if (!this.title) {\n          this.title = \"Oblique Stereographic Alternative\";\n        }\n      };\n\n      exports.forward = function (p) {\n        var sinc, cosc, cosl, k;\n        p.x = adjust_lon(p.x - this.long0);\n        gauss.forward.apply(this, [p]);\n        sinc = Math.sin(p.y);\n        cosc = Math.cos(p.y);\n        cosl = Math.cos(p.x);\n        k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n        p.x = k * cosc * Math.sin(p.x);\n        p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n        p.x = this.a * p.x + this.x0;\n        p.y = this.a * p.y + this.y0;\n        return p;\n      };\n\n      exports.inverse = function (p) {\n        var sinc, cosc, lon, lat, rho;\n        p.x = (p.x - this.x0) / this.a;\n        p.y = (p.y - this.y0) / this.a;\n        p.x /= this.k0;\n        p.y /= this.k0;\n\n        if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {\n          var c = 2 * Math.atan2(rho, this.R2);\n          sinc = Math.sin(c);\n          cosc = Math.cos(c);\n          lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n          lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n        } else {\n          lat = this.phic0;\n          lon = 0;\n        }\n\n        p.x = lon;\n        p.y = lat;\n        gauss.inverse.apply(this, [p]);\n        p.x = adjust_lon(p.x + this.long0);\n        return p;\n      };\n\n      exports.names = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\", \"Oblique Stereographic Alternative\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"./gauss\": 46\n    }],\n    62: [function (_dereq_, module, exports) {\n      var e0fn = _dereq_('../common/e0fn');\n\n      var e1fn = _dereq_('../common/e1fn');\n\n      var e2fn = _dereq_('../common/e2fn');\n\n      var e3fn = _dereq_('../common/e3fn');\n\n      var mlfn = _dereq_('../common/mlfn');\n\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      var sign = _dereq_('../common/sign');\n\n      var asinz = _dereq_('../common/asinz');\n\n      exports.init = function () {\n        this.e0 = e0fn(this.es);\n        this.e1 = e1fn(this.es);\n        this.e2 = e2fn(this.es);\n        this.e3 = e3fn(this.es);\n        this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n      };\n      /**\n          Transverse Mercator Forward  - long/lat to x/y\n          long/lat in radians\n        */\n\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        var delta_lon = adjust_lon(lon - this.long0);\n        var con;\n        var x, y;\n        var sin_phi = Math.sin(lat);\n        var cos_phi = Math.cos(lat);\n\n        if (this.sphere) {\n          var b = cos_phi * Math.sin(delta_lon);\n\n          if (Math.abs(Math.abs(b) - 1) < 0.0000000001) {\n            return 93;\n          } else {\n            x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));\n            con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));\n\n            if (lat < 0) {\n              con = -con;\n            }\n\n            y = this.a * this.k0 * (con - this.lat0);\n          }\n        } else {\n          var al = cos_phi * delta_lon;\n          var als = Math.pow(al, 2);\n          var c = this.ep2 * Math.pow(cos_phi, 2);\n          var tq = Math.tan(lat);\n          var t = Math.pow(tq, 2);\n          con = 1 - this.es * Math.pow(sin_phi, 2);\n          var n = this.a / Math.sqrt(con);\n          var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n          x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;\n          y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;\n        }\n\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n      /**\n          Transverse Mercator Inverse  -  x/y to long/lat\n        */\n\n\n      exports.inverse = function (p) {\n        var con, phi;\n        var delta_phi;\n        var i;\n        var max_iter = 6;\n        var lat, lon;\n\n        if (this.sphere) {\n          var f = Math.exp(p.x / (this.a * this.k0));\n          var g = 0.5 * (f - 1 / f);\n          var temp = this.lat0 + p.y / (this.a * this.k0);\n          var h = Math.cos(temp);\n          con = Math.sqrt((1 - h * h) / (1 + g * g));\n          lat = asinz(con);\n\n          if (temp < 0) {\n            lat = -lat;\n          }\n\n          if (g === 0 && h === 0) {\n            lon = this.long0;\n          } else {\n            lon = adjust_lon(Math.atan2(g, h) + this.long0);\n          }\n        } else {\n          // ellipsoidal form\n          var x = p.x - this.x0;\n          var y = p.y - this.y0;\n          con = (this.ml0 + y / this.k0) / this.a;\n          phi = con;\n\n          for (i = 0; true; i++) {\n            delta_phi = (con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0 - phi;\n            phi += delta_phi;\n\n            if (Math.abs(delta_phi) <= EPSLN) {\n              break;\n            }\n\n            if (i >= max_iter) {\n              return 95;\n            }\n          } // for()\n\n\n          if (Math.abs(phi) < HALF_PI) {\n            var sin_phi = Math.sin(phi);\n            var cos_phi = Math.cos(phi);\n            var tan_phi = Math.tan(phi);\n            var c = this.ep2 * Math.pow(cos_phi, 2);\n            var cs = Math.pow(c, 2);\n            var t = Math.pow(tan_phi, 2);\n            var ts = Math.pow(t, 2);\n            con = 1 - this.es * Math.pow(sin_phi, 2);\n            var n = this.a / Math.sqrt(con);\n            var r = n * (1 - this.es) / con;\n            var d = x / (n * this.k0);\n            var ds = Math.pow(d, 2);\n            lat = phi - n * tan_phi * ds / r * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));\n            lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi);\n          } else {\n            lat = HALF_PI * sign(y);\n            lon = this.long0;\n          }\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6,\n      \"../common/e0fn\": 7,\n      \"../common/e1fn\": 8,\n      \"../common/e2fn\": 9,\n      \"../common/e3fn\": 10,\n      \"../common/mlfn\": 14,\n      \"../common/sign\": 21\n    }],\n    63: [function (_dereq_, module, exports) {\n      var D2R = 0.01745329251994329577;\n\n      var tmerc = _dereq_('./tmerc');\n\n      exports.dependsOn = 'tmerc';\n\n      exports.init = function () {\n        if (!this.zone) {\n          return;\n        }\n\n        this.lat0 = 0;\n        this.long0 = (6 * Math.abs(this.zone) - 183) * D2R;\n        this.x0 = 500000;\n        this.y0 = this.utmSouth ? 10000000 : 0;\n        this.k0 = 0.9996;\n        tmerc.init.apply(this);\n        this.forward = tmerc.forward;\n        this.inverse = tmerc.inverse;\n      };\n\n      exports.names = [\"Universal Transverse Mercator System\", \"utm\"];\n    }, {\n      \"./tmerc\": 62\n    }],\n    64: [function (_dereq_, module, exports) {\n      var adjust_lon = _dereq_('../common/adjust_lon');\n\n      var HALF_PI = Math.PI / 2;\n      var EPSLN = 1.0e-10;\n\n      var asinz = _dereq_('../common/asinz');\n      /* Initialize the Van Der Grinten projection\n        ----------------------------------------*/\n\n\n      exports.init = function () {\n        //this.R = 6370997; //Radius of earth\n        this.R = this.a;\n      };\n\n      exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        /* Forward equations\n          -----------------*/\n\n        var dlon = adjust_lon(lon - this.long0);\n        var x, y;\n\n        if (Math.abs(lat) <= EPSLN) {\n          x = this.x0 + this.R * dlon;\n          y = this.y0;\n        }\n\n        var theta = asinz(2 * Math.abs(lat / Math.PI));\n\n        if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n          x = this.x0;\n\n          if (lat >= 0) {\n            y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n          } else {\n            y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n          } //  return(OK);\n\n        }\n\n        var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);\n        var asq = al * al;\n        var sinth = Math.sin(theta);\n        var costh = Math.cos(theta);\n        var g = costh / (sinth + costh - 1);\n        var gsq = g * g;\n        var m = g * (2 / sinth - 1);\n        var msq = m * m;\n        var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n\n        if (dlon < 0) {\n          con = -con;\n        }\n\n        x = this.x0 + con; //con = Math.abs(con / (Math.PI * this.R));\n\n        var q = asq + g;\n        con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n\n        if (lat >= 0) {\n          //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n          y = this.y0 + con;\n        } else {\n          //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n          y = this.y0 - con;\n        }\n\n        p.x = x;\n        p.y = y;\n        return p;\n      };\n      /* Van Der Grinten inverse equations--mapping x,y to lat/long\n        ---------------------------------------------------------*/\n\n\n      exports.inverse = function (p) {\n        var lon, lat;\n        var xx, yy, xys, c1, c2, c3;\n        var a1;\n        var m1;\n        var con;\n        var th1;\n        var d;\n        /* inverse equations\n          -----------------*/\n\n        p.x -= this.x0;\n        p.y -= this.y0;\n        con = Math.PI * this.R;\n        xx = p.x / con;\n        yy = p.y / con;\n        xys = xx * xx + yy * yy;\n        c1 = -Math.abs(yy) * (1 + xys);\n        c2 = c1 - 2 * yy * yy + xx * xx;\n        c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n        d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n        a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n        m1 = 2 * Math.sqrt(-a1 / 3);\n        con = 3 * d / a1 / m1;\n\n        if (Math.abs(con) > 1) {\n          if (con >= 0) {\n            con = 1;\n          } else {\n            con = -1;\n          }\n        }\n\n        th1 = Math.acos(con) / 3;\n\n        if (p.y >= 0) {\n          lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n        } else {\n          lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n        }\n\n        if (Math.abs(xx) < EPSLN) {\n          lon = this.long0;\n        } else {\n          lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n        }\n\n        p.x = lon;\n        p.y = lat;\n        return p;\n      };\n\n      exports.names = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\n    }, {\n      \"../common/adjust_lon\": 5,\n      \"../common/asinz\": 6\n    }],\n    65: [function (_dereq_, module, exports) {\n      var D2R = 0.01745329251994329577;\n      var R2D = 57.29577951308232088;\n      var PJD_3PARAM = 1;\n      var PJD_7PARAM = 2;\n\n      var datum_transform = _dereq_('./datum_transform');\n\n      var adjust_axis = _dereq_('./adjust_axis');\n\n      var proj = _dereq_('./Proj');\n\n      var toPoint = _dereq_('./common/toPoint');\n\n      module.exports = function transform(source, dest, point) {\n        var wgs84;\n\n        if (Array.isArray(point)) {\n          point = toPoint(point);\n        }\n\n        function checkNotWGS(source, dest) {\n          return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== \"WGS84\";\n        } // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n\n\n        if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {\n          wgs84 = new proj('WGS84');\n          transform(source, wgs84, point);\n          source = wgs84;\n        } // DGR, 2010/11/12\n\n\n        if (source.axis !== \"enu\") {\n          adjust_axis(source, false, point);\n        } // Transform source points to long/lat, if they aren't already.\n\n\n        if (source.projName === \"longlat\") {\n          point.x *= D2R; // convert degrees to radians\n\n          point.y *= D2R;\n        } else {\n          if (source.to_meter) {\n            point.x *= source.to_meter;\n            point.y *= source.to_meter;\n          }\n\n          source.inverse(point); // Convert Cartesian to longlat\n        } // Adjust for the prime meridian if necessary\n\n\n        if (source.from_greenwich) {\n          point.x += source.from_greenwich;\n        } // Convert datums if needed, and if possible.\n\n\n        point = datum_transform(source.datum, dest.datum, point); // Adjust for the prime meridian if necessary\n\n        if (dest.from_greenwich) {\n          point.x -= dest.from_greenwich;\n        }\n\n        if (dest.projName === \"longlat\") {\n          // convert radians to decimal degrees\n          point.x *= R2D;\n          point.y *= R2D;\n        } else {\n          // else project\n          dest.forward(point);\n\n          if (dest.to_meter) {\n            point.x /= dest.to_meter;\n            point.y /= dest.to_meter;\n          }\n        } // DGR, 2010/11/12\n\n\n        if (dest.axis !== \"enu\") {\n          adjust_axis(dest, true, point);\n        }\n\n        return point;\n      };\n    }, {\n      \"./Proj\": 2,\n      \"./adjust_axis\": 3,\n      \"./common/toPoint\": 23,\n      \"./datum_transform\": 31\n    }],\n    66: [function (_dereq_, module, exports) {\n      var D2R = 0.01745329251994329577;\n\n      var extend = _dereq_('./extend');\n\n      function mapit(obj, key, v) {\n        obj[key] = v.map(function (aa) {\n          var o = {};\n          sExpr(aa, o);\n          return o;\n        }).reduce(function (a, b) {\n          return extend(a, b);\n        }, {});\n      }\n\n      function sExpr(v, obj) {\n        var key;\n\n        if (!Array.isArray(v)) {\n          obj[v] = true;\n          return;\n        } else {\n          key = v.shift();\n\n          if (key === 'PARAMETER') {\n            key = v.shift();\n          }\n\n          if (v.length === 1) {\n            if (Array.isArray(v[0])) {\n              obj[key] = {};\n              sExpr(v[0], obj[key]);\n            } else {\n              obj[key] = v[0];\n            }\n          } else if (!v.length) {\n            obj[key] = true;\n          } else if (key === 'TOWGS84') {\n            obj[key] = v;\n          } else {\n            obj[key] = {};\n\n            if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {\n              obj[key] = {\n                name: v[0].toLowerCase(),\n                convert: v[1]\n              };\n\n              if (v.length === 3) {\n                obj[key].auth = v[2];\n              }\n            } else if (key === 'SPHEROID') {\n              obj[key] = {\n                name: v[0],\n                a: v[1],\n                rf: v[2]\n              };\n\n              if (v.length === 4) {\n                obj[key].auth = v[3];\n              }\n            } else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {\n              v[0] = ['name', v[0]];\n              mapit(obj, key, v);\n            } else if (v.every(function (aa) {\n              return Array.isArray(aa);\n            })) {\n              mapit(obj, key, v);\n            } else {\n              sExpr(v, obj[key]);\n            }\n          }\n        }\n      }\n\n      function rename(obj, params) {\n        var outName = params[0];\n        var inName = params[1];\n\n        if (!(outName in obj) && inName in obj) {\n          obj[outName] = obj[inName];\n\n          if (params.length === 3) {\n            obj[outName] = params[2](obj[outName]);\n          }\n        }\n      }\n\n      function d2r(input) {\n        return input * D2R;\n      }\n\n      function cleanWKT(wkt) {\n        if (wkt.type === 'GEOGCS') {\n          wkt.projName = 'longlat';\n        } else if (wkt.type === 'LOCAL_CS') {\n          wkt.projName = 'identity';\n          wkt.local = true;\n        } else {\n          if (_typeof(wkt.PROJECTION) === \"object\") {\n            wkt.projName = Object.keys(wkt.PROJECTION)[0];\n          } else {\n            wkt.projName = wkt.PROJECTION;\n          }\n        }\n\n        if (wkt.UNIT) {\n          wkt.units = wkt.UNIT.name.toLowerCase();\n\n          if (wkt.units === 'metre') {\n            wkt.units = 'meter';\n          }\n\n          if (wkt.UNIT.convert) {\n            if (wkt.type === 'GEOGCS') {\n              if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n                wkt.to_meter = parseFloat(wkt.UNIT.convert, 10) * wkt.DATUM.SPHEROID.a;\n              }\n            } else {\n              wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);\n            }\n          }\n        }\n\n        if (wkt.GEOGCS) {\n          //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n          //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n          //}\n          if (wkt.GEOGCS.DATUM) {\n            wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();\n          } else {\n            wkt.datumCode = wkt.GEOGCS.name.toLowerCase();\n          }\n\n          if (wkt.datumCode.slice(0, 2) === 'd_') {\n            wkt.datumCode = wkt.datumCode.slice(2);\n          }\n\n          if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n            wkt.datumCode = 'nzgd49';\n          }\n\n          if (wkt.datumCode === \"wgs_1984\") {\n            if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n              wkt.sphere = true;\n            }\n\n            wkt.datumCode = 'wgs84';\n          }\n\n          if (wkt.datumCode.slice(-6) === '_ferro') {\n            wkt.datumCode = wkt.datumCode.slice(0, -6);\n          }\n\n          if (wkt.datumCode.slice(-8) === '_jakarta') {\n            wkt.datumCode = wkt.datumCode.slice(0, -8);\n          }\n\n          if (~wkt.datumCode.indexOf('belge')) {\n            wkt.datumCode = \"rnb72\";\n          }\n\n          if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {\n            wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n\n            if (wkt.ellps.toLowerCase().slice(0, 13) === \"international\") {\n              wkt.ellps = 'intl';\n            }\n\n            wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;\n            wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);\n          }\n\n          if (~wkt.datumCode.indexOf('osgb_1936')) {\n            wkt.datumCode = \"osgb36\";\n          }\n        }\n\n        if (wkt.b && !isFinite(wkt.b)) {\n          wkt.b = wkt.a;\n        }\n\n        function toMeter(input) {\n          var ratio = wkt.to_meter || 1;\n          return parseFloat(input, 10) * ratio;\n        }\n\n        var renamer = function renamer(a) {\n          return rename(wkt, a);\n        };\n\n        var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_2', 'Standard_Parallel_2'], ['false_easting', 'False_Easting'], ['false_northing', 'False_Northing'], ['central_meridian', 'Central_Meridian'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];\n        list.forEach(renamer);\n\n        if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n          wkt.long0 = wkt.longc;\n        }\n\n        if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n          wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n          wkt.lat_ts = wkt.lat1;\n        }\n      }\n\n      module.exports = function (wkt, self) {\n        var lisp = JSON.parse((\",\" + wkt).replace(/\\s*\\,\\s*([A-Z_0-9]+?)(\\[)/g, ',[\"$1\",').slice(1).replace(/\\s*\\,\\s*([A-Z_0-9]+?)\\]/g, ',\"$1\"]').replace(/,\\[\"VERTCS\".+/, ''));\n        var type = lisp.shift();\n        var name = lisp.shift();\n        lisp.unshift(['name', name]);\n        lisp.unshift(['type', type]);\n        lisp.unshift('output');\n        var obj = {};\n        sExpr(lisp, obj);\n        cleanWKT(obj.output);\n        return extend(self, obj.output);\n      };\n    }, {\n      \"./extend\": 34\n    }],\n    67: [function (_dereq_, module, exports) {\n      /**\n       * UTM zones are grouped, and assigned to one of a group of 6\n       * sets.\n       *\n       * {int} @private\n       */\n      var NUM_100K_SETS = 6;\n      /**\n       * The column letters (for easting) of the lower left value, per\n       * set.\n       *\n       * {string} @private\n       */\n\n      var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n      /**\n       * The row letters (for northing) of the lower left value, per\n       * set.\n       *\n       * {string} @private\n       */\n\n      var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n      var A = 65; // A\n\n      var I = 73; // I\n\n      var O = 79; // O\n\n      var V = 86; // V\n\n      var Z = 90; // Z\n\n      /**\n       * Conversion of lat/lon to MGRS.\n       *\n       * @param {object} ll Object literal with lat and lon properties on a\n       *     WGS84 ellipsoid.\n       * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n       *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n       * @return {string} the MGRS string for the given location and accuracy.\n       */\n\n      exports.forward = function (ll, accuracy) {\n        accuracy = accuracy || 5; // default accuracy 1m\n\n        return encode(LLtoUTM({\n          lat: ll[1],\n          lon: ll[0]\n        }), accuracy);\n      };\n      /**\n       * Conversion of MGRS to lat/lon.\n       *\n       * @param {string} mgrs MGRS string.\n       * @return {array} An array with left (longitude), bottom (latitude), right\n       *     (longitude) and top (latitude) values in WGS84, representing the\n       *     bounding box for the provided MGRS reference.\n       */\n\n\n      exports.inverse = function (mgrs) {\n        var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n\n        if (bbox.lat && bbox.lon) {\n          return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n        }\n\n        return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n      };\n\n      exports.toPoint = function (mgrs) {\n        var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n\n        if (bbox.lat && bbox.lon) {\n          return [bbox.lon, bbox.lat];\n        }\n\n        return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n      };\n      /**\n       * Conversion from degrees to radians.\n       *\n       * @private\n       * @param {number} deg the angle in degrees.\n       * @return {number} the angle in radians.\n       */\n\n\n      function degToRad(deg) {\n        return deg * (Math.PI / 180.0);\n      }\n      /**\n       * Conversion from radians to degrees.\n       *\n       * @private\n       * @param {number} rad the angle in radians.\n       * @return {number} the angle in degrees.\n       */\n\n\n      function radToDeg(rad) {\n        return 180.0 * (rad / Math.PI);\n      }\n      /**\n       * Converts a set of Longitude and Latitude co-ordinates to UTM\n       * using the WGS84 ellipsoid.\n       *\n       * @private\n       * @param {object} ll Object literal with lat and lon properties\n       *     representing the WGS84 coordinate to be converted.\n       * @return {object} Object literal containing the UTM value with easting,\n       *     northing, zoneNumber and zoneLetter properties, and an optional\n       *     accuracy property in digits. Returns null if the conversion failed.\n       */\n\n\n      function LLtoUTM(ll) {\n        var Lat = ll.lat;\n        var Long = ll.lon;\n        var a = 6378137.0; //ellip.radius;\n\n        var eccSquared = 0.00669438; //ellip.eccsq;\n\n        var k0 = 0.9996;\n        var LongOrigin;\n        var eccPrimeSquared;\n        var N, T, C, A, M;\n        var LatRad = degToRad(Lat);\n        var LongRad = degToRad(Long);\n        var LongOriginRad;\n        var ZoneNumber; // (int)\n\n        ZoneNumber = Math.floor((Long + 180) / 6) + 1; //Make sure the longitude 180.00 is in Zone 60\n\n        if (Long === 180) {\n          ZoneNumber = 60;\n        } // Special zone for Norway\n\n\n        if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n          ZoneNumber = 32;\n        } // Special zones for Svalbard\n\n\n        if (Lat >= 72.0 && Lat < 84.0) {\n          if (Long >= 0.0 && Long < 9.0) {\n            ZoneNumber = 31;\n          } else if (Long >= 9.0 && Long < 21.0) {\n            ZoneNumber = 33;\n          } else if (Long >= 21.0 && Long < 33.0) {\n            ZoneNumber = 35;\n          } else if (Long >= 33.0 && Long < 42.0) {\n            ZoneNumber = 37;\n          }\n        }\n\n        LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n        // in middle of\n        // zone\n\n        LongOriginRad = degToRad(LongOrigin);\n        eccPrimeSquared = eccSquared / (1 - eccSquared);\n        N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n        T = Math.tan(LatRad) * Math.tan(LatRad);\n        C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n        A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n        M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));\n        var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;\n        var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));\n\n        if (Lat < 0.0) {\n          UTMNorthing += 10000000.0; //10000000 meter offset for\n          // southern hemisphere\n        }\n\n        return {\n          northing: Math.round(UTMNorthing),\n          easting: Math.round(UTMEasting),\n          zoneNumber: ZoneNumber,\n          zoneLetter: getLetterDesignator(Lat)\n        };\n      }\n      /**\n       * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n       * class where the Zone can be specified as a single string eg.\"60N\" which\n       * is then broken down into the ZoneNumber and ZoneLetter.\n       *\n       * @private\n       * @param {object} utm An object literal with northing, easting, zoneNumber\n       *     and zoneLetter properties. If an optional accuracy property is\n       *     provided (in meters), a bounding box will be returned instead of\n       *     latitude and longitude.\n       * @return {object} An object literal containing either lat and lon values\n       *     (if no accuracy was provided), or top, right, bottom and left values\n       *     for the bounding box calculated according to the provided accuracy.\n       *     Returns null if the conversion failed.\n       */\n\n\n      function UTMtoLL(utm) {\n        var UTMNorthing = utm.northing;\n        var UTMEasting = utm.easting;\n        var zoneLetter = utm.zoneLetter;\n        var zoneNumber = utm.zoneNumber; // check the ZoneNummber is valid\n\n        if (zoneNumber < 0 || zoneNumber > 60) {\n          return null;\n        }\n\n        var k0 = 0.9996;\n        var a = 6378137.0; //ellip.radius;\n\n        var eccSquared = 0.00669438; //ellip.eccsq;\n\n        var eccPrimeSquared;\n        var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n        var N1, T1, C1, R1, D, M;\n        var LongOrigin;\n        var mu, phi1Rad; // remove 500,000 meter offset for longitude\n\n        var x = UTMEasting - 500000.0;\n        var y = UTMNorthing; // We must know somehow if we are in the Northern or Southern\n        // hemisphere, this is the only time we use the letter So even\n        // if the Zone letter isn't exactly correct it should indicate\n        // the hemisphere correctly\n\n        if (zoneLetter < 'N') {\n          y -= 10000000.0; // remove 10,000,000 meter offset used\n          // for southern hemisphere\n        } // There are 60 zones with zone 1 being at West -180 to -174\n\n\n        LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n        // in middle of\n        // zone\n\n        eccPrimeSquared = eccSquared / (1 - eccSquared);\n        M = y / k0;\n        mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n        phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu); // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n        N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n        T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n        C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n        R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n        D = x / (N1 * k0);\n        var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n        lat = radToDeg(lat);\n        var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n        lon = LongOrigin + radToDeg(lon);\n        var result;\n\n        if (utm.accuracy) {\n          var topRight = UTMtoLL({\n            northing: utm.northing + utm.accuracy,\n            easting: utm.easting + utm.accuracy,\n            zoneLetter: utm.zoneLetter,\n            zoneNumber: utm.zoneNumber\n          });\n          result = {\n            top: topRight.lat,\n            right: topRight.lon,\n            bottom: lat,\n            left: lon\n          };\n        } else {\n          result = {\n            lat: lat,\n            lon: lon\n          };\n        }\n\n        return result;\n      }\n      /**\n       * Calculates the MGRS letter designator for the given latitude.\n       *\n       * @private\n       * @param {number} lat The latitude in WGS84 to get the letter designator\n       *     for.\n       * @return {char} The letter designator.\n       */\n\n\n      function getLetterDesignator(lat) {\n        //This is here as an error flag to show that the Latitude is\n        //outside MGRS limits\n        var LetterDesignator = 'Z';\n\n        if (84 >= lat && lat >= 72) {\n          LetterDesignator = 'X';\n        } else if (72 > lat && lat >= 64) {\n          LetterDesignator = 'W';\n        } else if (64 > lat && lat >= 56) {\n          LetterDesignator = 'V';\n        } else if (56 > lat && lat >= 48) {\n          LetterDesignator = 'U';\n        } else if (48 > lat && lat >= 40) {\n          LetterDesignator = 'T';\n        } else if (40 > lat && lat >= 32) {\n          LetterDesignator = 'S';\n        } else if (32 > lat && lat >= 24) {\n          LetterDesignator = 'R';\n        } else if (24 > lat && lat >= 16) {\n          LetterDesignator = 'Q';\n        } else if (16 > lat && lat >= 8) {\n          LetterDesignator = 'P';\n        } else if (8 > lat && lat >= 0) {\n          LetterDesignator = 'N';\n        } else if (0 > lat && lat >= -8) {\n          LetterDesignator = 'M';\n        } else if (-8 > lat && lat >= -16) {\n          LetterDesignator = 'L';\n        } else if (-16 > lat && lat >= -24) {\n          LetterDesignator = 'K';\n        } else if (-24 > lat && lat >= -32) {\n          LetterDesignator = 'J';\n        } else if (-32 > lat && lat >= -40) {\n          LetterDesignator = 'H';\n        } else if (-40 > lat && lat >= -48) {\n          LetterDesignator = 'G';\n        } else if (-48 > lat && lat >= -56) {\n          LetterDesignator = 'F';\n        } else if (-56 > lat && lat >= -64) {\n          LetterDesignator = 'E';\n        } else if (-64 > lat && lat >= -72) {\n          LetterDesignator = 'D';\n        } else if (-72 > lat && lat >= -80) {\n          LetterDesignator = 'C';\n        }\n\n        return LetterDesignator;\n      }\n      /**\n       * Encodes a UTM location as MGRS string.\n       *\n       * @private\n       * @param {object} utm An object literal with easting, northing,\n       *     zoneLetter, zoneNumber\n       * @param {number} accuracy Accuracy in digits (1-5).\n       * @return {string} MGRS string for the given UTM location.\n       */\n\n\n      function encode(utm, accuracy) {\n        // prepend with leading zeroes\n        var seasting = \"00000\" + utm.easting,\n            snorthing = \"00000\" + utm.northing;\n        return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n      }\n      /**\n       * Get the two letter 100k designator for a given UTM easting,\n       * northing and zone number value.\n       *\n       * @private\n       * @param {number} easting\n       * @param {number} northing\n       * @param {number} zoneNumber\n       * @return the two letter 100k designator for the given UTM location.\n       */\n\n\n      function get100kID(easting, northing, zoneNumber) {\n        var setParm = get100kSetForZone(zoneNumber);\n        var setColumn = Math.floor(easting / 100000);\n        var setRow = Math.floor(northing / 100000) % 20;\n        return getLetter100kID(setColumn, setRow, setParm);\n      }\n      /**\n       * Given a UTM zone number, figure out the MGRS 100K set it is in.\n       *\n       * @private\n       * @param {number} i An UTM zone number.\n       * @return {number} the 100k set the UTM zone is in.\n       */\n\n\n      function get100kSetForZone(i) {\n        var setParm = i % NUM_100K_SETS;\n\n        if (setParm === 0) {\n          setParm = NUM_100K_SETS;\n        }\n\n        return setParm;\n      }\n      /**\n       * Get the two-letter MGRS 100k designator given information\n       * translated from the UTM northing, easting and zone number.\n       *\n       * @private\n       * @param {number} column the column index as it relates to the MGRS\n       *        100k set spreadsheet, created from the UTM easting.\n       *        Values are 1-8.\n       * @param {number} row the row index as it relates to the MGRS 100k set\n       *        spreadsheet, created from the UTM northing value. Values\n       *        are from 0-19.\n       * @param {number} parm the set block, as it relates to the MGRS 100k set\n       *        spreadsheet, created from the UTM zone. Values are from\n       *        1-60.\n       * @return two letter MGRS 100k code.\n       */\n\n\n      function getLetter100kID(column, row, parm) {\n        // colOrigin and rowOrigin are the letters at the origin of the set\n        var index = parm - 1;\n        var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n        var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index); // colInt and rowInt are the letters to build to return\n\n        var colInt = colOrigin + column - 1;\n        var rowInt = rowOrigin + row;\n        var rollover = false;\n\n        if (colInt > Z) {\n          colInt = colInt - Z + A - 1;\n          rollover = true;\n        }\n\n        if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {\n          colInt++;\n        }\n\n        if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {\n          colInt++;\n\n          if (colInt === I) {\n            colInt++;\n          }\n        }\n\n        if (colInt > Z) {\n          colInt = colInt - Z + A - 1;\n        }\n\n        if (rowInt > V) {\n          rowInt = rowInt - V + A - 1;\n          rollover = true;\n        } else {\n          rollover = false;\n        }\n\n        if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {\n          rowInt++;\n        }\n\n        if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {\n          rowInt++;\n\n          if (rowInt === I) {\n            rowInt++;\n          }\n        }\n\n        if (rowInt > V) {\n          rowInt = rowInt - V + A - 1;\n        }\n\n        var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n        return twoLetter;\n      }\n      /**\n       * Decode the UTM parameters from a MGRS string.\n       *\n       * @private\n       * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n       * @return {object} An object literal with easting, northing, zoneLetter,\n       *     zoneNumber and accuracy (in meters) properties.\n       */\n\n\n      function decode(mgrsString) {\n        if (mgrsString && mgrsString.length === 0) {\n          throw \"MGRSPoint coverting from nothing\";\n        }\n\n        var length = mgrsString.length;\n        var hunK = null;\n        var sb = \"\";\n        var testChar;\n        var i = 0; // get Zone number\n\n        while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {\n          if (i >= 2) {\n            throw \"MGRSPoint bad conversion from: \" + mgrsString;\n          }\n\n          sb += testChar;\n          i++;\n        }\n\n        var zoneNumber = parseInt(sb, 10);\n\n        if (i === 0 || i + 3 > length) {\n          // A good MGRS string has to be 4-5 digits long,\n          // ##AAA/#AAA at least.\n          throw \"MGRSPoint bad conversion from: \" + mgrsString;\n        }\n\n        var zoneLetter = mgrsString.charAt(i++); // Should we check the zone letter here? Why not.\n\n        if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n          throw \"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString;\n        }\n\n        hunK = mgrsString.substring(i, i += 2);\n        var set = get100kSetForZone(zoneNumber);\n        var east100k = getEastingFromChar(hunK.charAt(0), set);\n        var north100k = getNorthingFromChar(hunK.charAt(1), set); // We have a bug where the northing may be 2000000 too low.\n        // How\n        // do we know when to roll over?\n\n        while (north100k < getMinNorthing(zoneLetter)) {\n          north100k += 2000000;\n        } // calculate the char index for easting/northing separator\n\n\n        var remainder = length - i;\n\n        if (remainder % 2 !== 0) {\n          throw \"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString;\n        }\n\n        var sep = remainder / 2;\n        var sepEasting = 0.0;\n        var sepNorthing = 0.0;\n        var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n\n        if (sep > 0) {\n          accuracyBonus = 100000.0 / Math.pow(10, sep);\n          sepEastingString = mgrsString.substring(i, i + sep);\n          sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n          sepNorthingString = mgrsString.substring(i + sep);\n          sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n        }\n\n        easting = sepEasting + east100k;\n        northing = sepNorthing + north100k;\n        return {\n          easting: easting,\n          northing: northing,\n          zoneLetter: zoneLetter,\n          zoneNumber: zoneNumber,\n          accuracy: accuracyBonus\n        };\n      }\n      /**\n       * Given the first letter from a two-letter MGRS 100k zone, and given the\n       * MGRS table set for the zone number, figure out the easting value that\n       * should be added to the other, secondary easting value.\n       *\n       * @private\n       * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n       * @param {number} set The MGRS table set for the zone number.\n       * @return {number} The easting value for the given letter and set.\n       */\n\n\n      function getEastingFromChar(e, set) {\n        // colOrigin is the letter at the origin of the set for the\n        // column\n        var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n        var eastingValue = 100000.0;\n        var rewindMarker = false;\n\n        while (curCol !== e.charCodeAt(0)) {\n          curCol++;\n\n          if (curCol === I) {\n            curCol++;\n          }\n\n          if (curCol === O) {\n            curCol++;\n          }\n\n          if (curCol > Z) {\n            if (rewindMarker) {\n              throw \"Bad character: \" + e;\n            }\n\n            curCol = A;\n            rewindMarker = true;\n          }\n\n          eastingValue += 100000.0;\n        }\n\n        return eastingValue;\n      }\n      /**\n       * Given the second letter from a two-letter MGRS 100k zone, and given the\n       * MGRS table set for the zone number, figure out the northing value that\n       * should be added to the other, secondary northing value. You have to\n       * remember that Northings are determined from the equator, and the vertical\n       * cycle of letters mean a 2000000 additional northing meters. This happens\n       * approx. every 18 degrees of latitude. This method does *NOT* count any\n       * additional northings. You have to figure out how many 2000000 meters need\n       * to be added for the zone letter of the MGRS coordinate.\n       *\n       * @private\n       * @param {char} n Second letter of the MGRS 100k zone\n       * @param {number} set The MGRS table set number, which is dependent on the\n       *     UTM zone number.\n       * @return {number} The northing value for the given letter and set.\n       */\n\n\n      function getNorthingFromChar(n, set) {\n        if (n > 'V') {\n          throw \"MGRSPoint given invalid Northing \" + n;\n        } // rowOrigin is the letter at the origin of the set for the\n        // column\n\n\n        var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n        var northingValue = 0.0;\n        var rewindMarker = false;\n\n        while (curRow !== n.charCodeAt(0)) {\n          curRow++;\n\n          if (curRow === I) {\n            curRow++;\n          }\n\n          if (curRow === O) {\n            curRow++;\n          } // fixing a bug making whole application hang in this loop\n          // when 'n' is a wrong character\n\n\n          if (curRow > V) {\n            if (rewindMarker) {\n              // making sure that this loop ends\n              throw \"Bad character: \" + n;\n            }\n\n            curRow = A;\n            rewindMarker = true;\n          }\n\n          northingValue += 100000.0;\n        }\n\n        return northingValue;\n      }\n      /**\n       * The function getMinNorthing returns the minimum northing value of a MGRS\n       * zone.\n       *\n       * Ported from Geotrans' c Lattitude_Band_Value structure table.\n       *\n       * @private\n       * @param {char} zoneLetter The MGRS zone to get the min northing for.\n       * @return {number}\n       */\n\n\n      function getMinNorthing(zoneLetter) {\n        var northing;\n\n        switch (zoneLetter) {\n          case 'C':\n            northing = 1100000.0;\n            break;\n\n          case 'D':\n            northing = 2000000.0;\n            break;\n\n          case 'E':\n            northing = 2800000.0;\n            break;\n\n          case 'F':\n            northing = 3700000.0;\n            break;\n\n          case 'G':\n            northing = 4600000.0;\n            break;\n\n          case 'H':\n            northing = 5500000.0;\n            break;\n\n          case 'J':\n            northing = 6400000.0;\n            break;\n\n          case 'K':\n            northing = 7300000.0;\n            break;\n\n          case 'L':\n            northing = 8200000.0;\n            break;\n\n          case 'M':\n            northing = 9100000.0;\n            break;\n\n          case 'N':\n            northing = 0.0;\n            break;\n\n          case 'P':\n            northing = 800000.0;\n            break;\n\n          case 'Q':\n            northing = 1700000.0;\n            break;\n\n          case 'R':\n            northing = 2600000.0;\n            break;\n\n          case 'S':\n            northing = 3500000.0;\n            break;\n\n          case 'T':\n            northing = 4400000.0;\n            break;\n\n          case 'U':\n            northing = 5300000.0;\n            break;\n\n          case 'V':\n            northing = 6200000.0;\n            break;\n\n          case 'W':\n            northing = 7000000.0;\n            break;\n\n          case 'X':\n            northing = 7900000.0;\n            break;\n\n          default:\n            northing = -1.0;\n        }\n\n        if (northing >= 0.0) {\n          return northing;\n        } else {\n          throw \"Invalid zone letter: \" + zoneLetter;\n        }\n      }\n    }, {}],\n    68: [function (_dereq_, module, exports) {\n      module.exports = {\n        \"name\": \"proj4\",\n        \"version\": \"2.3.14\",\n        \"description\": \"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\",\n        \"main\": \"lib/index.js\",\n        \"directories\": {\n          \"test\": \"test\",\n          \"doc\": \"docs\"\n        },\n        \"scripts\": {\n          \"test\": \"./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js\"\n        },\n        \"repository\": {\n          \"type\": \"git\",\n          \"url\": \"git://github.com/proj4js/proj4js.git\"\n        },\n        \"author\": \"\",\n        \"license\": \"MIT\",\n        \"jam\": {\n          \"main\": \"dist/proj4.js\",\n          \"include\": [\"dist/proj4.js\", \"README.md\", \"AUTHORS\", \"LICENSE.md\"]\n        },\n        \"devDependencies\": {\n          \"grunt-cli\": \"~0.1.13\",\n          \"grunt\": \"~0.4.2\",\n          \"grunt-contrib-connect\": \"~0.6.0\",\n          \"grunt-contrib-jshint\": \"~0.8.0\",\n          \"chai\": \"~1.8.1\",\n          \"mocha\": \"~1.17.1\",\n          \"grunt-mocha-phantomjs\": \"~0.4.0\",\n          \"browserify\": \"~12.0.1\",\n          \"grunt-browserify\": \"~4.0.1\",\n          \"grunt-contrib-uglify\": \"~0.11.1\",\n          \"curl\": \"git://github.com/cujojs/curl.git\",\n          \"istanbul\": \"~0.2.4\",\n          \"tin\": \"~0.4.0\"\n        },\n        \"dependencies\": {\n          \"mgrs\": \"~0.0.2\"\n        }\n      };\n    }, {}],\n    \"./includedProjections\": [function (_dereq_, module, exports) {\n      module.exports = _dereq_('hTEDpn');\n    }, {}],\n    \"hTEDpn\": [function (_dereq_, module, exports) {\n      var projs = [_dereq_('./lib/projections/tmerc'), _dereq_('./lib/projections/utm'), _dereq_('./lib/projections/sterea'), _dereq_('./lib/projections/stere'), _dereq_('./lib/projections/somerc'), _dereq_('./lib/projections/omerc'), _dereq_('./lib/projections/lcc'), _dereq_('./lib/projections/krovak'), _dereq_('./lib/projections/cass'), _dereq_('./lib/projections/laea'), _dereq_('./lib/projections/aea'), _dereq_('./lib/projections/gnom'), _dereq_('./lib/projections/cea'), _dereq_('./lib/projections/eqc'), _dereq_('./lib/projections/poly'), _dereq_('./lib/projections/nzmg'), _dereq_('./lib/projections/mill'), _dereq_('./lib/projections/sinu'), _dereq_('./lib/projections/moll'), _dereq_('./lib/projections/eqdc'), _dereq_('./lib/projections/vandg'), _dereq_('./lib/projections/aeqd')];\n\n      module.exports = function (proj4) {\n        projs.forEach(function (proj) {\n          proj4.Proj.projections.add(proj);\n        });\n      };\n    }, {\n      \"./lib/projections/aea\": 40,\n      \"./lib/projections/aeqd\": 41,\n      \"./lib/projections/cass\": 42,\n      \"./lib/projections/cea\": 43,\n      \"./lib/projections/eqc\": 44,\n      \"./lib/projections/eqdc\": 45,\n      \"./lib/projections/gnom\": 47,\n      \"./lib/projections/krovak\": 48,\n      \"./lib/projections/laea\": 49,\n      \"./lib/projections/lcc\": 50,\n      \"./lib/projections/mill\": 53,\n      \"./lib/projections/moll\": 54,\n      \"./lib/projections/nzmg\": 55,\n      \"./lib/projections/omerc\": 56,\n      \"./lib/projections/poly\": 57,\n      \"./lib/projections/sinu\": 58,\n      \"./lib/projections/somerc\": 59,\n      \"./lib/projections/stere\": 60,\n      \"./lib/projections/sterea\": 61,\n      \"./lib/projections/tmerc\": 62,\n      \"./lib/projections/utm\": 63,\n      \"./lib/projections/vandg\": 64\n    }]\n  }, {}, [36])(36);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9NYXAvTGVhZmxldC9wcm9qNC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01hcC9MZWFmbGV0L3Byb2o0LmpzPzY3ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucHJvajQ9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbWdycyA9IF9kZXJlcV8oJ21ncnMnKTtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgeikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCB6KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHRoaXMueCA9IHhbMF07XG4gICAgdGhpcy55ID0geFsxXTtcbiAgICB0aGlzLnogPSB4WzJdIHx8IDAuMDtcbiAgfSBlbHNlIGlmKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMueCA9IHgueDtcbiAgICB0aGlzLnkgPSB4Lnk7XG4gICAgdGhpcy56ID0geC56IHx8IDAuMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvb3JkcyA9IHguc3BsaXQoJywnKTtcbiAgICB0aGlzLnggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSwgMTApO1xuICAgIHRoaXMueSA9IHBhcnNlRmxvYXQoY29vcmRzWzFdLCAxMCk7XG4gICAgdGhpcy56ID0gcGFyc2VGbG9hdChjb29yZHNbMl0sIDEwKSB8fCAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHogfHwgMC4wO1xuICB9XG4gIGNvbnNvbGUud2FybigncHJvajQuUG9pbnQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMywgdXNlIHByb2o0LnRvUG9pbnQnKTtcbn1cblxuUG9pbnQuZnJvbU1HUlMgPSBmdW5jdGlvbihtZ3JzU3RyKSB7XG4gIHJldHVybiBuZXcgUG9pbnQobWdycy50b1BvaW50KG1ncnNTdHIpKTtcbn07XG5Qb2ludC5wcm90b3R5cGUudG9NR1JTID0gZnVuY3Rpb24oYWNjdXJhY3kpIHtcbiAgcmV0dXJuIG1ncnMuZm9yd2FyZChbdGhpcy54LCB0aGlzLnldLCBhY2N1cmFjeSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxufSx7XCJtZ3JzXCI6Njd9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBwYXJzZUNvZGUgPSBfZGVyZXFfKFwiLi9wYXJzZUNvZGVcIik7XG52YXIgZXh0ZW5kID0gX2RlcmVxXygnLi9leHRlbmQnKTtcbnZhciBwcm9qZWN0aW9ucyA9IF9kZXJlcV8oJy4vcHJvamVjdGlvbnMnKTtcbnZhciBkZXJpdmVDb25zdGFudHMgPSBfZGVyZXFfKCcuL2Rlcml2ZUNvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBQcm9qZWN0aW9uKHNyc0NvZGUsY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uKHNyc0NvZGUpO1xuICB9XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyb3Ipe1xuICAgIGlmKGVycm9yKXtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIGpzb24gPSBwYXJzZUNvZGUoc3JzQ29kZSk7XG4gIGlmKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0Jyl7XG4gICAgY2FsbGJhY2soc3JzQ29kZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtb2RpZmllZEpTT04gPSBkZXJpdmVDb25zdGFudHMoanNvbik7XG4gIHZhciBvdXJQcm9qID0gUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5nZXQobW9kaWZpZWRKU09OLnByb2pOYW1lKTtcbiAgaWYob3VyUHJvail7XG4gICAgZXh0ZW5kKHRoaXMsIG1vZGlmaWVkSlNPTik7XG4gICAgZXh0ZW5kKHRoaXMsIG91clByb2opO1xuICAgIHRoaXMuaW5pdCgpO1xuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICB9ZWxzZXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgfVxufVxuUHJvamVjdGlvbi5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5zdGFydCgpO1xubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0aW9uO1xuXG59LHtcIi4vZGVyaXZlQ29uc3RhbnRzXCI6MzMsXCIuL2V4dGVuZFwiOjM0LFwiLi9wYXJzZUNvZGVcIjozNyxcIi4vcHJvamVjdGlvbnNcIjozOX1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjcnMsIGRlbm9ybSwgcG9pbnQpIHtcbiAgdmFyIHhpbiA9IHBvaW50LngsXG4gICAgeWluID0gcG9pbnQueSxcbiAgICB6aW4gPSBwb2ludC56IHx8IDAuMDtcbiAgdmFyIHYsIHQsIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAoZGVub3JtICYmIGkgPT09IDIgJiYgcG9pbnQueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHYgPSB4aW47XG4gICAgICB0ID0gJ3gnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpID09PSAxKSB7XG4gICAgICB2ID0geWluO1xuICAgICAgdCA9ICd5JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2ID0gemluO1xuICAgICAgdCA9ICd6JztcbiAgICB9XG4gICAgc3dpdGNoIChjcnMuYXhpc1tpXSkge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgcG9pbnRbdF0gPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndyc6XG4gICAgICBwb2ludFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBwb2ludFt0XSA9IHY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIHBvaW50W3RdID0gLXY7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1JzpcbiAgICAgIGlmIChwb2ludFt0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50LnogPSB2O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZCc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludC56ID0gLXY7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy9jb25zb2xlLmxvZyhcIkVSUk9SOiB1bmtub3cgYXhpcyAoXCIrY3JzLmF4aXNbaV0rXCIpIC0gY2hlY2sgZGVmaW5pdGlvbiBvZiBcIitjcnMucHJvak5hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludDtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgc2lnbiA9IF9kZXJlcV8oJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8IEhBTEZfUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBNYXRoLlBJKSk7XG59O1xufSx7XCIuL3NpZ25cIjoyMX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFRXT19QSSA9IE1hdGguUEkgKiAyO1xuLy8gU1BJIGlzIHNsaWdodGx5IGdyZWF0ZXIgdGhhbiBNYXRoLlBJLCBzbyB2YWx1ZXMgdGhhdCBleGNlZWQgdGhlIC0xODAuLjE4MFxuLy8gZGVncmVlIHJhbmdlIGJ5IGEgdGlueSBhbW91bnQgZG9uJ3QgZ2V0IHdyYXBwZWQuIFRoaXMgcHJldmVudHMgcG9pbnRzIHRoYXRcbi8vIGhhdmUgZHJpZnRlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFsb25nIHRoZSAxODB0aCBtZXJpZGlhbiAoZHVlIHRvXG4vLyBmbG9hdGluZyBwb2ludCBlcnJvcikgZnJvbSBjaGFuZ2luZyB0aGVpciBzaWduLlxudmFyIFNQSSA9IDMuMTQxNTkyNjUzNTk7XG52YXIgc2lnbiA9IF9kZXJlcV8oJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8PSBTUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBUV09fUEkpKTtcbn07XG59LHtcIi4vc2lnblwiOjIxfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgaWYgKE1hdGguYWJzKHgpID4gMSkge1xuICAgIHggPSAoeCA+IDEpID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBNYXRoLmFzaW4oeCk7XG59O1xufSx7fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICgxIC0gMC4yNSAqIHggKiAoMSArIHggLyAxNiAqICgzICsgMS4yNSAqIHgpKSk7XG59O1xufSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICgwLjM3NSAqIHggKiAoMSArIDAuMjUgKiB4ICogKDEgKyAwLjQ2ODc1ICogeCkpKTtcbn07XG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDAuMDU4NTkzNzUgKiB4ICogeCAqICgxICsgMC43NSAqIHgpKTtcbn07XG59LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICh4ICogeCAqIHggKiAoMzUgLyAzMDcyKSk7XG59O1xufSx7fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBlLCBzaW5waGkpIHtcbiAgdmFyIHRlbXAgPSBlICogc2lucGhpO1xuICByZXR1cm4gYSAvIE1hdGguc3FydCgxIC0gdGVtcCAqIHRlbXApO1xufTtcbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWwsIGUwLCBlMSwgZTIsIGUzKSB7XG4gIHZhciBwaGk7XG4gIHZhciBkcGhpO1xuXG4gIHBoaSA9IG1sIC8gZTA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgIGRwaGkgPSAobWwgLSAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpKSAvIChlMCAtIDIgKiBlMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIGUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogZTMgKiBNYXRoLmNvcyg2ICogcGhpKSk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cblxuICAvLy4ucmVwb3J0RXJyb3IoXCJJTUxGTi1DT05WOkxhdGl0dWRlIGZhaWxlZCB0byBjb252ZXJnZSBhZnRlciAxNSBpdGVyYXRpb25zXCIpO1xuICByZXR1cm4gTmFOO1xufTtcbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgcSkge1xuICB2YXIgdGVtcCA9IDEgLSAoMSAtIGVjY2VudCAqIGVjY2VudCkgLyAoMiAqIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGVjY2VudCkgLyAoMSArIGVjY2VudCkpO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocSkgLSB0ZW1wKSA8IDEuMEUtNikge1xuICAgIGlmIChxIDwgMCkge1xuICAgICAgcmV0dXJuICgtMSAqIEhBTEZfUEkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBIQUxGX1BJO1xuICAgIH1cbiAgfVxuICAvL3ZhciBwaGkgPSAwLjUqIHEvKDEtZWNjZW50KmVjY2VudCk7XG4gIHZhciBwaGkgPSBNYXRoLmFzaW4oMC41ICogcSk7XG4gIHZhciBkcGhpO1xuICB2YXIgc2luX3BoaTtcbiAgdmFyIGNvc19waGk7XG4gIHZhciBjb247XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICAgIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbl9waGk7XG4gICAgZHBoaSA9IE1hdGgucG93KDEgLSBjb24gKiBjb24sIDIpIC8gKDIgKiBjb3NfcGhpKSAqIChxIC8gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC0gc2luX3BoaSAvICgxIC0gY29uICogY29uKSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcIklRU0ZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDMwIGl0ZXJhdGlvbnNcIik7XG4gIHJldHVybiBOYU47XG59O1xufSx7fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlMCwgZTEsIGUyLCBlMywgcGhpKSB7XG4gIHJldHVybiAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpO1xufTtcbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWNjZW50LCBzaW5waGksIGNvc3BoaSkge1xuICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuICByZXR1cm4gY29zcGhpIC8gKE1hdGguc3FydCgxIC0gY29uICogY29uKSk7XG59O1xufSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgdHMpIHtcbiAgdmFyIGVjY250aCA9IDAuNSAqIGVjY2VudDtcbiAgdmFyIGNvbiwgZHBoaTtcbiAgdmFyIHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTU7IGkrKykge1xuICAgIGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHBoaSk7XG4gICAgZHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzICogKE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBlY2NudGgpKSkgLSBwaGk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgLy9jb25zb2xlLmxvZyhcInBoaTJ6IGhhcyBOb0NvbnZlcmdlbmNlXCIpO1xuICByZXR1cm4gLTk5OTk7XG59O1xufSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEMwMCA9IDE7XG52YXIgQzAyID0gMC4yNTtcbnZhciBDMDQgPSAwLjA0Njg3NTtcbnZhciBDMDYgPSAwLjAxOTUzMTI1O1xudmFyIEMwOCA9IDAuMDEwNjgxMTUyMzQzNzU7XG52YXIgQzIyID0gMC43NTtcbnZhciBDNDQgPSAwLjQ2ODc1O1xudmFyIEM0NiA9IDAuMDEzMDIwODMzMzMzMzMzMzMzMzM7XG52YXIgQzQ4ID0gMC4wMDcxMjA3NjgyMjkxNjY2NjY2NjtcbnZhciBDNjYgPSAwLjM2NDU4MzMzMzMzMzMzMzMzMzMzO1xudmFyIEM2OCA9IDAuMDA1Njk2NjE0NTgzMzMzMzMzMzM7XG52YXIgQzg4ID0gMC4zMDc2MTcxODc1O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVzKSB7XG4gIHZhciBlbiA9IFtdO1xuICBlblswXSA9IEMwMCAtIGVzICogKEMwMiArIGVzICogKEMwNCArIGVzICogKEMwNiArIGVzICogQzA4KSkpO1xuICBlblsxXSA9IGVzICogKEMyMiAtIGVzICogKEMwNCArIGVzICogKEMwNiArIGVzICogQzA4KSkpO1xuICB2YXIgdCA9IGVzICogZXM7XG4gIGVuWzJdID0gdCAqIChDNDQgLSBlcyAqIChDNDYgKyBlcyAqIEM0OCkpO1xuICB0ICo9IGVzO1xuICBlblszXSA9IHQgKiAoQzY2IC0gZXMgKiBDNjgpO1xuICBlbls0XSA9IHQgKiBlcyAqIEM4ODtcbiAgcmV0dXJuIGVuO1xufTtcbn0se31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBwal9tbGZuID0gX2RlcmVxXyhcIi4vcGpfbWxmblwiKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgTUFYX0lURVIgPSAyMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJnLCBlcywgZW4pIHtcbiAgdmFyIGsgPSAxIC8gKDEgLSBlcyk7XG4gIHZhciBwaGkgPSBhcmc7XG4gIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7IC8qIHJhcmVseSBnb2VzIG92ZXIgMiBpdGVyYXRpb25zICovXG4gICAgdmFyIHMgPSBNYXRoLnNpbihwaGkpO1xuICAgIHZhciB0ID0gMSAtIGVzICogcyAqIHM7XG4gICAgLy90ID0gdGhpcy5wal9tbGZuKHBoaSwgcywgTWF0aC5jb3MocGhpKSwgZW4pIC0gYXJnO1xuICAgIC8vcGhpIC09IHQgKiAodCAqIE1hdGguc3FydCh0KSkgKiBrO1xuICAgIHQgPSAocGpfbWxmbihwaGksIHMsIE1hdGguY29zKHBoaSksIGVuKSAtIGFyZykgKiAodCAqIE1hdGguc3FydCh0KSkgKiBrO1xuICAgIHBoaSAtPSB0O1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICAvLy4ucmVwb3J0RXJyb3IoXCJjYXNzOnBqX2ludl9tbGZuOiBDb252ZXJnZW5jZSBlcnJvclwiKTtcbiAgcmV0dXJuIHBoaTtcbn07XG59LHtcIi4vcGpfbWxmblwiOjE5fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwaGksIHNwaGksIGNwaGksIGVuKSB7XG4gIGNwaGkgKj0gc3BoaTtcbiAgc3BoaSAqPSBzcGhpO1xuICByZXR1cm4gKGVuWzBdICogcGhpIC0gY3BoaSAqIChlblsxXSArIHNwaGkgKiAoZW5bMl0gKyBzcGhpICogKGVuWzNdICsgc3BoaSAqIGVuWzRdKSkpKTtcbn07XG59LHt9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgc2lucGhpKSB7XG4gIHZhciBjb247XG4gIGlmIChlY2NlbnQgPiAxLjBlLTcpIHtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gICAgcmV0dXJuICgoMSAtIGVjY2VudCAqIGVjY2VudCkgKiAoc2lucGhpIC8gKDEgLSBjb24gKiBjb24pIC0gKDAuNSAvIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuICgyICogc2lucGhpKTtcbiAgfVxufTtcbn0se31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDwwID8gLTEgOiAxO1xufTtcbn0se31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXNpbnAsIGV4cCkge1xuICByZXR1cm4gKE1hdGgucG93KCgxIC0gZXNpbnApIC8gKDEgKyBlc2lucCksIGV4cCkpO1xufTtcbn0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5KXtcbiAgdmFyIG91dCA9IHtcbiAgICB4OiBhcnJheVswXSxcbiAgICB5OiBhcnJheVsxXVxuICB9O1xuICBpZiAoYXJyYXkubGVuZ3RoPjIpIHtcbiAgICBvdXQueiA9IGFycmF5WzJdO1xuICB9XG4gIGlmIChhcnJheS5sZW5ndGg+Mykge1xuICAgIG91dC5tID0gYXJyYXlbM107XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG59LHt9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHBoaSwgc2lucGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHZhciBjb20gPSAwLjUgKiBlY2NlbnQ7XG4gIGNvbiA9IE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBjb20pO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJIC0gcGhpKSkgLyBjb24pO1xufTtcbn0se31dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMud2dzODQgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJXR1M4NFwiLFxuICBkYXR1bU5hbWU6IFwiV0dTODRcIlxufTtcbmV4cG9ydHMuY2gxOTAzID0ge1xuICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcInN3aXNzXCJcbn07XG5leHBvcnRzLmdncnM4NyA9IHtcbiAgdG93Z3M4NDogXCItMTk5Ljg3LDc0Ljc5LDI0Ni42MlwiLFxuICBlbGxpcHNlOiBcIkdSUzgwXCIsXG4gIGRhdHVtTmFtZTogXCJHcmVla19HZW9kZXRpY19SZWZlcmVuY2VfU3lzdGVtXzE5ODdcIlxufTtcbmV4cG9ydHMubmFkODMgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTk4M1wiXG59O1xuZXhwb3J0cy5uYWQyNyA9IHtcbiAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuICBlbGxpcHNlOiBcImNscms2NlwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTkyN1wiXG59O1xuZXhwb3J0cy5wb3RzZGFtID0ge1xuICB0b3dnczg0OiBcIjYwNi4wLDIzLjAsNDEzLjBcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG59O1xuZXhwb3J0cy5jYXJ0aGFnZSA9IHtcbiAgdG93Z3M4NDogXCItMjYzLjAsNi4wLDQzMS4wXCIsXG4gIGVsbGlwc2U6IFwiY2xhcms4MFwiLFxuICBkYXR1bU5hbWU6IFwiQ2FydGhhZ2UgMTkzNCBUdW5pc2lhXCJcbn07XG5leHBvcnRzLmhlcm1hbm5za29nZWwgPSB7XG4gIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5leHBvcnRzLmlyZTY1ID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwibW9kX2FpcnlcIixcbiAgZGF0dW1OYW1lOiBcIklyZWxhbmQgMTk2NVwiXG59O1xuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5leHBvcnRzLm56Z2Q0OSA9IHtcbiAgdG93Z3M4NDogXCI1OS40NywtNS4wNCwxODcuNDQsMC40NywtMC4xLDEuMDI0LC00LjU5OTNcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJOZXcgWmVhbGFuZCBHZW9kZXRpYyBEYXR1bSAxOTQ5XCJcbn07XG5leHBvcnRzLm9zZ2IzNiA9IHtcbiAgdG93Z3M4NDogXCI0NDYuNDQ4LC0xMjUuMTU3LDU0Mi4wNjAsMC4xNTAyLDAuMjQ3MCwwLjg0MjEsLTIwLjQ4OTRcIixcbiAgZWxsaXBzZTogXCJhaXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcbmV4cG9ydHMuYmVkdWFyYW0gPSB7XG4gIHRvd2dzODQ6ICctMTA2LC04NywxODgnLFxuICBlbGxpcHNlOiAnY2xyazgwJyxcbiAgZGF0dW1OYW1lOiAnQmVkdWFyYW0nXG59O1xuZXhwb3J0cy5ndW51bmdfc2VnYXJhID0ge1xuICB0b3dnczg0OiAnLTQwMyw2ODQsNDEnLFxuICBlbGxpcHNlOiAnYmVzc2VsJyxcbiAgZGF0dW1OYW1lOiAnR3VudW5nIFNlZ2FyYSBKYWthcnRhJ1xufTtcbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59O1xufSx7fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5NRVJJVCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiTUVSSVQgMTk4M1wiXG59O1xuZXhwb3J0cy5TR1M4NSA9IHtcbiAgYTogNjM3ODEzNi4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiU292aWV0IEdlb2RldGljIFN5c3RlbSA4NVwiXG59O1xuZXhwb3J0cy5HUlM4MCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NzIyMjEwMSxcbiAgZWxsaXBzZU5hbWU6IFwiR1JTIDE5ODAoSVVHRywgMTk4MClcIlxufTtcbmV4cG9ydHMuSUFVNzYgPSB7XG4gIGE6IDYzNzgxNDAuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIklBVSAxOTc2XCJcbn07XG5leHBvcnRzLmFpcnkgPSB7XG4gIGE6IDYzNzc1NjMuMzk2LFxuICBiOiA2MzU2MjU2LjkxMCxcbiAgZWxsaXBzZU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5leHBvcnRzLkFQTDQgPSB7XG4gIGE6IDYzNzgxMzcsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIkFwcGwuIFBoeXNpY3MuIDE5NjVcIlxufTtcbmV4cG9ydHMuTldMOUQgPSB7XG4gIGE6IDYzNzgxNDUuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiTmF2YWwgV2VhcG9ucyBMYWIuLCAxOTY1XCJcbn07XG5leHBvcnRzLm1vZF9haXJ5ID0ge1xuICBhOiA2Mzc3MzQwLjE4OSxcbiAgYjogNjM1NjAzNC40NDYsXG4gIGVsbGlwc2VOYW1lOiBcIk1vZGlmaWVkIEFpcnlcIlxufTtcbmV4cG9ydHMuYW5kcmFlID0ge1xuICBhOiA2Mzc3MTA0LjQzLFxuICByZjogMzAwLjAsXG4gIGVsbGlwc2VOYW1lOiBcIkFuZHJhZSAxODc2IChEZW4uLCBJY2xuZC4pXCJcbn07XG5leHBvcnRzLmF1c3RfU0EgPSB7XG4gIGE6IDYzNzgxNjAuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiQXVzdHJhbGlhbiBOYXRsICYgUy4gQW1lci4gMTk2OVwiXG59O1xuZXhwb3J0cy5HUlM2NyA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI0NzE2NzQyNzAsXG4gIGVsbGlwc2VOYW1lOiBcIkdSUyA2NyhJVUdHIDE5NjcpXCJcbn07XG5leHBvcnRzLmJlc3NlbCA9IHtcbiAgYTogNjM3NzM5Ny4xNTUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDFcIlxufTtcbmV4cG9ydHMuYmVzc19uYW0gPSB7XG4gIGE6IDYzNzc0ODMuODY1LFxuICByZjogMjk5LjE1MjgxMjgsXG4gIGVsbGlwc2VOYW1lOiBcIkJlc3NlbCAxODQxIChOYW1pYmlhKVwiXG59O1xuZXhwb3J0cy5jbHJrNjYgPSB7XG4gIGE6IDYzNzgyMDYuNCxcbiAgYjogNjM1NjU4My44LFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg2NlwiXG59O1xuZXhwb3J0cy5jbHJrODAgPSB7XG4gIGE6IDYzNzgyNDkuMTQ1LFxuICByZjogMjkzLjQ2NjMsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODgwIG1vZC5cIlxufTtcbmV4cG9ydHMuY2xyazU4ID0ge1xuICBhOiA2Mzc4MjkzLjY0NTIwODc1OSxcbiAgcmY6IDI5NC4yNjA2NzYzNjkyNjU0LFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg1OFwiXG59O1xuZXhwb3J0cy5DUE0gPSB7XG4gIGE6IDYzNzU3MzguNyxcbiAgcmY6IDMzNC4yOSxcbiAgZWxsaXBzZU5hbWU6IFwiQ29tbS4gZGVzIFBvaWRzIGV0IE1lc3VyZXMgMTc5OVwiXG59O1xuZXhwb3J0cy5kZWxtYnIgPSB7XG4gIGE6IDYzNzY0MjguMCxcbiAgcmY6IDMxMS41LFxuICBlbGxpcHNlTmFtZTogXCJEZWxhbWJyZSAxODEwIChCZWxnaXVtKVwiXG59O1xuZXhwb3J0cy5lbmdlbGlzID0ge1xuICBhOiA2Mzc4MTM2LjA1LFxuICByZjogMjk4LjI1NjYsXG4gIGVsbGlwc2VOYW1lOiBcIkVuZ2VsaXMgMTk4NVwiXG59O1xuZXhwb3J0cy5ldnJzdDMwID0ge1xuICBhOiA2Mzc3Mjc2LjM0NSxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE4MzBcIlxufTtcbmV4cG9ydHMuZXZyc3Q0OCA9IHtcbiAgYTogNjM3NzMwNC4wNjMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTQ4XCJcbn07XG5leHBvcnRzLmV2cnN0NTYgPSB7XG4gIGE6IDYzNzczMDEuMjQzLFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTk1NlwiXG59O1xuZXhwb3J0cy5ldnJzdDY5ID0ge1xuICBhOiA2Mzc3Mjk1LjY2NCxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NjlcIlxufTtcbmV4cG9ydHMuZXZyc3RTUyA9IHtcbiAgYTogNjM3NzI5OC41NTYsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAoU2FiYWggJiBTYXJhd2FrKVwiXG59O1xuZXhwb3J0cy5mc2NocjYwID0ge1xuICBhOiA2Mzc4MTY2LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAoTWVyY3VyeSBEYXR1bSkgMTk2MFwiXG59O1xuZXhwb3J0cy5mc2NocjYwbSA9IHtcbiAgYTogNjM3ODE1NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgMTk2MFwiXG59O1xuZXhwb3J0cy5mc2NocjY4ID0ge1xuICBhOiA2Mzc4MTUwLjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAxOTY4XCJcbn07XG5leHBvcnRzLmhlbG1lcnQgPSB7XG4gIGE6IDYzNzgyMDAuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJIZWxtZXJ0IDE5MDZcIlxufTtcbmV4cG9ydHMuaG91Z2ggPSB7XG4gIGE6IDYzNzgyNzAuMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJIb3VnaFwiXG59O1xuZXhwb3J0cy5pbnRsID0ge1xuICBhOiA2Mzc4Mzg4LjAsXG4gIHJmOiAyOTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiSW50ZXJuYXRpb25hbCAxOTA5IChIYXlmb3JkKVwiXG59O1xuZXhwb3J0cy5rYXVsYSA9IHtcbiAgYTogNjM3ODE2My4wLFxuICByZjogMjk4LjI0LFxuICBlbGxpcHNlTmFtZTogXCJLYXVsYSAxOTYxXCJcbn07XG5leHBvcnRzLmxlcmNoID0ge1xuICBhOiA2Mzc4MTM5LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJMZXJjaCAxOTc5XCJcbn07XG5leHBvcnRzLm1wcnRzID0ge1xuICBhOiA2Mzk3MzAwLjAsXG4gIHJmOiAxOTEuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTWF1cGVydGl1cyAxNzM4XCJcbn07XG5leHBvcnRzLm5ld19pbnRsID0ge1xuICBhOiA2Mzc4MTU3LjUsXG4gIGI6IDYzNTY3NzIuMixcbiAgZWxsaXBzZU5hbWU6IFwiTmV3IEludGVybmF0aW9uYWwgMTk2N1wiXG59O1xuZXhwb3J0cy5wbGVzc2lzID0ge1xuICBhOiA2Mzc2NTIzLjAsXG4gIHJmOiA2MzU1ODYzLjAsXG4gIGVsbGlwc2VOYW1lOiBcIlBsZXNzaXMgMTgxNyAoRnJhbmNlKVwiXG59O1xuZXhwb3J0cy5rcmFzcyA9IHtcbiAgYTogNjM3ODI0NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIktyYXNzb3Zza3ksIDE5NDJcIlxufTtcbmV4cG9ydHMuU0Vhc2lhID0ge1xuICBhOiA2Mzc4MTU1LjAsXG4gIGI6IDYzNTY3NzMuMzIwNSxcbiAgZWxsaXBzZU5hbWU6IFwiU291dGhlYXN0IEFzaWFcIlxufTtcbmV4cG9ydHMud2FsYmVjayA9IHtcbiAgYTogNjM3Njg5Ni4wLFxuICBiOiA2MzU1ODM0Ljg0NjcsXG4gIGVsbGlwc2VOYW1lOiBcIldhbGJlY2tcIlxufTtcbmV4cG9ydHMuV0dTNjAgPSB7XG4gIGE6IDYzNzgxNjUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjBcIlxufTtcbmV4cG9ydHMuV0dTNjYgPSB7XG4gIGE6IDYzNzgxNDUuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDY2XCJcbn07XG5leHBvcnRzLldHUzcgPSB7XG4gIGE6IDYzNzgxMzUuMCxcbiAgcmY6IDI5OC4yNixcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDcyXCJcbn07XG5leHBvcnRzLldHUzg0ID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIzNTYzLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgODRcIlxufTtcbmV4cG9ydHMuc3BoZXJlID0ge1xuICBhOiA2MzcwOTk3LjAsXG4gIGI6IDYzNzA5OTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTm9ybWFsIFNwaGVyZSAocj02MzcwOTk3KVwiXG59O1xufSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5ncmVlbndpY2ggPSAwLjA7IC8vXCIwZEVcIixcbmV4cG9ydHMubGlzYm9uID0gLTkuMTMxOTA2MTExMTExOyAvL1wiOWQwNyc1NC44NjJcXFwiV1wiLFxuZXhwb3J0cy5wYXJpcyA9IDIuMzM3MjI5MTY2NjY3OyAvL1wiMmQyMCcxNC4wMjVcXFwiRVwiLFxuZXhwb3J0cy5ib2dvdGEgPSAtNzQuMDgwOTE2NjY2NjY3OyAvL1wiNzRkMDQnNTEuM1xcXCJXXCIsXG5leHBvcnRzLm1hZHJpZCA9IC0zLjY4NzkzODg4ODg4OTsgLy9cIjNkNDEnMTYuNThcXFwiV1wiLFxuZXhwb3J0cy5yb21lID0gMTIuNDUyMzMzMzMzMzMzOyAvL1wiMTJkMjcnOC40XFxcIkVcIixcbmV4cG9ydHMuYmVybiA9IDcuNDM5NTgzMzMzMzMzOyAvL1wiN2QyNicyMi41XFxcIkVcIixcbmV4cG9ydHMuamFrYXJ0YSA9IDEwNi44MDc3MTk0NDQ0NDQ7IC8vXCIxMDZkNDgnMjcuNzlcXFwiRVwiLFxuZXhwb3J0cy5mZXJybyA9IC0xNy42NjY2NjY2NjY2Njc7IC8vXCIxN2Q0MCdXXCIsXG5leHBvcnRzLmJydXNzZWxzID0gNC4zNjc5NzU7IC8vXCI0ZDIyJzQuNzFcXFwiRVwiLFxuZXhwb3J0cy5zdG9ja2hvbG0gPSAxOC4wNTgyNzc3Nzc3Nzg7IC8vXCIxOGQzJzI5LjhcXFwiRVwiLFxuZXhwb3J0cy5hdGhlbnMgPSAyMy43MTYzMzc1OyAvL1wiMjNkNDInNTguODE1XFxcIkVcIixcbmV4cG9ydHMub3NsbyA9IDEwLjcyMjkxNjY2NjY2NzsgLy9cIjEwZDQzJzIyLjVcXFwiRVwiXG59LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLmZ0ID0ge3RvX21ldGVyOiAwLjMwNDh9O1xuZXhwb3J0c1sndXMtZnQnXSA9IHt0b19tZXRlcjogMTIwMCAvIDM5Mzd9O1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcHJvaiA9IF9kZXJlcV8oJy4vUHJvaicpO1xudmFyIHRyYW5zZm9ybSA9IF9kZXJlcV8oJy4vdHJhbnNmb3JtJyk7XG52YXIgd2dzODQgPSBwcm9qKCdXR1M4NCcpO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihmcm9tLCB0bywgY29vcmRzKSB7XG4gIHZhciB0cmFuc2Zvcm1lZEFycmF5O1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29yZHMpKSB7XG4gICAgdHJhbnNmb3JtZWRBcnJheSA9IHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzKTtcbiAgICBpZiAoY29vcmRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueSwgdHJhbnNmb3JtZWRBcnJheS56XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55XTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb2ooaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIHByb2opIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBpZiAoaXRlbS5vUHJvaikge1xuICAgIHJldHVybiBpdGVtLm9Qcm9qO1xuICB9XG4gIHJldHVybiBwcm9qKGl0ZW0pO1xufVxuZnVuY3Rpb24gcHJvajQoZnJvbVByb2osIHRvUHJvaiwgY29vcmQpIHtcbiAgZnJvbVByb2ogPSBjaGVja1Byb2ooZnJvbVByb2opO1xuICB2YXIgc2luZ2xlID0gZmFsc2U7XG4gIHZhciBvYmo7XG4gIGlmICh0eXBlb2YgdG9Qcm9qID09PSAndW5kZWZpbmVkJykge1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdG9Qcm9qLnggIT09ICd1bmRlZmluZWQnIHx8IEFycmF5LmlzQXJyYXkodG9Qcm9qKSkge1xuICAgIGNvb3JkID0gdG9Qcm9qO1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfVxuICB0b1Byb2ogPSBjaGVja1Byb2oodG9Qcm9qKTtcbiAgaWYgKGNvb3JkKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKTtcbiAgfVxuICBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBmb3J3YXJkOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGZyb21Qcm9qLCB0b1Byb2osIGNvb3Jkcyk7XG4gICAgICB9LFxuICAgICAgaW52ZXJzZTogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih0b1Byb2osIGZyb21Qcm9qLCBjb29yZHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNpbmdsZSkge1xuICAgICAgb2JqLm9Qcm9qID0gdG9Qcm9qO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHByb2o0O1xufSx7XCIuL1Byb2pcIjoyLFwiLi90cmFuc2Zvcm1cIjo2NX1dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIFBKRF9HUklEU0hJRlQgPSAzO1xudmFyIFBKRF9XR1M4NCA9IDQ7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbnZhciBQSkRfTk9EQVRVTSA9IDU7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcbnZhciBTRUNfVE9fUkFEID0gNC44NDgxMzY4MTEwOTUzNTk5MzU4OTkxNDEwMjM1N2UtNjtcbnZhciBBRF9DID0gMS4wMDI2MDAwO1xudmFyIENPU182N1A1ID0gMC4zODI2ODM0MzIzNjUwODk3NztcbnZhciBkYXR1bSA9IGZ1bmN0aW9uKHByb2opIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGRhdHVtKSkge1xuICAgIHJldHVybiBuZXcgZGF0dW0ocHJvaik7XG4gIH1cbiAgdGhpcy5kYXR1bV90eXBlID0gUEpEX1dHUzg0OyAvL2RlZmF1bHQgc2V0dGluZ1xuICBpZiAoIXByb2opIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2ouZGF0dW1Db2RlICYmIHByb2ouZGF0dW1Db2RlID09PSAnbm9uZScpIHtcbiAgICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfTk9EQVRVTTtcbiAgfVxuXG4gIGlmIChwcm9qLmRhdHVtX3BhcmFtcykge1xuICAgIHRoaXMuZGF0dW1fcGFyYW1zID0gcHJvai5kYXR1bV9wYXJhbXMubWFwKHBhcnNlRmxvYXQpO1xuICAgIGlmICh0aGlzLmRhdHVtX3BhcmFtc1swXSAhPT0gMCB8fCB0aGlzLmRhdHVtX3BhcmFtc1sxXSAhPT0gMCB8fCB0aGlzLmRhdHVtX3BhcmFtc1syXSAhPT0gMCkge1xuICAgICAgdGhpcy5kYXR1bV90eXBlID0gUEpEXzNQQVJBTTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0dW1fcGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0aGlzLmRhdHVtX3BhcmFtc1szXSAhPT0gMCB8fCB0aGlzLmRhdHVtX3BhcmFtc1s0XSAhPT0gMCB8fCB0aGlzLmRhdHVtX3BhcmFtc1s1XSAhPT0gMCB8fCB0aGlzLmRhdHVtX3BhcmFtc1s2XSAhPT0gMCkge1xuICAgICAgICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfN1BBUkFNO1xuICAgICAgICB0aGlzLmRhdHVtX3BhcmFtc1szXSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICB0aGlzLmRhdHVtX3BhcmFtc1s0XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICB0aGlzLmRhdHVtX3BhcmFtc1s1XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICB0aGlzLmRhdHVtX3BhcmFtc1s2XSA9ICh0aGlzLmRhdHVtX3BhcmFtc1s2XSAvIDEwMDAwMDAuMCkgKyAxLjA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gREdSIDIwMTEtMDMtMjEgOiBuYWRncmlkcyBzdXBwb3J0XG4gIHRoaXMuZGF0dW1fdHlwZSA9IHByb2ouZ3JpZHMgPyBQSkRfR1JJRFNISUZUIDogdGhpcy5kYXR1bV90eXBlO1xuXG4gIHRoaXMuYSA9IHByb2ouYTsgLy9kYXR1bSBvYmplY3QgYWxzbyB1c2VzIHRoZXNlIHZhbHVlc1xuICB0aGlzLmIgPSBwcm9qLmI7XG4gIHRoaXMuZXMgPSBwcm9qLmVzO1xuICB0aGlzLmVwMiA9IHByb2ouZXAyO1xuICBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfR1JJRFNISUZUKSB7XG4gICAgdGhpcy5ncmlkcyA9IHByb2ouZ3JpZHM7XG4gIH1cbn07XG5kYXR1bS5wcm90b3R5cGUgPSB7XG5cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gY3NfY29tcGFyZV9kYXR1bXMoKVxuICAvLyAgIFJldHVybnMgVFJVRSBpZiB0aGUgdHdvIGRhdHVtcyBtYXRjaCwgb3RoZXJ3aXNlIEZBTFNFLlxuICBjb21wYXJlX2RhdHVtczogZnVuY3Rpb24oZGVzdCkge1xuICAgIGlmICh0aGlzLmRhdHVtX3R5cGUgIT09IGRlc3QuZGF0dW1fdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBmYWxzZSwgZGF0dW1zIGFyZSBub3QgZXF1YWxcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5hICE9PSBkZXN0LmEgfHwgTWF0aC5hYnModGhpcy5lcyAtIGRlc3QuZXMpID4gMC4wMDAwMDAwMDAwNTApIHtcbiAgICAgIC8vIHRoZSB0b2xlcmVuY2UgZm9yIGVzIGlzIHRvIGVuc3VyZSB0aGF0IEdSUzgwIGFuZCBXR1M4NFxuICAgICAgLy8gYXJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgICAgcmV0dXJuICh0aGlzLmRhdHVtX3BhcmFtc1swXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMF0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbMV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzFdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgICAgcmV0dXJuICh0aGlzLmRhdHVtX3BhcmFtc1swXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMF0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbMV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzFdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1szXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbM10gJiYgdGhpcy5kYXR1bV9wYXJhbXNbNF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzRdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzVdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s1XSAmJiB0aGlzLmRhdHVtX3BhcmFtc1s2XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNl0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQgfHwgZGVzdC5kYXR1bV90eXBlID09PSBQSkRfR1JJRFNISUZUKSB7XG4gICAgICAvL2FsZXJ0KFwiRVJST1I6IEdyaWQgc2hpZnQgdHJhbnNmb3JtYXRpb25zIGFyZSBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgLy9yZXR1cm4gZmFsc2VcbiAgICAgIC8vREdSIDIwMTItMDctMjkgbGF6eSAuLi5cbiAgICAgIHJldHVybiB0aGlzLm5hZGdyaWRzID09PSBkZXN0Lm5hZGdyaWRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBkYXR1bXMgYXJlIGVxdWFsXG4gICAgfVxuICB9LCAvLyBjc19jb21wYXJlX2RhdHVtcygpXG5cbiAgLypcbiAgICogVGhlIGZ1bmN0aW9uIENvbnZlcnRfR2VvZGV0aWNfVG9fR2VvY2VudHJpYyBjb252ZXJ0cyBnZW9kZXRpYyBjb29yZGluYXRlc1xuICAgKiAobGF0aXR1ZGUsIGxvbmdpdHVkZSwgYW5kIGhlaWdodCkgdG8gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoWCwgWSwgWiksXG4gICAqIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBlbGxpcHNvaWQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogICAgTGF0aXR1ZGUgIDogR2VvZGV0aWMgbGF0aXR1ZGUgaW4gcmFkaWFucyAgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAgICogICAgTG9uZ2l0dWRlIDogR2VvZGV0aWMgbG9uZ2l0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAgICogICAgSGVpZ2h0ICAgIDogR2VvZGV0aWMgaGVpZ2h0LCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dClcbiAgICogICAgWCAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFggY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gICAqICAgIFkgICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBZIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICAgKiAgICBaICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWiBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAgICpcbiAgICovXG4gIGdlb2RldGljX3RvX2dlb2NlbnRyaWM6IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgTG9uZ2l0dWRlID0gcC54O1xuICAgIHZhciBMYXRpdHVkZSA9IHAueTtcbiAgICB2YXIgSGVpZ2h0ID0gcC56ID8gcC56IDogMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcbiAgICB2YXIgWDsgLy8gb3V0cHV0XG4gICAgdmFyIFk7XG4gICAgdmFyIFo7XG5cbiAgICB2YXIgRXJyb3JfQ29kZSA9IDA7IC8vICBHRU9DRU5UX05PX0VSUk9SO1xuICAgIHZhciBSbjsgLyogIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAgKi9cbiAgICB2YXIgU2luX0xhdDsgLyogIE1hdGguc2luKExhdGl0dWRlKSAgKi9cbiAgICB2YXIgU2luMl9MYXQ7IC8qICBTcXVhcmUgb2YgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICAgIHZhciBDb3NfTGF0OyAvKiAgTWF0aC5jb3MoTGF0aXR1ZGUpICAqL1xuXG4gICAgLypcbiAgICAgKiogRG9uJ3QgYmxvdyB1cCBpZiBMYXRpdHVkZSBpcyBqdXN0IGEgbGl0dGxlIG91dCBvZiB0aGUgdmFsdWVcbiAgICAgKiogcmFuZ2UgYXMgaXQgbWF5IGp1c3QgYmUgYSByb3VuZGluZyBpc3N1ZS4gIEFsc28gcmVtb3ZlZCBsb25naXR1ZGVcbiAgICAgKiogdGVzdCwgaXQgc2hvdWxkIGJlIHdyYXBwZWQgYnkgTWF0aC5jb3MoKSBhbmQgTWF0aC5zaW4oKS4gIE5GVyBmb3IgUFJPSi40LCBTZXAvMjAwMS5cbiAgICAgKi9cbiAgICBpZiAoTGF0aXR1ZGUgPCAtSEFMRl9QSSAmJiBMYXRpdHVkZSA+IC0xLjAwMSAqIEhBTEZfUEkpIHtcbiAgICAgIExhdGl0dWRlID0gLUhBTEZfUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKExhdGl0dWRlID4gSEFMRl9QSSAmJiBMYXRpdHVkZSA8IDEuMDAxICogSEFMRl9QSSkge1xuICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgIH1cbiAgICBlbHNlIGlmICgoTGF0aXR1ZGUgPCAtSEFMRl9QSSkgfHwgKExhdGl0dWRlID4gSEFMRl9QSSkpIHtcbiAgICAgIC8qIExhdGl0dWRlIG91dCBvZiByYW5nZSAqL1xuICAgICAgLy8uLnJlcG9ydEVycm9yKCdnZW9jZW50OmxhdCBvdXQgb2YgcmFuZ2U6JyArIExhdGl0dWRlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChMb25naXR1ZGUgPiBNYXRoLlBJKSB7XG4gICAgICBMb25naXR1ZGUgLT0gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG4gICAgU2luX0xhdCA9IE1hdGguc2luKExhdGl0dWRlKTtcbiAgICBDb3NfTGF0ID0gTWF0aC5jb3MoTGF0aXR1ZGUpO1xuICAgIFNpbjJfTGF0ID0gU2luX0xhdCAqIFNpbl9MYXQ7XG4gICAgUm4gPSB0aGlzLmEgLyAoTWF0aC5zcXJ0KDEuMGUwIC0gdGhpcy5lcyAqIFNpbjJfTGF0KSk7XG4gICAgWCA9IChSbiArIEhlaWdodCkgKiBDb3NfTGF0ICogTWF0aC5jb3MoTG9uZ2l0dWRlKTtcbiAgICBZID0gKFJuICsgSGVpZ2h0KSAqIENvc19MYXQgKiBNYXRoLnNpbihMb25naXR1ZGUpO1xuICAgIFogPSAoKFJuICogKDEgLSB0aGlzLmVzKSkgKyBIZWlnaHQpICogU2luX0xhdDtcblxuICAgIHAueCA9IFg7XG4gICAgcC55ID0gWTtcbiAgICBwLnogPSBaO1xuICAgIHJldHVybiBFcnJvcl9Db2RlO1xuICB9LCAvLyBjc19nZW9kZXRpY190b19nZW9jZW50cmljKClcblxuXG4gIGdlb2NlbnRyaWNfdG9fZ2VvZGV0aWM6IGZ1bmN0aW9uKHApIHtcbiAgICAvKiBsb2NhbCBkZWZpbnRpb25zIGFuZCB2YXJpYWJsZXMgKi9cbiAgICAvKiBlbmQtY3JpdGVyaXVtIG9mIGxvb3AsIGFjY3VyYWN5IG9mIHNpbihMYXRpdHVkZSkgKi9cbiAgICB2YXIgZ2VuYXUgPSAxZS0xMjtcbiAgICB2YXIgZ2VuYXUyID0gKGdlbmF1ICogZ2VuYXUpO1xuICAgIHZhciBtYXhpdGVyID0gMzA7XG5cbiAgICB2YXIgUDsgLyogZGlzdGFuY2UgYmV0d2VlbiBzZW1pLW1pbm9yIGF4aXMgYW5kIGxvY2F0aW9uICovXG4gICAgdmFyIFJSOyAvKiBkaXN0YW5jZSBiZXR3ZWVuIGNlbnRlciBhbmQgbG9jYXRpb24gKi9cbiAgICB2YXIgQ1Q7IC8qIHNpbiBvZiBnZW9jZW50cmljIGxhdGl0dWRlICovXG4gICAgdmFyIFNUOyAvKiBjb3Mgb2YgZ2VvY2VudHJpYyBsYXRpdHVkZSAqL1xuICAgIHZhciBSWDtcbiAgICB2YXIgUks7XG4gICAgdmFyIFJOOyAvKiBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gKi9cbiAgICB2YXIgQ1BISTA7IC8qIGNvcyBvZiBzdGFydCBvciBvbGQgZ2VvZGV0aWMgbGF0aXR1ZGUgaW4gaXRlcmF0aW9ucyAqL1xuICAgIHZhciBTUEhJMDsgLyogc2luIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gICAgdmFyIENQSEk7IC8qIGNvcyBvZiBzZWFyY2hlZCBnZW9kZXRpYyBsYXRpdHVkZSAqL1xuICAgIHZhciBTUEhJOyAvKiBzaW4gb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cbiAgICB2YXIgU0RQSEk7IC8qIGVuZC1jcml0ZXJpdW06IGFkZGl0aW9uLXRoZW9yZW0gb2Ygc2luKExhdGl0dWRlKGl0ZXIpLUxhdGl0dWRlKGl0ZXItMSkpICovXG4gICAgdmFyIEF0X1BvbGU7IC8qIGluZGljYXRlcyBsb2NhdGlvbiBpcyBpbiBwb2xhciByZWdpb24gKi9cbiAgICB2YXIgaXRlcjsgLyogIyBvZiBjb250aW5vdXMgaXRlcmF0aW9uLCBtYXguIDMwIGlzIGFsd2F5cyBlbm91Z2ggKHMuYS4pICovXG5cbiAgICB2YXIgWCA9IHAueDtcbiAgICB2YXIgWSA9IHAueTtcbiAgICB2YXIgWiA9IHAueiA/IHAueiA6IDAuMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcbiAgICB2YXIgTG9uZ2l0dWRlO1xuICAgIHZhciBMYXRpdHVkZTtcbiAgICB2YXIgSGVpZ2h0O1xuXG4gICAgQXRfUG9sZSA9IGZhbHNlO1xuICAgIFAgPSBNYXRoLnNxcnQoWCAqIFggKyBZICogWSk7XG4gICAgUlIgPSBNYXRoLnNxcnQoWCAqIFggKyBZICogWSArIFogKiBaKTtcblxuICAgIC8qICAgICAgc3BlY2lhbCBjYXNlcyBmb3IgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAqL1xuICAgIGlmIChQIC8gdGhpcy5hIDwgZ2VuYXUpIHtcblxuICAgICAgLyogIHNwZWNpYWwgY2FzZSwgaWYgUD0wLiAoWD0wLiwgWT0wLikgKi9cbiAgICAgIEF0X1BvbGUgPSB0cnVlO1xuICAgICAgTG9uZ2l0dWRlID0gMC4wO1xuXG4gICAgICAvKiAgaWYgKFgsWSxaKT0oMC4sMC4sMC4pIHRoZW4gSGVpZ2h0IGJlY29tZXMgc2VtaS1taW5vciBheGlzXG4gICAgICAgKiAgb2YgZWxsaXBzb2lkICg9Y2VudGVyIG9mIG1hc3MpLCBMYXRpdHVkZSBiZWNvbWVzIFBJLzIgKi9cbiAgICAgIGlmIChSUiAvIHRoaXMuYSA8IGdlbmF1KSB7XG4gICAgICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgICAgICAgSGVpZ2h0ID0gLXRoaXMuYjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8qICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGxvbmdpdHVkZVxuICAgICAgICogIGludGVydmFsOiAtUEkgPCBMb25naXR1ZGUgPD0gK1BJICovXG4gICAgICBMb25naXR1ZGUgPSBNYXRoLmF0YW4yKFksIFgpO1xuICAgIH1cblxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogRm9sbG93aW5nIGl0ZXJhdGl2ZSBhbGdvcml0aG0gd2FzIGRldmVsb3BwZWQgYnlcbiAgICAgKiBcIkluc3RpdHV0IGZvciBFcmRtZXNzdW5nXCIsIFVuaXZlcnNpdHkgb2YgSGFubm92ZXIsIEp1bHkgMTk4OC5cbiAgICAgKiBJbnRlcm5ldDogd3d3LmlmZS51bmktaGFubm92ZXIuZGVcbiAgICAgKiBJdGVyYXRpdmUgY29tcHV0YXRpb24gb2YgQ1BISSxTUEhJIGFuZCBIZWlnaHQuXG4gICAgICogSXRlcmF0aW9uIG9mIENQSEkgYW5kIFNQSEkgdG8gMTAqKi0xMiByYWRpYW4gcmVzcC5cbiAgICAgKiAyKjEwKiotNyBhcmNzZWMuXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cbiAgICBDVCA9IFogLyBSUjtcbiAgICBTVCA9IFAgLyBSUjtcbiAgICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSB0aGlzLmVzICogKDIuMCAtIHRoaXMuZXMpICogU1QgKiBTVCk7XG4gICAgQ1BISTAgPSBTVCAqICgxLjAgLSB0aGlzLmVzKSAqIFJYO1xuICAgIFNQSEkwID0gQ1QgKiBSWDtcbiAgICBpdGVyID0gMDtcblxuICAgIC8qIGxvb3AgdG8gZmluZCBzaW4oTGF0aXR1ZGUpIHJlc3AuIExhdGl0dWRlXG4gICAgICogdW50aWwgfHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKXwgPCBnZW5hdSAqL1xuICAgIGRvIHtcbiAgICAgIGl0ZXIrKztcbiAgICAgIFJOID0gdGhpcy5hIC8gTWF0aC5zcXJ0KDEuMCAtIHRoaXMuZXMgKiBTUEhJMCAqIFNQSEkwKTtcblxuICAgICAgLyogIGVsbGlwc29pZGFsIChnZW9kZXRpYykgaGVpZ2h0ICovXG4gICAgICBIZWlnaHQgPSBQICogQ1BISTAgKyBaICogU1BISTAgLSBSTiAqICgxLjAgLSB0aGlzLmVzICogU1BISTAgKiBTUEhJMCk7XG5cbiAgICAgIFJLID0gdGhpcy5lcyAqIFJOIC8gKFJOICsgSGVpZ2h0KTtcbiAgICAgIFJYID0gMS4wIC8gTWF0aC5zcXJ0KDEuMCAtIFJLICogKDIuMCAtIFJLKSAqIFNUICogU1QpO1xuICAgICAgQ1BISSA9IFNUICogKDEuMCAtIFJLKSAqIFJYO1xuICAgICAgU1BISSA9IENUICogUlg7XG4gICAgICBTRFBISSA9IFNQSEkgKiBDUEhJMCAtIENQSEkgKiBTUEhJMDtcbiAgICAgIENQSEkwID0gQ1BISTtcbiAgICAgIFNQSEkwID0gU1BISTtcbiAgICB9XG4gICAgd2hpbGUgKFNEUEhJICogU0RQSEkgPiBnZW5hdTIgJiYgaXRlciA8IG1heGl0ZXIpO1xuXG4gICAgLyogICAgICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGxhdGl0dWRlICovXG4gICAgTGF0aXR1ZGUgPSBNYXRoLmF0YW4oU1BISSAvIE1hdGguYWJzKENQSEkpKTtcblxuICAgIHAueCA9IExvbmdpdHVkZTtcbiAgICBwLnkgPSBMYXRpdHVkZTtcbiAgICBwLnogPSBIZWlnaHQ7XG4gICAgcmV0dXJuIHA7XG4gIH0sIC8vIGNzX2dlb2NlbnRyaWNfdG9fZ2VvZGV0aWMoKVxuXG4gIC8qKiBDb252ZXJ0X0dlb2NlbnRyaWNfVG9fR2VvZGV0aWNcbiAgICogVGhlIG1ldGhvZCB1c2VkIGhlcmUgaXMgZGVyaXZlZCBmcm9tICdBbiBJbXByb3ZlZCBBbGdvcml0aG0gZm9yXG4gICAqIEdlb2NlbnRyaWMgdG8gR2VvZGV0aWMgQ29vcmRpbmF0ZSBDb252ZXJzaW9uJywgYnkgUmFscGggVG9tcywgRmViIDE5OTZcbiAgICovXG4gIGdlb2NlbnRyaWNfdG9fZ2VvZGV0aWNfbm9uaXRlcjogZnVuY3Rpb24ocCkge1xuICAgIHZhciBYID0gcC54O1xuICAgIHZhciBZID0gcC55O1xuICAgIHZhciBaID0gcC56ID8gcC56IDogMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcbiAgICB2YXIgTG9uZ2l0dWRlO1xuICAgIHZhciBMYXRpdHVkZTtcbiAgICB2YXIgSGVpZ2h0O1xuXG4gICAgdmFyIFc7IC8qIGRpc3RhbmNlIGZyb20gWiBheGlzICovXG4gICAgdmFyIFcyOyAvKiBzcXVhcmUgb2YgZGlzdGFuY2UgZnJvbSBaIGF4aXMgKi9cbiAgICB2YXIgVDA7IC8qIGluaXRpYWwgZXN0aW1hdGUgb2YgdmVydGljYWwgY29tcG9uZW50ICovXG4gICAgdmFyIFQxOyAvKiBjb3JyZWN0ZWQgZXN0aW1hdGUgb2YgdmVydGljYWwgY29tcG9uZW50ICovXG4gICAgdmFyIFMwOyAvKiBpbml0aWFsIGVzdGltYXRlIG9mIGhvcml6b250YWwgY29tcG9uZW50ICovXG4gICAgdmFyIFMxOyAvKiBjb3JyZWN0ZWQgZXN0aW1hdGUgb2YgaG9yaXpvbnRhbCBjb21wb25lbnQgKi9cbiAgICB2YXIgU2luX0IwOyAvKiBNYXRoLnNpbihCMCksIEIwIGlzIGVzdGltYXRlIG9mIEJvd3JpbmcgYXV4IHZhcmlhYmxlICovXG4gICAgdmFyIFNpbjNfQjA7IC8qIGN1YmUgb2YgTWF0aC5zaW4oQjApICovXG4gICAgdmFyIENvc19CMDsgLyogTWF0aC5jb3MoQjApICovXG4gICAgdmFyIFNpbl9wMTsgLyogTWF0aC5zaW4ocGhpMSksIHBoaTEgaXMgZXN0aW1hdGVkIGxhdGl0dWRlICovXG4gICAgdmFyIENvc19wMTsgLyogTWF0aC5jb3MocGhpMSkgKi9cbiAgICB2YXIgUm47IC8qIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAqL1xuICAgIHZhciBTdW07IC8qIG51bWVyYXRvciBvZiBNYXRoLmNvcyhwaGkxKSAqL1xuICAgIHZhciBBdF9Qb2xlOyAvKiBpbmRpY2F0ZXMgbG9jYXRpb24gaXMgaW4gcG9sYXIgcmVnaW9uICovXG5cbiAgICBYID0gcGFyc2VGbG9hdChYKTsgLy8gY2FzdCBmcm9tIHN0cmluZyB0byBmbG9hdFxuICAgIFkgPSBwYXJzZUZsb2F0KFkpO1xuICAgIFogPSBwYXJzZUZsb2F0KFopO1xuXG4gICAgQXRfUG9sZSA9IGZhbHNlO1xuICAgIGlmIChYICE9PSAwLjApIHtcbiAgICAgIExvbmdpdHVkZSA9IE1hdGguYXRhbjIoWSwgWCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKFkgPiAwKSB7XG4gICAgICAgIExvbmdpdHVkZSA9IEhBTEZfUEk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChZIDwgMCkge1xuICAgICAgICBMb25naXR1ZGUgPSAtSEFMRl9QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBBdF9Qb2xlID0gdHJ1ZTtcbiAgICAgICAgTG9uZ2l0dWRlID0gMC4wO1xuICAgICAgICBpZiAoWiA+IDAuMCkgeyAvKiBub3J0aCBwb2xlICovXG4gICAgICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFogPCAwLjApIHsgLyogc291dGggcG9sZSAqL1xuICAgICAgICAgIExhdGl0dWRlID0gLUhBTEZfUEk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8qIGNlbnRlciBvZiBlYXJ0aCAqL1xuICAgICAgICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgICAgICAgICBIZWlnaHQgPSAtdGhpcy5iO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBXMiA9IFggKiBYICsgWSAqIFk7XG4gICAgVyA9IE1hdGguc3FydChXMik7XG4gICAgVDAgPSBaICogQURfQztcbiAgICBTMCA9IE1hdGguc3FydChUMCAqIFQwICsgVzIpO1xuICAgIFNpbl9CMCA9IFQwIC8gUzA7XG4gICAgQ29zX0IwID0gVyAvIFMwO1xuICAgIFNpbjNfQjAgPSBTaW5fQjAgKiBTaW5fQjAgKiBTaW5fQjA7XG4gICAgVDEgPSBaICsgdGhpcy5iICogdGhpcy5lcDIgKiBTaW4zX0IwO1xuICAgIFN1bSA9IFcgLSB0aGlzLmEgKiB0aGlzLmVzICogQ29zX0IwICogQ29zX0IwICogQ29zX0IwO1xuICAgIFMxID0gTWF0aC5zcXJ0KFQxICogVDEgKyBTdW0gKiBTdW0pO1xuICAgIFNpbl9wMSA9IFQxIC8gUzE7XG4gICAgQ29zX3AxID0gU3VtIC8gUzE7XG4gICAgUm4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoMS4wIC0gdGhpcy5lcyAqIFNpbl9wMSAqIFNpbl9wMSk7XG4gICAgaWYgKENvc19wMSA+PSBDT1NfNjdQNSkge1xuICAgICAgSGVpZ2h0ID0gVyAvIENvc19wMSAtIFJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChDb3NfcDEgPD0gLUNPU182N1A1KSB7XG4gICAgICBIZWlnaHQgPSBXIC8gLUNvc19wMSAtIFJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIEhlaWdodCA9IFogLyBTaW5fcDEgKyBSbiAqICh0aGlzLmVzIC0gMS4wKTtcbiAgICB9XG4gICAgaWYgKEF0X1BvbGUgPT09IGZhbHNlKSB7XG4gICAgICBMYXRpdHVkZSA9IE1hdGguYXRhbihTaW5fcDEgLyBDb3NfcDEpO1xuICAgIH1cblxuICAgIHAueCA9IExvbmdpdHVkZTtcbiAgICBwLnkgPSBMYXRpdHVkZTtcbiAgICBwLnogPSBIZWlnaHQ7XG4gICAgcmV0dXJuIHA7XG4gIH0sIC8vIGdlb2NlbnRyaWNfdG9fZ2VvZGV0aWNfbm9uaXRlcigpXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8vIHBqX2dlb2NlbnRpY190b193Z3M4NCggcCApXG4gIC8vICBwID0gcG9pbnQgdG8gdHJhbnNmb3JtIGluIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKHgseSx6KVxuICBnZW9jZW50cmljX3RvX3dnczg0OiBmdW5jdGlvbihwKSB7XG5cbiAgICBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAgIC8vICAgIGNvbnRpbnVlO1xuICAgICAgcC54ICs9IHRoaXMuZGF0dW1fcGFyYW1zWzBdO1xuICAgICAgcC55ICs9IHRoaXMuZGF0dW1fcGFyYW1zWzFdO1xuICAgICAgcC56ICs9IHRoaXMuZGF0dW1fcGFyYW1zWzJdO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgICAgdmFyIER4X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMF07XG4gICAgICB2YXIgRHlfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1sxXTtcbiAgICAgIHZhciBEel9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzJdO1xuICAgICAgdmFyIFJ4X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbM107XG4gICAgICB2YXIgUnlfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s0XTtcbiAgICAgIHZhciBSel9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzVdO1xuICAgICAgdmFyIE1fQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s2XTtcbiAgICAgIC8vIGlmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgICAgLy8gICAgY29udGludWU7XG4gICAgICB2YXIgeF9vdXQgPSBNX0JGICogKHAueCAtIFJ6X0JGICogcC55ICsgUnlfQkYgKiBwLnopICsgRHhfQkY7XG4gICAgICB2YXIgeV9vdXQgPSBNX0JGICogKFJ6X0JGICogcC54ICsgcC55IC0gUnhfQkYgKiBwLnopICsgRHlfQkY7XG4gICAgICB2YXIgel9vdXQgPSBNX0JGICogKC1SeV9CRiAqIHAueCArIFJ4X0JGICogcC55ICsgcC56KSArIER6X0JGO1xuICAgICAgcC54ID0geF9vdXQ7XG4gICAgICBwLnkgPSB5X291dDtcbiAgICAgIHAueiA9IHpfb3V0O1xuICAgIH1cbiAgfSwgLy8gY3NfZ2VvY2VudHJpY190b193Z3M4NFxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvLyBwal9nZW9jZW50aWNfZnJvbV93Z3M4NCgpXG4gIC8vICBjb29yZGluYXRlIHN5c3RlbSBkZWZpbml0aW9uLFxuICAvLyAgcG9pbnQgdG8gdHJhbnNmb3JtIGluIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKHgseSx6KVxuICBnZW9jZW50cmljX2Zyb21fd2dzODQ6IGZ1bmN0aW9uKHApIHtcblxuICAgIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcbiAgICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgICAvLyAgICBjb250aW51ZTtcbiAgICAgIHAueCAtPSB0aGlzLmRhdHVtX3BhcmFtc1swXTtcbiAgICAgIHAueSAtPSB0aGlzLmRhdHVtX3BhcmFtc1sxXTtcbiAgICAgIHAueiAtPSB0aGlzLmRhdHVtX3BhcmFtc1syXTtcblxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICAgIHZhciBEeF9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzBdO1xuICAgICAgdmFyIER5X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMV07XG4gICAgICB2YXIgRHpfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1syXTtcbiAgICAgIHZhciBSeF9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzNdO1xuICAgICAgdmFyIFJ5X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNF07XG4gICAgICB2YXIgUnpfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s1XTtcbiAgICAgIHZhciBNX0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNl07XG4gICAgICB2YXIgeF90bXAgPSAocC54IC0gRHhfQkYpIC8gTV9CRjtcbiAgICAgIHZhciB5X3RtcCA9IChwLnkgLSBEeV9CRikgLyBNX0JGO1xuICAgICAgdmFyIHpfdG1wID0gKHAueiAtIER6X0JGKSAvIE1fQkY7XG4gICAgICAvL2lmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgICAgLy8gICAgY29udGludWU7XG5cbiAgICAgIHAueCA9IHhfdG1wICsgUnpfQkYgKiB5X3RtcCAtIFJ5X0JGICogel90bXA7XG4gICAgICBwLnkgPSAtUnpfQkYgKiB4X3RtcCArIHlfdG1wICsgUnhfQkYgKiB6X3RtcDtcbiAgICAgIHAueiA9IFJ5X0JGICogeF90bXAgLSBSeF9CRiAqIHlfdG1wICsgel90bXA7XG4gICAgfSAvL2NzX2dlb2NlbnRyaWNfZnJvbV93Z3M4NCgpXG4gIH1cbn07XG5cbi8qKiBwb2ludCBvYmplY3QsIG5vdGhpbmcgZmFuY3ksIGp1c3QgYWxsb3dzIHZhbHVlcyB0byBiZVxuICAgIHBhc3NlZCBiYWNrIGFuZCBmb3J0aCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gYnkgdmFsdWUuXG4gICAgT3RoZXIgcG9pbnQgY2xhc3NlcyBtYXkgYmUgdXNlZCBhcyBsb25nIGFzIHRoZXkgaGF2ZVxuICAgIHggYW5kIHkgcHJvcGVydGllcywgd2hpY2ggd2lsbCBnZXQgbW9kaWZpZWQgaW4gdGhlIHRyYW5zZm9ybSBtZXRob2QuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBkYXR1bTtcblxufSx7fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIFBKRF9HUklEU0hJRlQgPSAzO1xudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFNSU19XR1M4NF9TRU1JTUFKT1IgPSA2Mzc4MTM3OyAvLyBvbmx5IHVzZWQgaW4gZ3JpZCBzaGlmdCB0cmFuc2Zvcm1zXG52YXIgU1JTX1dHUzg0X0VTUVVBUkVEID0gMC4wMDY2OTQzNzk5OTAxNDEzMTY7IC8vREdSOiAyMDEyLTA3LTI5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgdmFyIHdwLCBpLCBsO1xuXG4gIGZ1bmN0aW9uIGNoZWNrUGFyYW1zKGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIChmYWxsYmFjayA9PT0gUEpEXzNQQVJBTSB8fCBmYWxsYmFjayA9PT0gUEpEXzdQQVJBTSk7XG4gIH1cbiAgLy8gU2hvcnQgY3V0IGlmIHRoZSBkYXR1bXMgYXJlIGlkZW50aWNhbC5cbiAgaWYgKHNvdXJjZS5jb21wYXJlX2RhdHVtcyhkZXN0KSkge1xuICAgIHJldHVybiBwb2ludDsgLy8gaW4gdGhpcyBjYXNlLCB6ZXJvIGlzIHN1Y2VzcyxcbiAgICAvLyB3aGVyZWFzIGNzX2NvbXBhcmVfZGF0dW1zIHJldHVybnMgMSB0byBpbmRpY2F0ZSBUUlVFXG4gICAgLy8gY29uZnVzaW5nLCBzaG91bGQgZml4IHRoaXNcbiAgfVxuXG4gIC8vIEV4cGxpY2l0bHkgc2tpcCBkYXR1bSB0cmFuc2Zvcm0gYnkgc2V0dGluZyAnZGF0dW09bm9uZScgYXMgcGFyYW1ldGVyIGZvciBlaXRoZXIgc291cmNlIG9yIGRlc3RcbiAgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfTk9EQVRVTSB8fCBkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLy9ER1I6IDIwMTItMDctMjkgOiBhZGQgbmFkZ3JpZHMgc3VwcG9ydCAoYmVnaW4pXG4gIHZhciBzcmNfYSA9IHNvdXJjZS5hO1xuICB2YXIgc3JjX2VzID0gc291cmNlLmVzO1xuXG4gIHZhciBkc3RfYSA9IGRlc3QuYTtcbiAgdmFyIGRzdF9lcyA9IGRlc3QuZXM7XG5cbiAgdmFyIGZhbGxiYWNrID0gc291cmNlLmRhdHVtX3R5cGU7XG4gIC8vIElmIHRoaXMgZGF0dW0gcmVxdWlyZXMgZ3JpZCBzaGlmdHMsIHRoZW4gYXBwbHkgaXQgdG8gZ2VvZGV0aWMgY29vcmRpbmF0ZXMuXG4gIGlmIChmYWxsYmFjayA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgIGlmICh0aGlzLmFwcGx5X2dyaWRzaGlmdChzb3VyY2UsIDAsIHBvaW50KSA9PT0gMCkge1xuICAgICAgc291cmNlLmEgPSBTUlNfV0dTODRfU0VNSU1BSk9SO1xuICAgICAgc291cmNlLmVzID0gU1JTX1dHUzg0X0VTUVVBUkVEO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHRyeSAzIG9yIDcgcGFyYW1zIHRyYW5zZm9ybWF0aW9uIG9yIG5vdGhpbmcgP1xuICAgICAgaWYgKCFzb3VyY2UuZGF0dW1fcGFyYW1zKSB7XG4gICAgICAgIHNvdXJjZS5hID0gc3JjX2E7XG4gICAgICAgIHNvdXJjZS5lcyA9IHNvdXJjZS5lcztcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgd3AgPSAxO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHNvdXJjZS5kYXR1bV9wYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHdwICo9IHNvdXJjZS5kYXR1bV9wYXJhbXNbaV07XG4gICAgICB9XG4gICAgICBpZiAod3AgPT09IDApIHtcbiAgICAgICAgc291cmNlLmEgPSBzcmNfYTtcbiAgICAgICAgc291cmNlLmVzID0gc291cmNlLmVzO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmRhdHVtX3BhcmFtcy5sZW5ndGggPiAzKSB7XG4gICAgICAgIGZhbGxiYWNrID0gUEpEXzdQQVJBTTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWxsYmFjayA9IFBKRF8zUEFSQU07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICBkZXN0LmEgPSBTUlNfV0dTODRfU0VNSU1BSk9SO1xuICAgIGRlc3QuZXMgPSBTUlNfV0dTODRfRVNRVUFSRUQ7XG4gIH1cbiAgLy8gRG8gd2UgbmVlZCB0byBnbyB0aHJvdWdoIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXM/XG4gIGlmIChzb3VyY2UuZXMgIT09IGRlc3QuZXMgfHwgc291cmNlLmEgIT09IGRlc3QuYSB8fCBjaGVja1BhcmFtcyhmYWxsYmFjaykgfHwgY2hlY2tQYXJhbXMoZGVzdC5kYXR1bV90eXBlKSkge1xuICAgIC8vREdSOiAyMDEyLTA3LTI5IDogYWRkIG5hZGdyaWRzIHN1cHBvcnQgKGVuZClcbiAgICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG4gICAgc291cmNlLmdlb2RldGljX3RvX2dlb2NlbnRyaWMocG9pbnQpO1xuICAgIC8vIENIRUNLX1JFVFVSTjtcbiAgICAvLyBDb252ZXJ0IGJldHdlZW4gZGF0dW1zXG4gICAgaWYgKGNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSkge1xuICAgICAgc291cmNlLmdlb2NlbnRyaWNfdG9fd2dzODQocG9pbnQpO1xuICAgICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAoY2hlY2tQYXJhbXMoZGVzdC5kYXR1bV90eXBlKSkge1xuICAgICAgZGVzdC5nZW9jZW50cmljX2Zyb21fd2dzODQocG9pbnQpO1xuICAgICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gZ2VvZGV0aWMgY29vcmRpbmF0ZXNcbiAgICBkZXN0Lmdlb2NlbnRyaWNfdG9fZ2VvZGV0aWMocG9pbnQpO1xuICAgIC8vIENIRUNLX1JFVFVSTjtcbiAgfVxuICAvLyBBcHBseSBncmlkIHNoaWZ0IHRvIGRlc3RpbmF0aW9uIGlmIHJlcXVpcmVkXG4gIGlmIChkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICB0aGlzLmFwcGx5X2dyaWRzaGlmdChkZXN0LCAxLCBwb2ludCk7XG4gICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICB9XG5cbiAgc291cmNlLmEgPSBzcmNfYTtcbiAgc291cmNlLmVzID0gc3JjX2VzO1xuICBkZXN0LmEgPSBkc3RfYTtcbiAgZGVzdC5lcyA9IGRzdF9lcztcblxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG5cbn0se31dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnbG9iYWxzID0gX2RlcmVxXygnLi9nbG9iYWwnKTtcbnZhciBwYXJzZVByb2ogPSBfZGVyZXFfKCcuL3Byb2pTdHJpbmcnKTtcbnZhciB3a3QgPSBfZGVyZXFfKCcuL3drdCcpO1xuXG5mdW5jdGlvbiBkZWZzKG5hbWUpIHtcbiAgLypnbG9iYWwgY29uc29sZSovXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGVmID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGRlZi5jaGFyQXQoMCkgPT09ICcrJykge1xuICAgICAgICBkZWZzW25hbWVdID0gcGFyc2VQcm9qKGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVmc1tuYW1lXSA9IHdrdChhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZzW25hbWVdID0gZGVmO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgIHJldHVybiBuYW1lLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgZGVmcy5hcHBseSh0aGF0LCB2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZzKHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAobmFtZSBpbiBkZWZzKSB7XG4gICAgICAgIHJldHVybiBkZWZzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgnRVBTRycgaW4gbmFtZSkge1xuICAgICAgZGVmc1snRVBTRzonICsgbmFtZS5FUFNHXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdFU1JJJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydFU1JJOicgKyBuYW1lLkVTUkldID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ0lBVTIwMDAnIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0lBVTIwMDA6JyArIG5hbWUuSUFVMjAwMF0gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuXG59XG5nbG9iYWxzKGRlZnMpO1xubW9kdWxlLmV4cG9ydHMgPSBkZWZzO1xuXG59LHtcIi4vZ2xvYmFsXCI6MzUsXCIuL3Byb2pTdHJpbmdcIjozOCxcIi4vd2t0XCI6NjZ9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRGF0dW0gPSBfZGVyZXFfKCcuL2NvbnN0YW50cy9EYXR1bScpO1xudmFyIEVsbGlwc29pZCA9IF9kZXJlcV8oJy4vY29uc3RhbnRzL0VsbGlwc29pZCcpO1xudmFyIGV4dGVuZCA9IF9kZXJlcV8oJy4vZXh0ZW5kJyk7XG52YXIgZGF0dW0gPSBfZGVyZXFfKCcuL2RhdHVtJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuLy8gZWxsaXBvaWQgcGpfc2V0X2VsbC5jXG52YXIgU0lYVEggPSAwLjE2NjY2NjY2NjY2NjY2NjY2Njc7XG4vKiAxLzYgKi9cbnZhciBSQTQgPSAwLjA0NzIyMjIyMjIyMjIyMjIyMjIyO1xuLyogMTcvMzYwICovXG52YXIgUkE2ID0gMC4wMjIxNTYwODQ2NTYwODQ2NTYwODtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oanNvbikge1xuICAvLyBER1IgMjAxMS0wMy0yMCA6IG5hZ3JpZHMgLT4gbmFkZ3JpZHNcbiAgaWYgKGpzb24uZGF0dW1Db2RlICYmIGpzb24uZGF0dW1Db2RlICE9PSAnbm9uZScpIHtcbiAgICB2YXIgZGF0dW1EZWYgPSBEYXR1bVtqc29uLmRhdHVtQ29kZV07XG4gICAgaWYgKGRhdHVtRGVmKSB7XG4gICAgICBqc29uLmRhdHVtX3BhcmFtcyA9IGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsO1xuICAgICAganNvbi5lbGxwcyA9IGRhdHVtRGVmLmVsbGlwc2U7XG4gICAgICBqc29uLmRhdHVtTmFtZSA9IGRhdHVtRGVmLmRhdHVtTmFtZSA/IGRhdHVtRGVmLmRhdHVtTmFtZSA6IGpzb24uZGF0dW1Db2RlO1xuICAgIH1cbiAgfVxuICBpZiAoIWpzb24uYSkgeyAvLyBkbyB3ZSBoYXZlIGFuIGVsbGlwc29pZD9cbiAgICB2YXIgZWxsaXBzZSA9IEVsbGlwc29pZFtqc29uLmVsbHBzXSA/IEVsbGlwc29pZFtqc29uLmVsbHBzXSA6IEVsbGlwc29pZC5XR1M4NDtcbiAgICBleHRlbmQoanNvbiwgZWxsaXBzZSk7XG4gIH1cbiAgaWYgKGpzb24ucmYgJiYgIWpzb24uYikge1xuICAgIGpzb24uYiA9ICgxLjAgLSAxLjAgLyBqc29uLnJmKSAqIGpzb24uYTtcbiAgfVxuICBpZiAoanNvbi5yZiA9PT0gMCB8fCBNYXRoLmFicyhqc29uLmEgLSBqc29uLmIpIDwgRVBTTE4pIHtcbiAgICBqc29uLnNwaGVyZSA9IHRydWU7XG4gICAganNvbi5iID0ganNvbi5hO1xuICB9XG4gIGpzb24uYTIgPSBqc29uLmEgKiBqc29uLmE7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICBqc29uLmIyID0ganNvbi5iICoganNvbi5iOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAganNvbi5lcyA9IChqc29uLmEyIC0ganNvbi5iMikgLyBqc29uLmEyOyAvLyBlIF4gMlxuICBqc29uLmUgPSBNYXRoLnNxcnQoanNvbi5lcyk7IC8vIGVjY2VudHJpY2l0eVxuICBpZiAoanNvbi5SX0EpIHtcbiAgICBqc29uLmEgKj0gMSAtIGpzb24uZXMgKiAoU0lYVEggKyBqc29uLmVzICogKFJBNCArIGpzb24uZXMgKiBSQTYpKTtcbiAgICBqc29uLmEyID0ganNvbi5hICoganNvbi5hO1xuICAgIGpzb24uYjIgPSBqc29uLmIgKiBqc29uLmI7XG4gICAganNvbi5lcyA9IDA7XG4gIH1cbiAganNvbi5lcDIgPSAoanNvbi5hMiAtIGpzb24uYjIpIC8ganNvbi5iMjsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIGlmICghanNvbi5rMCkge1xuICAgIGpzb24uazAgPSAxLjA7IC8vZGVmYXVsdCB2YWx1ZVxuICB9XG4gIC8vREdSIDIwMTAtMTEtMTI6IGF4aXNcbiAgaWYgKCFqc29uLmF4aXMpIHtcbiAgICBqc29uLmF4aXMgPSBcImVudVwiO1xuICB9XG5cbiAgaWYgKCFqc29uLmRhdHVtKSB7XG4gICAganNvbi5kYXR1bSA9IGRhdHVtKGpzb24pO1xuICB9XG4gIHJldHVybiBqc29uO1xufTtcblxufSx7XCIuL2NvbnN0YW50cy9EYXR1bVwiOjI1LFwiLi9jb25zdGFudHMvRWxsaXBzb2lkXCI6MjYsXCIuL2RhdHVtXCI6MzAsXCIuL2V4dGVuZFwiOjM0fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XG4gIHZhciB2YWx1ZSwgcHJvcGVydHk7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG4gIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxufSx7fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZWZzKSB7XG4gIGRlZnMoJ0VQU0c6NDMyNicsIFwiK3RpdGxlPVdHUyA4NCAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzo0MjY5JywgXCIrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXNcIik7XG4gIGRlZnMoJ0VQU0c6Mzg1NycsIFwiK3RpdGxlPVdHUyA4NCAvIFBzZXVkby1NZXJjYXRvciArcHJvaj1tZXJjICthPTYzNzgxMzcgK2I9NjM3ODEzNyArbGF0X3RzPTAuMCArbG9uXzA9MC4wICt4XzA9MC4wICt5XzA9MCAraz0xLjAgK3VuaXRzPW0gK25hZGdyaWRzPUBudWxsICtub19kZWZzXCIpO1xuXG4gIGRlZnMuV0dTODQgPSBkZWZzWydFUFNHOjQzMjYnXTtcbiAgZGVmc1snRVBTRzozNzg1J10gPSBkZWZzWydFUFNHOjM4NTcnXTsgLy8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0LCBvZmZpY2lhbCBjb2RlIGlzIDM4NTdcbiAgZGVmcy5HT09HTEUgPSBkZWZzWydFUFNHOjM4NTcnXTtcbiAgZGVmc1snRVBTRzo5MDA5MTMnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjEwMjExMyddID0gZGVmc1snRVBTRzozODU3J107XG59O1xuXG59LHt9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcHJvajQgPSBfZGVyZXFfKCcuL2NvcmUnKTtcbnByb2o0LmRlZmF1bHREYXR1bSA9ICdXR1M4NCc7IC8vZGVmYXVsdCBkYXR1bVxucHJvajQuUHJvaiA9IF9kZXJlcV8oJy4vUHJvaicpO1xucHJvajQuV0dTODQgPSBuZXcgcHJvajQuUHJvaignV0dTODQnKTtcbnByb2o0LlBvaW50ID0gX2RlcmVxXygnLi9Qb2ludCcpO1xucHJvajQudG9Qb2ludCA9IF9kZXJlcV8oXCIuL2NvbW1vbi90b1BvaW50XCIpO1xucHJvajQuZGVmcyA9IF9kZXJlcV8oJy4vZGVmcycpO1xucHJvajQudHJhbnNmb3JtID0gX2RlcmVxXygnLi90cmFuc2Zvcm0nKTtcbnByb2o0Lm1ncnMgPSBfZGVyZXFfKCdtZ3JzJyk7XG5wcm9qNC52ZXJzaW9uID0gX2RlcmVxXygnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbl9kZXJlcV8oJy4vaW5jbHVkZWRQcm9qZWN0aW9ucycpKHByb2o0KTtcbm1vZHVsZS5leHBvcnRzID0gcHJvajQ7XG59LHtcIi4uL3BhY2thZ2UuanNvblwiOjY4LFwiLi9Qb2ludFwiOjEsXCIuL1Byb2pcIjoyLFwiLi9jb21tb24vdG9Qb2ludFwiOjIzLFwiLi9jb3JlXCI6MjksXCIuL2RlZnNcIjozMixcIi4vaW5jbHVkZWRQcm9qZWN0aW9uc1wiOlwiaFRFRHBuXCIsXCIuL3RyYW5zZm9ybVwiOjY1LFwibWdyc1wiOjY3fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGRlZnMgPSBfZGVyZXFfKCcuL2RlZnMnKTtcbnZhciB3a3QgPSBfZGVyZXFfKCcuL3drdCcpO1xudmFyIHByb2pTdHIgPSBfZGVyZXFfKCcuL3Byb2pTdHJpbmcnKTtcbmZ1bmN0aW9uIHRlc3RPYmooY29kZSl7XG4gIHJldHVybiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiB0ZXN0RGVmKGNvZGUpe1xuICByZXR1cm4gY29kZSBpbiBkZWZzO1xufVxuZnVuY3Rpb24gdGVzdFdLVChjb2RlKXtcbiAgdmFyIGNvZGVXb3JkcyA9IFsnR0VPR0NTJywnR0VPQ0NTJywnUFJPSkNTJywnTE9DQUxfQ1MnXTtcbiAgcmV0dXJuIGNvZGVXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYSsxK2NvZGUuaW5kZXhPZihiKTtcbiAgfSwwKTtcbn1cbmZ1bmN0aW9uIHRlc3RQcm9qKGNvZGUpe1xuICByZXR1cm4gY29kZVswXSA9PT0gJysnO1xufVxuZnVuY3Rpb24gcGFyc2UoY29kZSl7XG4gIGlmICh0ZXN0T2JqKGNvZGUpKSB7XG4gICAgLy9jaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIFdLVCBzdHJpbmdcbiAgICBpZiAodGVzdERlZihjb2RlKSkge1xuICAgICAgcmV0dXJuIGRlZnNbY29kZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlc3RXS1QoY29kZSkpIHtcbiAgICAgIHJldHVybiB3a3QoY29kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlc3RQcm9qKGNvZGUpKSB7XG4gICAgICByZXR1cm4gcHJvalN0cihjb2RlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHJldHVybiBjb2RlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG59LHtcIi4vZGVmc1wiOjMyLFwiLi9wcm9qU3RyaW5nXCI6MzgsXCIuL3drdFwiOjY2fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgUHJpbWVNZXJpZGlhbiA9IF9kZXJlcV8oJy4vY29uc3RhbnRzL1ByaW1lTWVyaWRpYW4nKTtcbnZhciB1bml0cyA9IF9kZXJlcV8oJy4vY29uc3RhbnRzL3VuaXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVmRGF0YSkge1xuICB2YXIgc2VsZiA9IHt9O1xuICB2YXIgcGFyYW1PYmogPSB7fTtcbiAgZGVmRGF0YS5zcGxpdChcIitcIikubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi50cmltKCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIHZhciBzcGxpdCA9IGEuc3BsaXQoXCI9XCIpO1xuICAgIHNwbGl0LnB1c2godHJ1ZSk7XG4gICAgcGFyYW1PYmpbc3BsaXRbMF0udG9Mb3dlckNhc2UoKV0gPSBzcGxpdFsxXTtcbiAgfSk7XG4gIHZhciBwYXJhbU5hbWUsIHBhcmFtVmFsLCBwYXJhbU91dG5hbWU7XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgcHJvajogJ3Byb2pOYW1lJyxcbiAgICBkYXR1bTogJ2RhdHVtQ29kZScsXG4gICAgcmY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYucmYgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgbGF0XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MCA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfMTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQxID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF8yOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDIgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0X3RzOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdF90cyA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMCA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMSA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMiA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBhbHBoYTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5hbHBoYSA9IHBhcnNlRmxvYXQodikgKiBEMlI7XG4gICAgfSxcbiAgICBsb25jOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmdjID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHhfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi54MCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICB5XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYueTAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAga18wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGs6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuazAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgYTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5hID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYiA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICByX2E6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5SX0EgPSB0cnVlO1xuICAgIH0sXG4gICAgem9uZTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi56b25lID0gcGFyc2VJbnQodiwgMTApO1xuICAgIH0sXG4gICAgc291dGg6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi51dG1Tb3V0aCA9IHRydWU7XG4gICAgfSxcbiAgICB0b3dnczg0OiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmRhdHVtX3BhcmFtcyA9IHYuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b19tZXRlcjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi50b19tZXRlciA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICB1bml0czogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi51bml0cyA9IHY7XG4gICAgICBpZiAodW5pdHNbdl0pIHtcbiAgICAgICAgc2VsZi50b19tZXRlciA9IHVuaXRzW3ZdLnRvX21ldGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnJvbV9ncmVlbndpY2g6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSB2ICogRDJSO1xuICAgIH0sXG4gICAgcG06IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSAoUHJpbWVNZXJpZGlhblt2XSA/IFByaW1lTWVyaWRpYW5bdl0gOiBwYXJzZUZsb2F0KHYpKSAqIEQyUjtcbiAgICB9LFxuICAgIG5hZGdyaWRzOiBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAodiA9PT0gJ0BudWxsJykge1xuICAgICAgICBzZWxmLmRhdHVtQ29kZSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLm5hZGdyaWRzID0gdjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF4aXM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBsZWdhbEF4aXMgPSBcImV3bnN1ZFwiO1xuICAgICAgaWYgKHYubGVuZ3RoID09PSAzICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDAsIDEpKSAhPT0gLTEgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMSwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigyLCAxKSkgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuYXhpcyA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmb3IgKHBhcmFtTmFtZSBpbiBwYXJhbU9iaikge1xuICAgIHBhcmFtVmFsID0gcGFyYW1PYmpbcGFyYW1OYW1lXTtcbiAgICBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1PdXRuYW1lID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICBpZiAodHlwZW9mIHBhcmFtT3V0bmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwYXJhbU91dG5hbWUocGFyYW1WYWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGZbcGFyYW1PdXRuYW1lXSA9IHBhcmFtVmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGZbcGFyYW1OYW1lXSA9IHBhcmFtVmFsO1xuICAgIH1cbiAgfVxuICBpZih0eXBlb2Ygc2VsZi5kYXR1bUNvZGUgPT09ICdzdHJpbmcnICYmIHNlbGYuZGF0dW1Db2RlICE9PSBcIldHUzg0XCIpe1xuICAgIHNlbGYuZGF0dW1Db2RlID0gc2VsZi5kYXR1bUNvZGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbn0se1wiLi9jb25zdGFudHMvUHJpbWVNZXJpZGlhblwiOjI3LFwiLi9jb25zdGFudHMvdW5pdHNcIjoyOH1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBwcm9qcyA9IFtcbiAgX2RlcmVxXygnLi9wcm9qZWN0aW9ucy9tZXJjJyksXG4gIF9kZXJlcV8oJy4vcHJvamVjdGlvbnMvbG9uZ2xhdCcpXG5dO1xudmFyIG5hbWVzID0ge307XG52YXIgcHJvalN0b3JlID0gW107XG5cbmZ1bmN0aW9uIGFkZChwcm9qLCBpKSB7XG4gIHZhciBsZW4gPSBwcm9qU3RvcmUubGVuZ3RoO1xuICBpZiAoIXByb2oubmFtZXMpIHtcbiAgICBjb25zb2xlLmxvZyhpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwcm9qU3RvcmVbbGVuXSA9IHByb2o7XG4gIHByb2oubmFtZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgbmFtZXNbbi50b0xvd2VyQ2FzZSgpXSA9IGxlbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnRzLmFkZCA9IGFkZDtcblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbiA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHR5cGVvZiBuYW1lc1tuXSAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvalN0b3JlW25hbWVzW25dXSkge1xuICAgIHJldHVybiBwcm9qU3RvcmVbbmFtZXNbbl1dO1xuICB9XG59O1xuZXhwb3J0cy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICBwcm9qcy5mb3JFYWNoKGFkZCk7XG59O1xuXG59LHtcIi4vcHJvamVjdGlvbnMvbG9uZ2xhdFwiOjUxLFwiLi9wcm9qZWN0aW9ucy9tZXJjXCI6NTJ9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIG1zZm56ID0gX2RlcmVxXygnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgcXNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vcXNmbnonKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhc2lueiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hc2lueicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcbiAgdGhpcy5lMyA9IE1hdGguc3FydCh0aGlzLmVzKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdGhpcy50MSA9IHRoaXMuc2luX3BvO1xuICB0aGlzLmNvbiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMxID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdGhpcy50MiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMyID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdGhpcy50MyA9IHRoaXMuc2luX3BvO1xuICB0aGlzLnFzMCA9IHFzZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMwID0gKHRoaXMubXMxICogdGhpcy5tczEgLSB0aGlzLm1zMiAqIHRoaXMubXMyKSAvICh0aGlzLnFzMiAtIHRoaXMucXMxKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zMCA9IHRoaXMuY29uO1xuICB9XG4gIHRoaXMuYyA9IHRoaXMubXMxICogdGhpcy5tczEgKyB0aGlzLm5zMCAqIHRoaXMucXMxO1xuICB0aGlzLnJoID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogdGhpcy5xczApIC8gdGhpcy5uczA7XG59O1xuXG4vKiBBbGJlcnMgQ29uaWNhbCBFcXVhbCBBcmVhIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHRoaXMuc2luX3BoaSA9IE1hdGguc2luKGxhdCk7XG4gIHRoaXMuY29zX3BoaSA9IE1hdGguY29zKGxhdCk7XG5cbiAgdmFyIHFzID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcGhpLCB0aGlzLmNvc19waGkpO1xuICB2YXIgcmgxID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogcXMpIC8gdGhpcy5uczA7XG4gIHZhciB0aGV0YSA9IHRoaXMubnMwICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHggPSByaDEgKiBNYXRoLnNpbih0aGV0YSkgKyB0aGlzLngwO1xuICB2YXIgeSA9IHRoaXMucmggLSByaDEgKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLnkwO1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciByaDEsIHFzLCBjb24sIHRoZXRhLCBsb24sIGxhdDtcblxuICBwLnggLT0gdGhpcy54MDtcbiAgcC55ID0gdGhpcy5yaCAtIHAueSArIHRoaXMueTA7XG4gIGlmICh0aGlzLm5zMCA+PSAwKSB7XG4gICAgcmgxID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gMTtcbiAgfVxuICBlbHNlIHtcbiAgICByaDEgPSAtTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gLTE7XG4gIH1cbiAgdGhldGEgPSAwO1xuICBpZiAocmgxICE9PSAwKSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKGNvbiAqIHAueCwgY29uICogcC55KTtcbiAgfVxuICBjb24gPSByaDEgKiB0aGlzLm5zMCAvIHRoaXMuYTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gTWF0aC5hc2luKCh0aGlzLmMgLSBjb24gKiBjb24pIC8gKDIgKiB0aGlzLm5zMCkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHFzID0gKHRoaXMuYyAtIGNvbiAqIGNvbikgLyB0aGlzLm5zMDtcbiAgICBsYXQgPSB0aGlzLnBoaTF6KHRoaXMuZTMsIHFzKTtcbiAgfVxuXG4gIGxvbiA9IGFkanVzdF9sb24odGhldGEgLyB0aGlzLm5zMCArIHRoaXMubG9uZzApO1xuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBGdW5jdGlvbiB0byBjb21wdXRlIHBoaTEsIHRoZSBsYXRpdHVkZSBmb3IgdGhlIGludmVyc2Ugb2YgdGhlXG4gICBBbGJlcnMgQ29uaWNhbCBFcXVhbC1BcmVhIHByb2plY3Rpb24uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMucGhpMXogPSBmdW5jdGlvbihlY2NlbnQsIHFzKSB7XG4gIHZhciBzaW5waGksIGNvc3BoaSwgY29uLCBjb20sIGRwaGk7XG4gIHZhciBwaGkgPSBhc2lueigwLjUgKiBxcyk7XG4gIGlmIChlY2NlbnQgPCBFUFNMTikge1xuICAgIHJldHVybiBwaGk7XG4gIH1cblxuICB2YXIgZWNjbnRzID0gZWNjZW50ICogZWNjZW50O1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSAyNTsgaSsrKSB7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgICBjb20gPSAxIC0gY29uICogY29uO1xuICAgIGRwaGkgPSAwLjUgKiBjb20gKiBjb20gLyBjb3NwaGkgKiAocXMgLyAoMSAtIGVjY250cykgLSBzaW5waGkgLyBjb20gKyAwLjUgLyBlY2NlbnQgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKTtcbiAgICBwaGkgPSBwaGkgKyBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAxZS03KSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiQWxiZXJzX0NvbmljX0VxdWFsX0FyZWFcIiwgXCJBbGJlcnNcIiwgXCJhZWFcIl07XG5cbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2FzaW56XCI6NixcIi4uL2NvbW1vbi9tc2ZuelwiOjE1LFwiLi4vY29tbW9uL3FzZm56XCI6MjB9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRqdXN0X2xvbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgbWxmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgZTBmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgZ04gPSBfZGVyZXFfKCcuLi9jb21tb24vZ04nKTtcbnZhciBhc2lueiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hc2lueicpO1xudmFyIGltbGZuID0gX2RlcmVxXygnLi4vY29tbW9uL2ltbGZuJyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaW5fcDEyID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcDEyID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbn07XG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG4gIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwLnkpO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBlMCwgZTEsIGUyLCBlMywgTWxwLCBNbCwgdGFucGhpLCBObDEsIE5sLCBwc2ksIEF6LCBHLCBILCBHSCwgSHMsIGMsIGtwLCBjb3NfYywgcywgczIsIHMzLCBzNCwgczU7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vZGVmYXVsdCBjYXNlXG4gICAgICBjb3NfYyA9IHRoaXMuc2luX3AxMiAqIHNpbnBoaSArIHRoaXMuY29zX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgYyA9IE1hdGguYWNvcyhjb3NfYyk7XG4gICAgICBrcCA9IGMgLyBNYXRoLnNpbihjKTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiBrcCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCArIHRoaXMuYSAqIGtwICogKHRoaXMuY29zX3AxMiAqIHNpbnBoaSAtIHRoaXMuc2luX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIFBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICBNbCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIGxhdCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgKE1scCAtIE1sKSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCAtIChNbHAgLSBNbCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuICAgICAgTWwgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBsYXQpO1xuICAgICAgcC54ID0gdGhpcy54MCArIChNbHAgKyBNbCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyAoTWxwICsgTWwpICogTWF0aC5jb3MoZGxvbik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL0RlZmF1bHQgY2FzZVxuICAgICAgdGFucGhpID0gc2lucGhpIC8gY29zcGhpO1xuICAgICAgTmwxID0gZ04odGhpcy5hLCB0aGlzLmUsIHRoaXMuc2luX3AxMik7XG4gICAgICBObCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBzaW5waGkpO1xuICAgICAgcHNpID0gTWF0aC5hdGFuKCgxIC0gdGhpcy5lcykgKiB0YW5waGkgKyB0aGlzLmVzICogTmwxICogdGhpcy5zaW5fcDEyIC8gKE5sICogY29zcGhpKSk7XG4gICAgICBBeiA9IE1hdGguYXRhbjIoTWF0aC5zaW4oZGxvbiksIHRoaXMuY29zX3AxMiAqIE1hdGgudGFuKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhkbG9uKSk7XG4gICAgICBpZiAoQXogPT09IDApIHtcbiAgICAgICAgcyA9IE1hdGguYXNpbih0aGlzLmNvc19wMTIgKiBNYXRoLnNpbihwc2kpIC0gdGhpcy5zaW5fcDEyICogTWF0aC5jb3MocHNpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChNYXRoLmFicyhNYXRoLmFicyhBeikgLSBNYXRoLlBJKSA8PSBFUFNMTikge1xuICAgICAgICBzID0gLU1hdGguYXNpbih0aGlzLmNvc19wMTIgKiBNYXRoLnNpbihwc2kpIC0gdGhpcy5zaW5fcDEyICogTWF0aC5jb3MocHNpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IE1hdGguYXNpbihNYXRoLnNpbihkbG9uKSAqIE1hdGguY29zKHBzaSkgLyBNYXRoLnNpbihBeikpO1xuICAgICAgfVxuICAgICAgRyA9IHRoaXMuZSAqIHRoaXMuc2luX3AxMiAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyk7XG4gICAgICBIID0gdGhpcy5lICogdGhpcy5jb3NfcDEyICogTWF0aC5jb3MoQXopIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKTtcbiAgICAgIEdIID0gRyAqIEg7XG4gICAgICBIcyA9IEggKiBIO1xuICAgICAgczIgPSBzICogcztcbiAgICAgIHMzID0gczIgKiBzO1xuICAgICAgczQgPSBzMyAqIHM7XG4gICAgICBzNSA9IHM0ICogcztcbiAgICAgIGMgPSBObDEgKiBzICogKDEgLSBzMiAqIEhzICogKDEgLSBIcykgLyA2ICsgczMgLyA4ICogR0ggKiAoMSAtIDIgKiBIcykgKyBzNCAvIDEyMCAqIChIcyAqICg0IC0gNyAqIEhzKSAtIDMgKiBHICogRyAqICgxIC0gNyAqIEhzKSkgLSBzNSAvIDQ4ICogR0gpO1xuICAgICAgcC54ID0gdGhpcy54MCArIGMgKiBNYXRoLnNpbihBeik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgYyAqIE1hdGguY29zKEF6KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG5cbn07XG5cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgcmgsIHosIHNpbnosIGNvc3osIGxvbiwgbGF0LCBjb24sIGUwLCBlMSwgZTIsIGUzLCBNbHAsIE0sIE4xLCBwc2ksIEF6LCBjb3NBeiwgdG1wLCBBLCBCLCBELCBFZSwgRjtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBpZiAocmggPiAoMiAqIEhBTEZfUEkgKiB0aGlzLmEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHogPSByaCAvIHRoaXMuYTtcblxuICAgIHNpbnogPSBNYXRoLnNpbih6KTtcbiAgICBjb3N6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcbiAgICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDEyICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTIpIC8gcmgpO1xuICAgICAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG4gICAgICBpZiAoTWF0aC5hYnMoY29uKSA8PSBFUFNMTikge1xuICAgICAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLypjb24gPSBjb3N6IC0gdGhpcy5zaW5fcDEyICogTWF0aC5zaW4obGF0KTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhjb24pIDwgRVBTTE4pICYmIChNYXRoLmFicyhwLngpIDwgRVBTTE4pKSB7XG4gICAgICAgICAgLy9uby1vcCwganVzdCBrZWVwIHRoZSBsb24gdmFsdWUgYXMgaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IE1hdGguYXRhbjIoKHAueCAqIHNpbnogKiB0aGlzLmNvc19wMTIpLCAoY29uICogcmgpKTtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSkpO1xuICAgICAgICB9Ki9cbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBzaW56LCByaCAqIHRoaXMuY29zX3AxMiAqIGNvc3ogLSBwLnkgKiB0aGlzLnNpbl9wMTIgKiBzaW56KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IE1scCAtIHJoO1xuICAgICAgbGF0ID0gaW1sZm4oTSAvIHRoaXMuYSwgZTAsIGUxLCBlMiwgZTMpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IHJoIC0gTWxwO1xuXG4gICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgcC55KSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2RlZmF1bHQgY2FzZVxuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG4gICAgICBOMSA9IGdOKHRoaXMuYSwgdGhpcy5lLCB0aGlzLnNpbl9wMTIpO1xuICAgICAgY29zQXogPSBNYXRoLmNvcyhBeik7XG4gICAgICB0bXAgPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBjb3NBejtcbiAgICAgIEEgPSAtdG1wICogdG1wIC8gKDEgLSB0aGlzLmVzKTtcbiAgICAgIEIgPSAzICogdGhpcy5lcyAqICgxIC0gQSkgKiB0aGlzLnNpbl9wMTIgKiB0aGlzLmNvc19wMTIgKiBjb3NBeiAvICgxIC0gdGhpcy5lcyk7XG4gICAgICBEID0gcmggLyBOMTtcbiAgICAgIEVlID0gRCAtIEEgKiAoMSArIEEpICogTWF0aC5wb3coRCwgMykgLyA2IC0gQiAqICgxICsgMyAqIEEpICogTWF0aC5wb3coRCwgNCkgLyAyNDtcbiAgICAgIEYgPSAxIC0gQSAqIEVlICogRWUgLyAyIC0gRCAqIEVlICogRWUgKiBFZSAvIDY7XG4gICAgICBwc2kgPSBNYXRoLmFzaW4odGhpcy5zaW5fcDEyICogTWF0aC5jb3MoRWUpICsgdGhpcy5jb3NfcDEyICogTWF0aC5zaW4oRWUpICogY29zQXopO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKE1hdGguc2luKEF6KSAqIE1hdGguc2luKEVlKSAvIE1hdGguY29zKHBzaSkpKTtcbiAgICAgIGxhdCA9IE1hdGguYXRhbigoMSAtIHRoaXMuZXMgKiBGICogdGhpcy5zaW5fcDEyIC8gTWF0aC5zaW4ocHNpKSkgKiBNYXRoLnRhbihwc2kpIC8gKDEgLSB0aGlzLmVzKSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH1cblxufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJBemltdXRoYWxfRXF1aWRpc3RhbnRcIiwgXCJhZXFkXCJdO1xuXG59LHtcIi4uL2NvbW1vbi9hZGp1c3RfbG9uXCI6NSxcIi4uL2NvbW1vbi9hc2luelwiOjYsXCIuLi9jb21tb24vZTBmblwiOjcsXCIuLi9jb21tb24vZTFmblwiOjgsXCIuLi9jb21tb24vZTJmblwiOjksXCIuLi9jb21tb24vZTNmblwiOjEwLFwiLi4vY29tbW9uL2dOXCI6MTEsXCIuLi9jb21tb24vaW1sZm5cIjoxMixcIi4uL2NvbW1vbi9tbGZuXCI6MTR9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbWxmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgZTBmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgZ04gPSBfZGVyZXFfKCcuLi9jb21tb24vZ04nKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhZGp1c3RfbGF0ID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sYXQnKTtcbnZhciBpbWxmbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9pbWxmbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zcGhlcmUpIHtcbiAgICB0aGlzLmUwID0gZTBmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUzID0gZTNmbih0aGlzLmVzKTtcbiAgICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgfVxufTtcblxuXG5cbi8qIENhc3NpbmkgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgeCwgeTtcbiAgdmFyIGxhbSA9IHAueDtcbiAgdmFyIHBoaSA9IHAueTtcbiAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB4ID0gdGhpcy5hICogTWF0aC5hc2luKE1hdGguY29zKHBoaSkgKiBNYXRoLnNpbihsYW0pKTtcbiAgICB5ID0gdGhpcy5hICogKE1hdGguYXRhbjIoTWF0aC50YW4ocGhpKSwgTWF0aC5jb3MobGFtKSkgLSB0aGlzLmxhdDApO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vZWxsaXBzb2lkXG4gICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgdmFyIGNvc3BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgdmFyIG5sID0gZ04odGhpcy5hLCB0aGlzLmUsIHNpbnBoaSk7XG4gICAgdmFyIHRsID0gTWF0aC50YW4ocGhpKSAqIE1hdGgudGFuKHBoaSk7XG4gICAgdmFyIGFsID0gbGFtICogTWF0aC5jb3MocGhpKTtcbiAgICB2YXIgYXNxID0gYWwgKiBhbDtcbiAgICB2YXIgY2wgPSB0aGlzLmVzICogY29zcGhpICogY29zcGhpIC8gKDEgLSB0aGlzLmVzKTtcbiAgICB2YXIgbWwgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHBoaSk7XG5cbiAgICB4ID0gbmwgKiBhbCAqICgxIC0gYXNxICogdGwgKiAoMSAvIDYgLSAoOCAtIHRsICsgOCAqIGNsKSAqIGFzcSAvIDEyMCkpO1xuICAgIHkgPSBtbCAtIHRoaXMubWwwICsgbmwgKiBzaW5waGkgLyBjb3NwaGkgKiBhc3EgKiAoMC41ICsgKDUgLSB0bCArIDYgKiBjbCkgKiBhc3EgLyAyNCk7XG5cblxuICB9XG5cbiAgcC54ID0geCArIHRoaXMueDA7XG4gIHAueSA9IHkgKyB0aGlzLnkwO1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBwaGksIGxhbTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgZGQgPSB5ICsgdGhpcy5sYXQwO1xuICAgIHBoaSA9IE1hdGguYXNpbihNYXRoLnNpbihkZCkgKiBNYXRoLmNvcyh4KSk7XG4gICAgbGFtID0gTWF0aC5hdGFuMihNYXRoLnRhbih4KSwgTWF0aC5jb3MoZGQpKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvKiBlbGxpcHNvaWQgKi9cbiAgICB2YXIgbWwxID0gdGhpcy5tbDAgLyB0aGlzLmEgKyB5O1xuICAgIHZhciBwaGkxID0gaW1sZm4obWwxLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocGhpMSkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICAgIHAueSA9IEhBTEZfUEk7XG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgcC55ICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBubDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4ocGhpMSkpO1xuXG4gICAgdmFyIHJsMSA9IG5sMSAqIG5sMSAqIG5sMSAvIHRoaXMuYSAvIHRoaXMuYSAqICgxIC0gdGhpcy5lcyk7XG4gICAgdmFyIHRsMSA9IE1hdGgucG93KE1hdGgudGFuKHBoaTEpLCAyKTtcbiAgICB2YXIgZGwgPSB4ICogdGhpcy5hIC8gbmwxO1xuICAgIHZhciBkc3EgPSBkbCAqIGRsO1xuICAgIHBoaSA9IHBoaTEgLSBubDEgKiBNYXRoLnRhbihwaGkxKSAvIHJsMSAqIGRsICogZGwgKiAoMC41IC0gKDEgKyAzICogdGwxKSAqIGRsICogZGwgLyAyNCk7XG4gICAgbGFtID0gZGwgKiAoMSAtIGRzcSAqICh0bDEgLyAzICsgKDEgKyAzICogdGwxKSAqIHRsMSAqIGRzcSAvIDE1KSkgLyBNYXRoLmNvcyhwaGkxKTtcblxuICB9XG5cbiAgcC54ID0gYWRqdXN0X2xvbihsYW0gKyB0aGlzLmxvbmcwKTtcbiAgcC55ID0gYWRqdXN0X2xhdChwaGkpO1xuICByZXR1cm4gcDtcblxufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJDYXNzaW5pXCIsIFwiQ2Fzc2luaV9Tb2xkbmVyXCIsIFwiY2Fzc1wiXTtcbn0se1wiLi4vY29tbW9uL2FkanVzdF9sYXRcIjo0LFwiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2UwZm5cIjo3LFwiLi4vY29tbW9uL2UxZm5cIjo4LFwiLi4vY29tbW9uL2UyZm5cIjo5LFwiLi4vY29tbW9uL2UzZm5cIjoxMCxcIi4uL2NvbW1vbi9nTlwiOjExLFwiLi4vY29tbW9uL2ltbGZuXCI6MTIsXCIuLi9jb21tb24vbWxmblwiOjE0fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIHFzZm56ID0gX2RlcmVxXygnLi4vY29tbW9uL3FzZm56Jyk7XG52YXIgbXNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBpcXNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vaXFzZm56Jyk7XG4vKlxuICByZWZlcmVuY2U6ICBcbiAgICBcIkNhcnRvZ3JhcGhpYyBQcm9qZWN0aW9uIFByb2NlZHVyZXMgZm9yIHRoZSBVTklYIEVudmlyb25tZW50LVxuICAgIEEgVXNlcidzIE1hbnVhbFwiIGJ5IEdlcmFsZCBJLiBFdmVuZGVuLFxuICAgIFVTR1MgT3BlbiBGaWxlIFJlcG9ydCA5MC0yODRhbmQgUmVsZWFzZSA0IEludGVyaW0gUmVwb3J0cyAoMjAwMylcbiovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy9uby1vcFxuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICB9XG59O1xuXG5cbi8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHgsIHk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiBkbG9uICogTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5zaW4obGF0KSAvIE1hdGguY29zKHRoaXMubGF0X3RzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcXMgPSBxc2Zueih0aGlzLmUsIE1hdGguc2luKGxhdCkpO1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGRsb247XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBxcyAqIDAuNSAvIHRoaXMuazA7XG4gIH1cblxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKHAueCAvIHRoaXMuYSkgLyBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICAgIGxhdCA9IE1hdGguYXNpbigocC55IC8gdGhpcy5hKSAqIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gaXFzZm56KHRoaXMuZSwgMiAqIHAueSAqIHRoaXMuazAgLyB0aGlzLmEpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHAueCAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcImNlYVwiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjUsXCIuLi9jb21tb24vaXFzZm56XCI6MTMsXCIuLi9jb21tb24vbXNmbnpcIjoxNSxcIi4uL2NvbW1vbi9xc2ZuelwiOjIwfV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFkanVzdF9sYXQgPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xhdCcpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy54MCA9IHRoaXMueDAgfHwgMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgdGhpcy5sYXQwID0gdGhpcy5sYXQwIHx8IDA7XG4gIHRoaXMubG9uZzAgPSB0aGlzLmxvbmcwIHx8IDA7XG4gIHRoaXMubGF0X3RzID0gdGhpcy5sYXRfdHMgfHwgMDtcbiAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGUgfHwgXCJFcXVpZGlzdGFudCBDeWxpbmRyaWNhbCAoUGxhdGUgQ2FycmUpXCI7XG5cbiAgdGhpcy5yYyA9IE1hdGguY29zKHRoaXMubGF0X3RzKTtcbn07XG5cblxuLy8gZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgZGxhdCA9IGFkanVzdF9sYXQobGF0IC0gdGhpcy5sYXQwKTtcbiAgcC54ID0gdGhpcy54MCArICh0aGlzLmEgKiBkbG9uICogdGhpcy5yYyk7XG4gIHAueSA9IHRoaXMueTAgKyAodGhpcy5hICogZGxhdCk7XG4gIHJldHVybiBwO1xufTtcblxuLy8gaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcblxuICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoKHggLSB0aGlzLngwKSAvICh0aGlzLmEgKiB0aGlzLnJjKSkpO1xuICBwLnkgPSBhZGp1c3RfbGF0KHRoaXMubGF0MCArICgoeSAtIHRoaXMueTApIC8gKHRoaXMuYSkpKTtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkVxdWlyZWN0YW5ndWxhclwiLCBcIkVxdWlkaXN0YW50X0N5bGluZHJpY2FsXCIsIFwiZXFjXCJdO1xuXG59LHtcIi4uL2NvbW1vbi9hZGp1c3RfbGF0XCI6NCxcIi4uL2NvbW1vbi9hZGp1c3RfbG9uXCI6NX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBlMGZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtc2ZueiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9tc2ZueicpO1xudmFyIG1sZm4gPSBfZGVyZXFfKCcuLi9jb21tb24vbWxmbicpO1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFkanVzdF9sYXQgPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xhdCcpO1xudmFyIGltbGZuID0gX2RlcmVxXygnLi4vY29tbW9uL2ltbGZuJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIFN0YW5kYXJkIFBhcmFsbGVscyBjYW5ub3QgYmUgZXF1YWwgYW5kIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBlcXVhdG9yXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXQyID0gdGhpcy5sYXQyIHx8IHRoaXMubGF0MTtcbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cbiAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuICB0aGlzLmNvc3BoaSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG5cbiAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG4gIHRoaXMubWwxID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDEpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm5zID0gdGhpcy5zaW5waGk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICAgIHRoaXMuY29zcGhpID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5waGksIHRoaXMuY29zcGhpKTtcbiAgICB0aGlzLm1sMiA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQyKTtcbiAgICB0aGlzLm5zID0gKHRoaXMubXMxIC0gdGhpcy5tczIpIC8gKHRoaXMubWwyIC0gdGhpcy5tbDEpO1xuICB9XG4gIHRoaXMuZyA9IHRoaXMubWwxICsgdGhpcy5tczEgLyB0aGlzLm5zO1xuICB0aGlzLm1sMCA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqICh0aGlzLmcgLSB0aGlzLm1sMCk7XG59O1xuXG5cbi8qIEVxdWlkaXN0YW50IENvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciByaDE7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmgxID0gdGhpcy5hICogKHRoaXMuZyAtIGxhdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG1sID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpO1xuICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBtbCk7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHJoMSAqIE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKTtcbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgdmFyIGNvbiwgcmgxLCBsYXQsIGxvbjtcbiAgaWYgKHRoaXMubnMgPj0gMCkge1xuICAgIHJoMSA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmgxID0gLU1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IC0xO1xuICB9XG4gIHZhciB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgdGhldGEgLyB0aGlzLm5zKTtcbiAgICBsYXQgPSBhZGp1c3RfbGF0KHRoaXMuZyAtIHJoMSAvIHRoaXMuYSk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgbWwgPSB0aGlzLmcgLSByaDEgLyB0aGlzLmE7XG4gICAgbGF0ID0gaW1sZm4obWwsIHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHRoZXRhIC8gdGhpcy5ucyk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkVxdWlkaXN0YW50X0NvbmljXCIsIFwiZXFkY1wiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xhdFwiOjQsXCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjUsXCIuLi9jb21tb24vZTBmblwiOjcsXCIuLi9jb21tb24vZTFmblwiOjgsXCIuLi9jb21tb24vZTJmblwiOjksXCIuLi9jb21tb24vZTNmblwiOjEwLFwiLi4vY29tbW9uL2ltbGZuXCI6MTIsXCIuLi9jb21tb24vbWxmblwiOjE0LFwiLi4vY29tbW9uL21zZm56XCI6MTV9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIHNyYXQgPSBfZGVyZXFfKCcuLi9jb21tb24vc3JhdCcpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgTUFYX0lURVIgPSAyMDtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3BoaSA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHZhciBjcGhpID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgY3BoaSAqPSBjcGhpO1xuICB0aGlzLnJjID0gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSAvICgxIC0gdGhpcy5lcyAqIHNwaGkgKiBzcGhpKTtcbiAgdGhpcy5DID0gTWF0aC5zcXJ0KDEgKyB0aGlzLmVzICogY3BoaSAqIGNwaGkgLyAoMSAtIHRoaXMuZXMpKTtcbiAgdGhpcy5waGljMCA9IE1hdGguYXNpbihzcGhpIC8gdGhpcy5DKTtcbiAgdGhpcy5yYXRleHAgPSAwLjUgKiB0aGlzLkMgKiB0aGlzLmU7XG4gIHRoaXMuSyA9IE1hdGgudGFuKDAuNSAqIHRoaXMucGhpYzAgKyBGT1JUUEkpIC8gKE1hdGgucG93KE1hdGgudGFuKDAuNSAqIHRoaXMubGF0MCArIEZPUlRQSSksIHRoaXMuQykgKiBzcmF0KHRoaXMuZSAqIHNwaGksIHRoaXMucmF0ZXhwKSk7XG59O1xuXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgcC55ID0gMiAqIE1hdGguYXRhbih0aGlzLksgKiBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBNYXRoLnNpbihsYXQpLCB0aGlzLnJhdGV4cCkpIC0gSEFMRl9QSTtcbiAgcC54ID0gdGhpcy5DICogbG9uO1xuICByZXR1cm4gcDtcbn07XG5cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIERFTF9UT0wgPSAxZS0xNDtcbiAgdmFyIGxvbiA9IHAueCAvIHRoaXMuQztcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIG51bSA9IE1hdGgucG93KE1hdGgudGFuKDAuNSAqIGxhdCArIEZPUlRQSSkgLyB0aGlzLkssIDEgLyB0aGlzLkMpO1xuICBmb3IgKHZhciBpID0gTUFYX0lURVI7IGkgPiAwOyAtLWkpIHtcbiAgICBsYXQgPSAyICogTWF0aC5hdGFuKG51bSAqIHNyYXQodGhpcy5lICogTWF0aC5zaW4ocC55KSwgLSAwLjUgKiB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgaWYgKE1hdGguYWJzKGxhdCAtIHAueSkgPCBERUxfVE9MKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcC55ID0gbGF0O1xuICB9XG4gIC8qIGNvbnZlcmdlbmNlIGZhaWxlZCAqL1xuICBpZiAoIWkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcImdhdXNzXCJdO1xuXG59LHtcIi4uL2NvbW1vbi9zcmF0XCI6MjJ9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRqdXN0X2xvbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGFzaW56ID0gX2RlcmVxXygnLi4vY29tbW9uL2FzaW56Jyk7XG5cbi8qXG4gIHJlZmVyZW5jZTpcbiAgICBXb2xmcmFtIE1hdGh3b3JsZCBcIkdub21vbmljIFByb2plY3Rpb25cIlxuICAgIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vR25vbW9uaWNQcm9qZWN0aW9uLmh0bWxcbiAgICBBY2Nlc3NlZDogMTJ0aCBOb3ZlbWJlciAyMDA5XG4gICovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdGhpcy5zaW5fcDE0ID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcDE0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgLy8gQXBwcm94aW1hdGlvbiBmb3IgcHJvamVjdGluZyBwb2ludHMgdG8gdGhlIGhvcml6b24gKGluZmluaXR5KVxuICB0aGlzLmluZmluaXR5X2Rpc3QgPSAxMDAwICogdGhpcy5hO1xuICB0aGlzLnJjID0gMTtcbn07XG5cblxuLyogR25vbW9uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIHNpbnBoaSwgY29zcGhpOyAvKiBzaW4gYW5kIGNvcyB2YWx1ZSAgICAgICAgKi9cbiAgdmFyIGRsb247IC8qIGRlbHRhIGxvbmdpdHVkZSB2YWx1ZSAgICAgICovXG4gIHZhciBjb3Nsb247IC8qIGNvcyBvZiBsb25naXR1ZGUgICAgICAgICovXG4gIHZhciBrc3A7IC8qIHNjYWxlIGZhY3RvciAgICAgICAgICAqL1xuICB2YXIgZztcbiAgdmFyIHgsIHk7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXG4gIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gIGNvc3BoaSA9IE1hdGguY29zKGxhdCk7XG5cbiAgY29zbG9uID0gTWF0aC5jb3MoZGxvbik7XG4gIGcgPSB0aGlzLnNpbl9wMTQgKiBzaW5waGkgKyB0aGlzLmNvc19wMTQgKiBjb3NwaGkgKiBjb3Nsb247XG4gIGtzcCA9IDE7XG4gIGlmICgoZyA+IDApIHx8IChNYXRoLmFicyhnKSA8PSBFUFNMTikpIHtcbiAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGtzcCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pIC8gZztcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuYSAqIGtzcCAqICh0aGlzLmNvc19wMTQgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTQgKiBjb3NwaGkgKiBjb3Nsb24pIC8gZztcbiAgfVxuICBlbHNlIHtcblxuICAgIC8vIFBvaW50IGlzIGluIHRoZSBvcHBvc2luZyBoZW1pc3BoZXJlIGFuZCBpcyB1bnByb2plY3RhYmxlXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byByZXR1cm4gYSByZWFzb25hYmxlIHBvaW50LCBzbyB3ZSBwcm9qZWN0IFxuICAgIC8vIHRvIGluZmluaXR5LCBvbiBhIGJlYXJpbmcgXG4gICAgLy8gZXF1aXZhbGVudCB0byB0aGUgbm9ydGhlcm4gaGVtaXNwaGVyZSBlcXVpdmFsZW50XG4gICAgLy8gVGhpcyBpcyBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvbiBmb3Igc2hvcnQgc2hhcGVzIGFuZCBsaW5lcyB0aGF0IFxuICAgIC8vIHN0cmFkZGxlIHRoZSBob3Jpem9uLlxuXG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmluZmluaXR5X2Rpc3QgKiBjb3NwaGkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuaW5maW5pdHlfZGlzdCAqICh0aGlzLmNvc19wMTQgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTQgKiBjb3NwaGkgKiBjb3Nsb24pO1xuXG4gIH1cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG5cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIHJoOyAvKiBSaG8gKi9cbiAgdmFyIHNpbmMsIGNvc2M7XG4gIHZhciBjO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgcC54IC89IHRoaXMuazA7XG4gIHAueSAvPSB0aGlzLmswO1xuXG4gIGlmICgocmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSkpIHtcbiAgICBjID0gTWF0aC5hdGFuMihyaCwgdGhpcy5yYyk7XG4gICAgc2luYyA9IE1hdGguc2luKGMpO1xuICAgIGNvc2MgPSBNYXRoLmNvcyhjKTtcblxuICAgIGxhdCA9IGFzaW56KGNvc2MgKiB0aGlzLnNpbl9wMTQgKyAocC55ICogc2luYyAqIHRoaXMuY29zX3AxNCkgLyByaCk7XG4gICAgbG9uID0gTWF0aC5hdGFuMihwLnggKiBzaW5jLCByaCAqIHRoaXMuY29zX3AxNCAqIGNvc2MgLSBwLnkgKiB0aGlzLnNpbl9wMTQgKiBzaW5jKTtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBsb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHRoaXMucGhpYzA7XG4gICAgbG9uID0gMDtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiZ25vbVwiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjUsXCIuLi9jb21tb24vYXNpbnpcIjo2fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYSA9IDYzNzczOTcuMTU1O1xuICB0aGlzLmVzID0gMC4wMDY2NzQzNzIyMzA2MTQ7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKCF0aGlzLmxhdDApIHtcbiAgICB0aGlzLmxhdDAgPSAwLjg2MzkzNzk3OTczNzE5MztcbiAgfVxuICBpZiAoIXRoaXMubG9uZzApIHtcbiAgICB0aGlzLmxvbmcwID0gMC43NDE3NjQ5MzIwOTc1OTAxIC0gMC4zMDgzNDE1MDExODU2NjU7XG4gIH1cbiAgLyogaWYgc2NhbGUgbm90IHNldCBkZWZhdWx0IHRvIDAuOTk5OSAqL1xuICBpZiAoIXRoaXMuazApIHtcbiAgICB0aGlzLmswID0gMC45OTk5O1xuICB9XG4gIHRoaXMuczQ1ID0gMC43ODUzOTgxNjMzOTc0NDg7IC8qIDQ1ICovXG4gIHRoaXMuczkwID0gMiAqIHRoaXMuczQ1O1xuICB0aGlzLmZpMCA9IHRoaXMubGF0MDtcbiAgdGhpcy5lMiA9IHRoaXMuZXM7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmUyKTtcbiAgdGhpcy5hbGZhID0gTWF0aC5zcXJ0KDEgKyAodGhpcy5lMiAqIE1hdGgucG93KE1hdGguY29zKHRoaXMuZmkwKSwgNCkpIC8gKDEgLSB0aGlzLmUyKSk7XG4gIHRoaXMudXEgPSAxLjA0MjE2ODU2MzgwNDc0O1xuICB0aGlzLnUwID0gTWF0aC5hc2luKE1hdGguc2luKHRoaXMuZmkwKSAvIHRoaXMuYWxmYSk7XG4gIHRoaXMuZyA9IE1hdGgucG93KCgxICsgdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSwgdGhpcy5hbGZhICogdGhpcy5lIC8gMik7XG4gIHRoaXMuayA9IE1hdGgudGFuKHRoaXMudTAgLyAyICsgdGhpcy5zNDUpIC8gTWF0aC5wb3coTWF0aC50YW4odGhpcy5maTAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpICogdGhpcy5nO1xuICB0aGlzLmsxID0gdGhpcy5rMDtcbiAgdGhpcy5uMCA9IHRoaXMuYSAqIE1hdGguc3FydCgxIC0gdGhpcy5lMikgLyAoMSAtIHRoaXMuZTIgKiBNYXRoLnBvdyhNYXRoLnNpbih0aGlzLmZpMCksIDIpKTtcbiAgdGhpcy5zMCA9IDEuMzcwMDgzNDYyODE1NTU7XG4gIHRoaXMubiA9IE1hdGguc2luKHRoaXMuczApO1xuICB0aGlzLnJvMCA9IHRoaXMuazEgKiB0aGlzLm4wIC8gTWF0aC50YW4odGhpcy5zMCk7XG4gIHRoaXMuYWQgPSB0aGlzLnM5MCAtIHRoaXMudXE7XG59O1xuXG4vKiBlbGxpcHNvaWQgKi9cbi8qIGNhbGN1bGF0ZSB4eSBmcm9tIGxhdC9sb24gKi9cbi8qIENvbnN0YW50cywgaWRlbnRpY2FsIHRvIGludmVyc2UgdHJhbnNmb3JtIGZ1bmN0aW9uICovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBnZmksIHUsIGRlbHRhdiwgcywgZCwgZXBzLCBybztcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIC8qIFRyYW5zZm9ybWF0aW9uICovXG4gIGdmaSA9IE1hdGgucG93KCgoMSArIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihsYXQpKSksICh0aGlzLmFsZmEgKiB0aGlzLmUgLyAyKSk7XG4gIHUgPSAyICogKE1hdGguYXRhbih0aGlzLmsgKiBNYXRoLnBvdyhNYXRoLnRhbihsYXQgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpIC8gZ2ZpKSAtIHRoaXMuczQ1KTtcbiAgZGVsdGF2ID0gLWRlbHRhX2xvbiAqIHRoaXMuYWxmYTtcbiAgcyA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmFkKSAqIE1hdGguc2luKHUpICsgTWF0aC5zaW4odGhpcy5hZCkgKiBNYXRoLmNvcyh1KSAqIE1hdGguY29zKGRlbHRhdikpO1xuICBkID0gTWF0aC5hc2luKE1hdGguY29zKHUpICogTWF0aC5zaW4oZGVsdGF2KSAvIE1hdGguY29zKHMpKTtcbiAgZXBzID0gdGhpcy5uICogZDtcbiAgcm8gPSB0aGlzLnJvMCAqIE1hdGgucG93KE1hdGgudGFuKHRoaXMuczAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLm4pIC8gTWF0aC5wb3coTWF0aC50YW4ocyAvIDIgKyB0aGlzLnM0NSksIHRoaXMubik7XG4gIHAueSA9IHJvICogTWF0aC5jb3MoZXBzKSAvIDE7XG4gIHAueCA9IHJvICogTWF0aC5zaW4oZXBzKSAvIDE7XG5cbiAgaWYgKCF0aGlzLmN6ZWNoKSB7XG4gICAgcC55ICo9IC0xO1xuICAgIHAueCAqPSAtMTtcbiAgfVxuICByZXR1cm4gKHApO1xufTtcblxuLyogY2FsY3VsYXRlIGxhdC9sb24gZnJvbSB4eSAqL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdSwgZGVsdGF2LCBzLCBkLCBlcHMsIHJvLCBmaTE7XG4gIHZhciBvaztcblxuICAvKiBUcmFuc2Zvcm1hdGlvbiAqL1xuICAvKiByZXZlcnQgeSwgeCovXG4gIHZhciB0bXAgPSBwLng7XG4gIHAueCA9IHAueTtcbiAgcC55ID0gdG1wO1xuICBpZiAoIXRoaXMuY3plY2gpIHtcbiAgICBwLnkgKj0gLTE7XG4gICAgcC54ICo9IC0xO1xuICB9XG4gIHJvID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gIGVwcyA9IE1hdGguYXRhbjIocC55LCBwLngpO1xuICBkID0gZXBzIC8gTWF0aC5zaW4odGhpcy5zMCk7XG4gIHMgPSAyICogKE1hdGguYXRhbihNYXRoLnBvdyh0aGlzLnJvMCAvIHJvLCAxIC8gdGhpcy5uKSAqIE1hdGgudGFuKHRoaXMuczAgLyAyICsgdGhpcy5zNDUpKSAtIHRoaXMuczQ1KTtcbiAgdSA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmFkKSAqIE1hdGguc2luKHMpIC0gTWF0aC5zaW4odGhpcy5hZCkgKiBNYXRoLmNvcyhzKSAqIE1hdGguY29zKGQpKTtcbiAgZGVsdGF2ID0gTWF0aC5hc2luKE1hdGguY29zKHMpICogTWF0aC5zaW4oZCkgLyBNYXRoLmNvcyh1KSk7XG4gIHAueCA9IHRoaXMubG9uZzAgLSBkZWx0YXYgLyB0aGlzLmFsZmE7XG4gIGZpMSA9IHU7XG4gIG9rID0gMDtcbiAgdmFyIGl0ZXIgPSAwO1xuICBkbyB7XG4gICAgcC55ID0gMiAqIChNYXRoLmF0YW4oTWF0aC5wb3codGhpcy5rLCAtIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coTWF0aC50YW4odSAvIDIgKyB0aGlzLnM0NSksIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihmaTEpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4oZmkxKSksIHRoaXMuZSAvIDIpKSAtIHRoaXMuczQ1KTtcbiAgICBpZiAoTWF0aC5hYnMoZmkxIC0gcC55KSA8IDAuMDAwMDAwMDAwMSkge1xuICAgICAgb2sgPSAxO1xuICAgIH1cbiAgICBmaTEgPSBwLnk7XG4gICAgaXRlciArPSAxO1xuICB9IHdoaWxlIChvayA9PT0gMCAmJiBpdGVyIDwgMTUpO1xuICBpZiAoaXRlciA+PSAxNSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChwKTtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiS3JvdmFrXCIsIFwia3JvdmFrXCJdO1xuXG59LHtcIi4uL2NvbW1vbi9hZGp1c3RfbG9uXCI6NX1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEZPUlRQSSA9IE1hdGguUEkvNDtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgcXNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vcXNmbnonKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbi8qXG4gIHJlZmVyZW5jZVxuICAgIFwiTmV3IEVxdWFsLUFyZWEgTWFwIFByb2plY3Rpb25zIGZvciBOb25jaXJjdWxhciBSZWdpb25zXCIsIEpvaG4gUC4gU255ZGVyLFxuICAgIFRoZSBBbWVyaWNhbiBDYXJ0b2dyYXBoZXIsIFZvbCAxNSwgTm8uIDQsIE9jdG9iZXIgMTk4OCwgcHAuIDM0MS0zNTUuXG4gICovXG5cbmV4cG9ydHMuU19QT0xFID0gMTtcbmV4cG9ydHMuTl9QT0xFID0gMjtcbmV4cG9ydHMuRVFVSVQgPSAzO1xuZXhwb3J0cy5PQkxJUSA9IDQ7XG5cblxuLyogSW5pdGlhbGl6ZSB0aGUgTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSBNYXRoLmFicyh0aGlzLmxhdDApO1xuICBpZiAoTWF0aC5hYnModCAtIEhBTEZfUEkpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLmxhdDAgPCAwID8gdGhpcy5TX1BPTEUgOiB0aGlzLk5fUE9MRTtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5FUVVJVDtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLk9CTElRO1xuICB9XG4gIGlmICh0aGlzLmVzID4gMCkge1xuICAgIHZhciBzaW5waGk7XG5cbiAgICB0aGlzLnFwID0gcXNmbnoodGhpcy5lLCAxKTtcbiAgICB0aGlzLm1tZiA9IDAuNSAvICgxIC0gdGhpcy5lcyk7XG4gICAgdGhpcy5hcGEgPSB0aGlzLmF1dGhzZXQodGhpcy5lcyk7XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgICAgdGhpcy5kZCA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuU19QT0xFOlxuICAgICAgdGhpcy5kZCA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuRVFVSVQ6XG4gICAgICB0aGlzLnJxID0gTWF0aC5zcXJ0KDAuNSAqIHRoaXMucXApO1xuICAgICAgdGhpcy5kZCA9IDEgLyB0aGlzLnJxO1xuICAgICAgdGhpcy54bWYgPSAxO1xuICAgICAgdGhpcy55bWYgPSAwLjUgKiB0aGlzLnFwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgICAgdGhpcy5ycSA9IE1hdGguc3FydCgwLjUgKiB0aGlzLnFwKTtcbiAgICAgIHNpbnBoaSA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gICAgICB0aGlzLnNpbmIxID0gcXNmbnoodGhpcy5lLCBzaW5waGkpIC8gdGhpcy5xcDtcbiAgICAgIHRoaXMuY29zYjEgPSBNYXRoLnNxcnQoMSAtIHRoaXMuc2luYjEgKiB0aGlzLnNpbmIxKTtcbiAgICAgIHRoaXMuZGQgPSBNYXRoLmNvcyh0aGlzLmxhdDApIC8gKE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHNpbnBoaSAqIHNpbnBoaSkgKiB0aGlzLnJxICogdGhpcy5jb3NiMSk7XG4gICAgICB0aGlzLnltZiA9ICh0aGlzLnhtZiA9IHRoaXMucnEpIC8gdGhpcy5kZDtcbiAgICAgIHRoaXMueG1mICo9IHRoaXMuZGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkge1xuICAgICAgdGhpcy5zaW5waDAgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgICAgdGhpcy5jb3NwaDAgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuICAgIH1cbiAgfVxufTtcblxuLyogTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciB4LCB5LCBjb3NsYW0sIHNpbmxhbSwgc2lucGhpLCBxLCBzaW5iLCBjb3NiLCBiLCBjb3NwaGk7XG4gIHZhciBsYW0gPSBwLng7XG4gIHZhciBwaGkgPSBwLnk7XG5cbiAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc3BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29zbGFtID0gTWF0aC5jb3MobGFtKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuICAgICAgeSA9ICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpID8gMSArIGNvc3BoaSAqIGNvc2xhbSA6IDEgKyB0aGlzLnNpbnBoMCAqIHNpbnBoaSArIHRoaXMuY29zcGgwICogY29zcGhpICogY29zbGFtO1xuICAgICAgaWYgKHkgPD0gRVBTTE4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB5ID0gTWF0aC5zcXJ0KDIgLyB5KTtcbiAgICAgIHggPSB5ICogY29zcGhpICogTWF0aC5zaW4obGFtKTtcbiAgICAgIHkgKj0gKHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkgPyBzaW5waGkgOiB0aGlzLmNvc3BoMCAqIHNpbnBoaSAtIHRoaXMuc2lucGgwICogY29zcGhpICogY29zbGFtO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuTl9QT0xFIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuTl9QT0xFKSB7XG4gICAgICAgIGNvc2xhbSA9IC1jb3NsYW07XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMocGhpICsgdGhpcy5waGkwKSA8IEVQU0xOKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgeSA9IEZPUlRQSSAtIHBoaSAqIDAuNTtcbiAgICAgIHkgPSAyICogKCh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSA/IE1hdGguY29zKHkpIDogTWF0aC5zaW4oeSkpO1xuICAgICAgeCA9IHkgKiBNYXRoLnNpbihsYW0pO1xuICAgICAgeSAqPSBjb3NsYW07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHNpbmIgPSAwO1xuICAgIGNvc2IgPSAwO1xuICAgIGIgPSAwO1xuICAgIGNvc2xhbSA9IE1hdGguY29zKGxhbSk7XG4gICAgc2lubGFtID0gTWF0aC5zaW4obGFtKTtcbiAgICBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIHEgPSBxc2Zueih0aGlzLmUsIHNpbnBoaSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHNpbmIgPSBxIC8gdGhpcy5xcDtcbiAgICAgIGNvc2IgPSBNYXRoLnNxcnQoMSAtIHNpbmIgKiBzaW5iKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgICBiID0gMSArIHRoaXMuc2luYjEgKiBzaW5iICsgdGhpcy5jb3NiMSAqIGNvc2IgKiBjb3NsYW07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuRVFVSVQ6XG4gICAgICBiID0gMSArIGNvc2IgKiBjb3NsYW07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgICAgYiA9IEhBTEZfUEkgKyBwaGk7XG4gICAgICBxID0gdGhpcy5xcCAtIHE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuU19QT0xFOlxuICAgICAgYiA9IHBoaSAtIEhBTEZfUEk7XG4gICAgICBxID0gdGhpcy5xcCArIHE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGIpIDwgRVBTTE4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICBjYXNlIHRoaXMuRVFVSVQ6XG4gICAgICBiID0gTWF0aC5zcXJ0KDIgLyBiKTtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcbiAgICAgICAgeSA9IHRoaXMueW1mICogYiAqICh0aGlzLmNvc2IxICogc2luYiAtIHRoaXMuc2luYjEgKiBjb3NiICogY29zbGFtKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB5ID0gKGIgPSBNYXRoLnNxcnQoMiAvICgxICsgY29zYiAqIGNvc2xhbSkpKSAqIHNpbmIgKiB0aGlzLnltZjtcbiAgICAgIH1cbiAgICAgIHggPSB0aGlzLnhtZiAqIGIgKiBjb3NiICogc2lubGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICBjYXNlIHRoaXMuU19QT0xFOlxuICAgICAgaWYgKHEgPj0gMCkge1xuICAgICAgICB4ID0gKGIgPSBNYXRoLnNxcnQocSkpICogc2lubGFtO1xuICAgICAgICB5ID0gY29zbGFtICogKCh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSA/IGIgOiAtYik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeCA9IHkgPSAwO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcC54ID0gdGhpcy5hICogeCArIHRoaXMueDA7XG4gIHAueSA9IHRoaXMuYSAqIHkgKyB0aGlzLnkwO1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBsYW0sIHBoaSwgY0NlLCBzQ2UsIHEsIHJobywgYWI7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGNvc3ogPSAwLFxuICAgICAgcmgsIHNpbnogPSAwO1xuXG4gICAgcmggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgcGhpID0gcmggKiAwLjU7XG4gICAgaWYgKHBoaSA+IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwaGkgPSAyICogTWF0aC5hc2luKHBoaSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHNpbnogPSBNYXRoLnNpbihwaGkpO1xuICAgICAgY29zeiA9IE1hdGguY29zKHBoaSk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgcGhpID0gKE1hdGguYWJzKHJoKSA8PSBFUFNMTikgPyAwIDogTWF0aC5hc2luKHkgKiBzaW56IC8gcmgpO1xuICAgICAgeCAqPSBzaW56O1xuICAgICAgeSA9IGNvc3ogKiByaDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICAgIHBoaSA9IChNYXRoLmFicyhyaCkgPD0gRVBTTE4pID8gdGhpcy5waGkwIDogTWF0aC5hc2luKGNvc3ogKiB0aGlzLnNpbnBoMCArIHkgKiBzaW56ICogdGhpcy5jb3NwaDAgLyByaCk7XG4gICAgICB4ICo9IHNpbnogKiB0aGlzLmNvc3BoMDtcbiAgICAgIHkgPSAoY29zeiAtIE1hdGguc2luKHBoaSkgKiB0aGlzLnNpbnBoMCkgKiByaDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgICB5ID0gLXk7XG4gICAgICBwaGkgPSBIQUxGX1BJIC0gcGhpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIHBoaSAtPSBIQUxGX1BJO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhbSA9ICh5ID09PSAwICYmICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQgfHwgdGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSkgPyAwIDogTWF0aC5hdGFuMih4LCB5KTtcbiAgfVxuICBlbHNlIHtcbiAgICBhYiA9IDA7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHggLz0gdGhpcy5kZDtcbiAgICAgIHkgKj0gdGhpcy5kZDtcbiAgICAgIHJobyA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgIGlmIChyaG8gPCBFUFNMTikge1xuICAgICAgICBwLnggPSAwO1xuICAgICAgICBwLnkgPSB0aGlzLnBoaTA7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgICAgc0NlID0gMiAqIE1hdGguYXNpbigwLjUgKiByaG8gLyB0aGlzLnJxKTtcbiAgICAgIGNDZSA9IE1hdGguY29zKHNDZSk7XG4gICAgICB4ICo9IChzQ2UgPSBNYXRoLnNpbihzQ2UpKTtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcbiAgICAgICAgYWIgPSBjQ2UgKiB0aGlzLnNpbmIxICsgeSAqIHNDZSAqIHRoaXMuY29zYjEgLyByaG87XG4gICAgICAgIHEgPSB0aGlzLnFwICogYWI7XG4gICAgICAgIHkgPSByaG8gKiB0aGlzLmNvc2IxICogY0NlIC0geSAqIHRoaXMuc2luYjEgKiBzQ2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWIgPSB5ICogc0NlIC8gcmhvO1xuICAgICAgICBxID0gdGhpcy5xcCAqIGFiO1xuICAgICAgICB5ID0gcmhvICogY0NlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuTl9QT0xFIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuTl9QT0xFKSB7XG4gICAgICAgIHkgPSAteTtcbiAgICAgIH1cbiAgICAgIHEgPSAoeCAqIHggKyB5ICogeSk7XG4gICAgICBpZiAoIXEpIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgICAgcC55ID0gdGhpcy5waGkwO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIGFiID0gMSAtIHEgLyB0aGlzLnFwO1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpIHtcbiAgICAgICAgYWIgPSAtYWI7XG4gICAgICB9XG4gICAgfVxuICAgIGxhbSA9IE1hdGguYXRhbjIoeCwgeSk7XG4gICAgcGhpID0gdGhpcy5hdXRobGF0KE1hdGguYXNpbihhYiksIHRoaXMuYXBhKTtcbiAgfVxuXG5cbiAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgbGFtKTtcbiAgcC55ID0gcGhpO1xuICByZXR1cm4gcDtcbn07XG5cbi8qIGRldGVybWluZSBsYXRpdHVkZSBmcm9tIGF1dGhhbGljIGxhdGl0dWRlICovXG5leHBvcnRzLlAwMCA9IDAuMzMzMzMzMzMzMzMzMzMzMzMzMzM7XG5leHBvcnRzLlAwMSA9IDAuMTcyMjIyMjIyMjIyMjIyMjIyMjI7XG5leHBvcnRzLlAwMiA9IDAuMTAyNTc5MzY1MDc5MzY1MDc5MzY7XG5leHBvcnRzLlAxMCA9IDAuMDYzODg4ODg4ODg4ODg4ODg4ODg7XG5leHBvcnRzLlAxMSA9IDAuMDY2NDAyMTE2NDAyMTE2NDAyMTE7XG5leHBvcnRzLlAyMCA9IDAuMDE2NDE1MDEyOTQyMTkxNTQ0NDM7XG5cbmV4cG9ydHMuYXV0aHNldCA9IGZ1bmN0aW9uKGVzKSB7XG4gIHZhciB0O1xuICB2YXIgQVBBID0gW107XG4gIEFQQVswXSA9IGVzICogdGhpcy5QMDA7XG4gIHQgPSBlcyAqIGVzO1xuICBBUEFbMF0gKz0gdCAqIHRoaXMuUDAxO1xuICBBUEFbMV0gPSB0ICogdGhpcy5QMTA7XG4gIHQgKj0gZXM7XG4gIEFQQVswXSArPSB0ICogdGhpcy5QMDI7XG4gIEFQQVsxXSArPSB0ICogdGhpcy5QMTE7XG4gIEFQQVsyXSA9IHQgKiB0aGlzLlAyMDtcbiAgcmV0dXJuIEFQQTtcbn07XG5cbmV4cG9ydHMuYXV0aGxhdCA9IGZ1bmN0aW9uKGJldGEsIEFQQSkge1xuICB2YXIgdCA9IGJldGEgKyBiZXRhO1xuICByZXR1cm4gKGJldGEgKyBBUEFbMF0gKiBNYXRoLnNpbih0KSArIEFQQVsxXSAqIE1hdGguc2luKHQgKyB0KSArIEFQQVsyXSAqIE1hdGguc2luKHQgKyB0ICsgdCkpO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJMYW1iZXJ0IEF6aW11dGhhbCBFcXVhbCBBcmVhXCIsIFwiTGFtYmVydF9BemltdXRoYWxfRXF1YWxfQXJlYVwiLCBcImxhZWFcIl07XG5cbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL3FzZm56XCI6MjB9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIG1zZm56ID0gX2RlcmVxXygnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgdHNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIHNpZ24gPSBfZGVyZXFfKCcuLi9jb21tb24vc2lnbicpO1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIHBoaTJ6ID0gX2RlcmVxXygnLi4vY29tbW9uL3BoaTJ6Jyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICAvLyBhcnJheSBvZjogIHJfbWFqLHJfbWluLGxhdDEsbGF0MixjX2xvbixjX2xhdCxmYWxzZV9lYXN0LGZhbHNlX25vcnRoXG4gIC8vZG91YmxlIGNfbGF0OyAgICAgICAgICAgICAgICAgICAvKiBjZW50ZXIgbGF0aXR1ZGUgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgY19sb247ICAgICAgICAgICAgICAgICAgIC8qIGNlbnRlciBsb25naXR1ZGUgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBsYXQxOyAgICAgICAgICAgICAgICAgICAgLyogZmlyc3Qgc3RhbmRhcmQgcGFyYWxsZWwgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGxhdDI7ICAgICAgICAgICAgICAgICAgICAvKiBzZWNvbmQgc3RhbmRhcmQgcGFyYWxsZWwgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgcl9tYWo7ICAgICAgICAgICAgICAgICAgIC8qIG1ham9yIGF4aXMgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSByX21pbjsgICAgICAgICAgICAgICAgICAgLyogbWlub3IgYXhpcyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGZhbHNlX2Vhc3Q7ICAgICAgICAgICAgICAvKiB4IG9mZnNldCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgZmFsc2Vfbm9ydGg7ICAgICAgICAgICAgIC8qIHkgb2Zmc2V0IGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAqL1xuXG4gIGlmICghdGhpcy5sYXQyKSB7XG4gICAgdGhpcy5sYXQyID0gdGhpcy5sYXQxO1xuICB9IC8vaWYgbGF0MiBpcyBub3QgZGVmaW5lZFxuICBpZiAoIXRoaXMuazApIHtcbiAgICB0aGlzLmswID0gMTtcbiAgfVxuICB0aGlzLngwID0gdGhpcy54MCB8fCAwO1xuICB0aGlzLnkwID0gdGhpcy55MCB8fCAwO1xuICAvLyBTdGFuZGFyZCBQYXJhbGxlbHMgY2Fubm90IGJlIGVxdWFsIGFuZCBvbiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgZXF1YXRvclxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxICsgdGhpcy5sYXQyKSA8IEVQU0xOKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZSA9IE1hdGguc3FydCgxIC0gdGVtcCAqIHRlbXApO1xuXG4gIHZhciBzaW4xID0gTWF0aC5zaW4odGhpcy5sYXQxKTtcbiAgdmFyIGNvczEgPSBNYXRoLmNvcyh0aGlzLmxhdDEpO1xuICB2YXIgbXMxID0gbXNmbnoodGhpcy5lLCBzaW4xLCBjb3MxKTtcbiAgdmFyIHRzMSA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQxLCBzaW4xKTtcblxuICB2YXIgc2luMiA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHZhciBjb3MyID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdmFyIG1zMiA9IG1zZm56KHRoaXMuZSwgc2luMiwgY29zMik7XG4gIHZhciB0czIgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0Miwgc2luMik7XG5cbiAgdmFyIHRzMCA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQwLCBNYXRoLnNpbih0aGlzLmxhdDApKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxIC0gdGhpcy5sYXQyKSA+IEVQU0xOKSB7XG4gICAgdGhpcy5ucyA9IE1hdGgubG9nKG1zMSAvIG1zMikgLyBNYXRoLmxvZyh0czEgLyB0czIpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubnMgPSBzaW4xO1xuICB9XG4gIGlmIChpc05hTih0aGlzLm5zKSkge1xuICAgIHRoaXMubnMgPSBzaW4xO1xuICB9XG4gIHRoaXMuZjAgPSBtczEgLyAodGhpcy5ucyAqIE1hdGgucG93KHRzMSwgdGhpcy5ucykpO1xuICB0aGlzLnJoID0gdGhpcy5hICogdGhpcy5mMCAqIE1hdGgucG93KHRzMCwgdGhpcy5ucyk7XG4gIGlmICghdGhpcy50aXRsZSkge1xuICAgIHRoaXMudGl0bGUgPSBcIkxhbWJlcnQgQ29uZm9ybWFsIENvbmljXCI7XG4gIH1cbn07XG5cblxuLy8gTGFtYmVydCBDb25mb3JtYWwgY29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgLy8gc2luZ3VsYXIgY2FzZXMgOlxuICBpZiAoTWF0aC5hYnMoMiAqIE1hdGguYWJzKGxhdCkgLSBNYXRoLlBJKSA8PSBFUFNMTikge1xuICAgIGxhdCA9IHNpZ24obGF0KSAqIChIQUxGX1BJIC0gMiAqIEVQU0xOKTtcbiAgfVxuXG4gIHZhciBjb24gPSBNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSk7XG4gIHZhciB0cywgcmgxO1xuICBpZiAoY29uID4gRVBTTE4pIHtcbiAgICB0cyA9IHRzZm56KHRoaXMuZSwgbGF0LCBNYXRoLnNpbihsYXQpKTtcbiAgICByaDEgPSB0aGlzLmEgKiB0aGlzLmYwICogTWF0aC5wb3codHMsIHRoaXMubnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbiA9IGxhdCAqIHRoaXMubnM7XG4gICAgaWYgKGNvbiA8PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmgxID0gMDtcbiAgfVxuICB2YXIgdGhldGEgPSB0aGlzLm5zICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgcC54ID0gdGhpcy5rMCAqIChyaDEgKiBNYXRoLnNpbih0aGV0YSkpICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5rMCAqICh0aGlzLnJoIC0gcmgxICogTWF0aC5jb3ModGhldGEpKSArIHRoaXMueTA7XG5cbiAgcmV0dXJuIHA7XG59O1xuXG4vLyBMYW1iZXJ0IENvbmZvcm1hbCBDb25pYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG5cbiAgdmFyIHJoMSwgY29uLCB0cztcbiAgdmFyIGxhdCwgbG9uO1xuICB2YXIgeCA9IChwLnggLSB0aGlzLngwKSAvIHRoaXMuazA7XG4gIHZhciB5ID0gKHRoaXMucmggLSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmswKTtcbiAgaWYgKHRoaXMubnMgPiAwKSB7XG4gICAgcmgxID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNvbiA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmgxID0gLU1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB2YXIgdGhldGEgPSAwO1xuICBpZiAocmgxICE9PSAwKSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKChjb24gKiB4KSwgKGNvbiAqIHkpKTtcbiAgfVxuICBpZiAoKHJoMSAhPT0gMCkgfHwgKHRoaXMubnMgPiAwKSkge1xuICAgIGNvbiA9IDEgLyB0aGlzLm5zO1xuICAgIHRzID0gTWF0aC5wb3coKHJoMSAvICh0aGlzLmEgKiB0aGlzLmYwKSksIGNvbik7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSAtSEFMRl9QSTtcbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoZXRhIC8gdGhpcy5ucyArIHRoaXMubG9uZzApO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5cbmV4cG9ydHMubmFtZXMgPSBbXCJMYW1iZXJ0IFRhbmdlbnRpYWwgQ29uZm9ybWFsIENvbmljIFByb2plY3Rpb25cIiwgXCJMYW1iZXJ0X0NvbmZvcm1hbF9Db25pY1wiLCBcIkxhbWJlcnRfQ29uZm9ybWFsX0NvbmljXzJTUFwiLCBcImxjY1wiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjUsXCIuLi9jb21tb24vbXNmbnpcIjoxNSxcIi4uL2NvbW1vbi9waGkyelwiOjE2LFwiLi4vY29tbW9uL3NpZ25cIjoyMSxcIi4uL2NvbW1vbi90c2ZuelwiOjI0fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vbm8tb3AgZm9yIGxvbmdsYXRcbn07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG4gIHJldHVybiBwdDtcbn1cbmV4cG9ydHMuZm9yd2FyZCA9IGlkZW50aXR5O1xuZXhwb3J0cy5pbnZlcnNlID0gaWRlbnRpdHk7XG5leHBvcnRzLm5hbWVzID0gW1wibG9uZ2xhdFwiLCBcImlkZW50aXR5XCJdO1xuXG59LHt9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgbXNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBGT1JUUEkgPSBNYXRoLlBJLzQ7XG52YXIgdHNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBwaGkyeiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9waGkyeicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb24gPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gY29uICogY29uO1xuICBpZighKCd4MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueDAgPSAwO1xuICB9XG4gIGlmKCEoJ3kwJyBpbiB0aGlzKSl7XG4gICAgdGhpcy55MCA9IDA7XG4gIH1cbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICBpZiAodGhpcy5sYXRfdHMpIHtcbiAgICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICAgIHRoaXMuazAgPSBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuazApIHtcbiAgICAgIGlmICh0aGlzLmspIHtcbiAgICAgICAgdGhpcy5rMCA9IHRoaXMuaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmswID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIE1lcmNhdG9yIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLy8gY29udmVydCB0byByYWRpYW5zXG4gIGlmIChsYXQgKiBSMkQgPiA5MCAmJiBsYXQgKiBSMkQgPCAtOTAgJiYgbG9uICogUjJEID4gMTgwICYmIGxvbiAqIFIyRCA8IC0xODApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB4LCB5O1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgMC41ICogbGF0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gICAgICB2YXIgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgc2lucGhpKTtcbiAgICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICB5ID0gdGhpcy55MCAtIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZyh0cyk7XG4gICAgfVxuICAgIHAueCA9IHg7XG4gICAgcC55ID0geTtcbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxuXG4vKiBNZXJjYXRvciBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciB4ID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgdHMgPSBNYXRoLmV4cCgteSAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB4IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiTWVyY2F0b3JcIiwgXCJQb3B1bGFyIFZpc3VhbGlzYXRpb24gUHNldWRvIE1lcmNhdG9yXCIsIFwiTWVyY2F0b3JfMVNQXCIsIFwiTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZVwiLCBcIm1lcmNcIl07XG5cbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL21zZm56XCI6MTUsXCIuLi9jb21tb24vcGhpMnpcIjoxNixcIi4uL2NvbW1vbi90c2ZuelwiOjI0fV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuLypcbiAgcmVmZXJlbmNlXG4gICAgXCJOZXcgRXF1YWwtQXJlYSBNYXAgUHJvamVjdGlvbnMgZm9yIE5vbmNpcmN1bGFyIFJlZ2lvbnNcIiwgSm9obiBQLiBTbnlkZXIsXG4gICAgVGhlIEFtZXJpY2FuIENhcnRvZ3JhcGhlciwgVm9sIDE1LCBOby4gNCwgT2N0b2JlciAxOTg4LCBwcC4gMzQxLTM1NS5cbiAgKi9cblxuXG4vKiBJbml0aWFsaXplIHRoZSBNaWxsZXIgQ3lsaW5kcmljYWwgcHJvamVjdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvL25vLW9wXG59O1xuXG5cbi8qIE1pbGxlciBDeWxpbmRyaWNhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGRsb247XG4gIHZhciB5ID0gdGhpcy55MCArIHRoaXMuYSAqIE1hdGgubG9nKE1hdGgudGFuKChNYXRoLlBJIC8gNCkgKyAobGF0IC8gMi41KSkpICogMS4yNTtcblxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cbi8qIE1pbGxlciBDeWxpbmRyaWNhbCBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG5cbiAgdmFyIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHAueCAvIHRoaXMuYSk7XG4gIHZhciBsYXQgPSAyLjUgKiAoTWF0aC5hdGFuKE1hdGguZXhwKDAuOCAqIHAueSAvIHRoaXMuYSkpIC0gTWF0aC5QSSAvIDQpO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiTWlsbGVyX0N5bGluZHJpY2FsXCIsIFwibWlsbFwiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjV9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRqdXN0X2xvbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuLyogTW9sbHdlaWRlIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB0aGV0YSA9IGxhdDtcbiAgdmFyIGNvbiA9IE1hdGguUEkgKiBNYXRoLnNpbihsYXQpO1xuXG4gIC8qIEl0ZXJhdGUgdXNpbmcgdGhlIE5ld3Rvbi1SYXBoc29uIG1ldGhvZCB0byBmaW5kIHRoZXRhXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIGZvciAodmFyIGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICB2YXIgZGVsdGFfdGhldGEgPSAtKHRoZXRhICsgTWF0aC5zaW4odGhldGEpIC0gY29uKSAvICgxICsgTWF0aC5jb3ModGhldGEpKTtcbiAgICB0aGV0YSArPSBkZWx0YV90aGV0YTtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFfdGhldGEpIDwgRVBTTE4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGV0YSAvPSAyO1xuXG4gIC8qIElmIHRoZSBsYXRpdHVkZSBpcyA5MCBkZWcsIGZvcmNlIHRoZSB4IGNvb3JkaW5hdGUgdG8gYmUgXCIwICsgZmFsc2UgZWFzdGluZ1wiXG4gICAgICAgdGhpcyBpcyBkb25lIGhlcmUgYmVjYXVzZSBvZiBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBcImNvcyh0aGV0YSlcIlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKE1hdGguUEkgLyAyIC0gTWF0aC5hYnMobGF0KSA8IEVQU0xOKSB7XG4gICAgZGVsdGFfbG9uID0gMDtcbiAgfVxuICB2YXIgeCA9IDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogZGVsdGFfbG9uICogTWF0aC5jb3ModGhldGEpICsgdGhpcy54MDtcbiAgdmFyIHkgPSAxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEgKiBNYXRoLnNpbih0aGV0YSkgKyB0aGlzLnkwO1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdGhldGE7XG4gIHZhciBhcmc7XG5cbiAgLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICBhcmcgPSBwLnkgLyAoMS40MTQyMTM1NjIzNzMxICogdGhpcy5hKTtcblxuICAvKiBCZWNhdXNlIG9mIGRpdmlzaW9uIGJ5IHplcm8gcHJvYmxlbXMsICdhcmcnIGNhbiBub3QgYmUgMS4gIFRoZXJlZm9yZVxuICAgICAgIGEgbnVtYmVyIHZlcnkgY2xvc2UgdG8gb25lIGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKE1hdGguYWJzKGFyZykgPiAwLjk5OTk5OTk5OTk5OSkge1xuICAgIGFyZyA9IDAuOTk5OTk5OTk5OTk5O1xuICB9XG4gIHRoZXRhID0gTWF0aC5hc2luKGFyZyk7XG4gIHZhciBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAocC54IC8gKDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogTWF0aC5jb3ModGhldGEpKSkpO1xuICBpZiAobG9uIDwgKC1NYXRoLlBJKSkge1xuICAgIGxvbiA9IC1NYXRoLlBJO1xuICB9XG4gIGlmIChsb24gPiBNYXRoLlBJKSB7XG4gICAgbG9uID0gTWF0aC5QSTtcbiAgfVxuICBhcmcgPSAoMiAqIHRoZXRhICsgTWF0aC5zaW4oMiAqIHRoZXRhKSkgLyBNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMoYXJnKSA+IDEpIHtcbiAgICBhcmcgPSAxO1xuICB9XG4gIHZhciBsYXQgPSBNYXRoLmFzaW4oYXJnKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIk1vbGx3ZWlkZVwiLCBcIm1vbGxcIl07XG5cbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xuLypcbiAgcmVmZXJlbmNlXG4gICAgRGVwYXJ0bWVudCBvZiBMYW5kIGFuZCBTdXJ2ZXkgVGVjaG5pY2FsIENpcmN1bGFyIDE5NzMvMzJcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uei1tYXAtZGVmaW5pdGlvbi5wZGZcbiAgICBPU0cgVGVjaG5pY2FsIFJlcG9ydCA0LjFcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uem1nLnBkZlxuICAqL1xuXG4vKipcbiAqIGl0ZXJhdGlvbnM6IE51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJlZmluZSBpbnZlcnNlIHRyYW5zZm9ybS5cbiAqICAgICAwIC0+IGttIGFjY3VyYWN5XG4gKiAgICAgMSAtPiBtIGFjY3VyYWN5IC0tIHN1aXRhYmxlIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gKiAgICAgMiAtPiBtbSBhY2N1cmFjeVxuICovXG5leHBvcnRzLml0ZXJhdGlvbnMgPSAxO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5BID0gW107XG4gIHRoaXMuQVsxXSA9IDAuNjM5OTE3NTA3MztcbiAgdGhpcy5BWzJdID0gLTAuMTM1ODc5NzYxMztcbiAgdGhpcy5BWzNdID0gMC4wNjMyOTQ0MDk7XG4gIHRoaXMuQVs0XSA9IC0wLjAyNTI2ODUzO1xuICB0aGlzLkFbNV0gPSAwLjAxMTc4Nzk7XG4gIHRoaXMuQVs2XSA9IC0wLjAwNTUxNjE7XG4gIHRoaXMuQVs3XSA9IDAuMDAyNjkwNjtcbiAgdGhpcy5BWzhdID0gLTAuMDAxMzMzO1xuICB0aGlzLkFbOV0gPSAwLjAwMDY3O1xuICB0aGlzLkFbMTBdID0gLTAuMDAwMzQ7XG5cbiAgdGhpcy5CX3JlID0gW107XG4gIHRoaXMuQl9pbSA9IFtdO1xuICB0aGlzLkJfcmVbMV0gPSAwLjc1NTc4NTMyMjg7XG4gIHRoaXMuQl9pbVsxXSA9IDA7XG4gIHRoaXMuQl9yZVsyXSA9IDAuMjQ5MjA0NjQ2O1xuICB0aGlzLkJfaW1bMl0gPSAwLjAwMzM3MTUwNztcbiAgdGhpcy5CX3JlWzNdID0gLTAuMDAxNTQxNzM5O1xuICB0aGlzLkJfaW1bM10gPSAwLjA0MTA1ODU2MDtcbiAgdGhpcy5CX3JlWzRdID0gLTAuMTAxNjI5MDc7XG4gIHRoaXMuQl9pbVs0XSA9IDAuMDE3Mjc2MDk7XG4gIHRoaXMuQl9yZVs1XSA9IC0wLjI2NjIzNDg5O1xuICB0aGlzLkJfaW1bNV0gPSAtMC4zNjI0OTIxODtcbiAgdGhpcy5CX3JlWzZdID0gLTAuNjg3MDk4MztcbiAgdGhpcy5CX2ltWzZdID0gLTEuMTY1MTk2NztcblxuICB0aGlzLkNfcmUgPSBbXTtcbiAgdGhpcy5DX2ltID0gW107XG4gIHRoaXMuQ19yZVsxXSA9IDEuMzIzMTI3MDQzOTtcbiAgdGhpcy5DX2ltWzFdID0gMDtcbiAgdGhpcy5DX3JlWzJdID0gLTAuNTc3MjQ1Nzg5O1xuICB0aGlzLkNfaW1bMl0gPSAtMC4wMDc4MDk1OTg7XG4gIHRoaXMuQ19yZVszXSA9IDAuNTA4MzA3NTEzO1xuICB0aGlzLkNfaW1bM10gPSAtMC4xMTIyMDg5NTI7XG4gIHRoaXMuQ19yZVs0XSA9IC0wLjE1MDk0NzYyO1xuICB0aGlzLkNfaW1bNF0gPSAwLjE4MjAwNjAyO1xuICB0aGlzLkNfcmVbNV0gPSAxLjAxNDE4MTc5O1xuICB0aGlzLkNfaW1bNV0gPSAxLjY0NDk3Njk2O1xuICB0aGlzLkNfcmVbNl0gPSAxLjk2NjA1NDk7XG4gIHRoaXMuQ19pbVs2XSA9IDIuNTEyNzY0NTtcblxuICB0aGlzLkQgPSBbXTtcbiAgdGhpcy5EWzFdID0gMS41NjI3MDE0MjQzO1xuICB0aGlzLkRbMl0gPSAwLjUxODU0MDYzOTg7XG4gIHRoaXMuRFszXSA9IC0wLjAzMzMzMDk4O1xuICB0aGlzLkRbNF0gPSAtMC4xMDUyOTA2O1xuICB0aGlzLkRbNV0gPSAtMC4wMzY4NTk0O1xuICB0aGlzLkRbNl0gPSAwLjAwNzMxNztcbiAgdGhpcy5EWzddID0gMC4wMTIyMDtcbiAgdGhpcy5EWzhdID0gMC4wMDM5NDtcbiAgdGhpcy5EWzldID0gLTAuMDAxMztcbn07XG5cbi8qKlxuICAgIE5ldyBaZWFsYW5kIE1hcCBHcmlkIEZvcndhcmQgIC0gbG9uZy9sYXQgdG8geC95XG4gICAgbG9uZy9sYXQgaW4gcmFkaWFuc1xuICAqL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbjtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbGF0ID0gbGF0IC0gdGhpcy5sYXQwO1xuICB2YXIgZGVsdGFfbG9uID0gbG9uIC0gdGhpcy5sb25nMDtcblxuICAvLyAxLiBDYWxjdWxhdGUgZF9waGkgYW5kIGRfcHNpICAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRfbGFtYmRhXG4gIC8vIEZvciB0aGlzIGFsZ29yaXRobSwgZGVsdGFfbGF0aXR1ZGUgaXMgaW4gc2Vjb25kcyBvZiBhcmMgeCAxMC01LCBzbyB3ZSBuZWVkIHRvIHNjYWxlIHRvIHRob3NlIHVuaXRzLiBMb25naXR1ZGUgaXMgcmFkaWFucy5cbiAgdmFyIGRfcGhpID0gZGVsdGFfbGF0IC8gU0VDX1RPX1JBRCAqIDFFLTU7XG4gIHZhciBkX2xhbWJkYSA9IGRlbHRhX2xvbjtcbiAgdmFyIGRfcGhpX24gPSAxOyAvLyBkX3BoaV4wXG5cbiAgdmFyIGRfcHNpID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSAxMDsgbisrKSB7XG4gICAgZF9waGlfbiA9IGRfcGhpX24gKiBkX3BoaTtcbiAgICBkX3BzaSA9IGRfcHNpICsgdGhpcy5BW25dICogZF9waGlfbjtcbiAgfVxuXG4gIC8vIDIuIENhbGN1bGF0ZSB0aGV0YVxuICB2YXIgdGhfcmUgPSBkX3BzaTtcbiAgdmFyIHRoX2ltID0gZF9sYW1iZGE7XG5cbiAgLy8gMy4gQ2FsY3VsYXRlIHpcbiAgdmFyIHRoX25fcmUgPSAxO1xuICB2YXIgdGhfbl9pbSA9IDA7IC8vIHRoZXRhXjBcbiAgdmFyIHRoX25fcmUxO1xuICB2YXIgdGhfbl9pbTE7XG5cbiAgdmFyIHpfcmUgPSAwO1xuICB2YXIgel9pbSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gNjsgbisrKSB7XG4gICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG4gICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICB6X3JlID0gel9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltO1xuICAgIHpfaW0gPSB6X2ltICsgdGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW07XG4gIH1cblxuICAvLyA0LiBDYWxjdWxhdGUgZWFzdGluZyBhbmQgbm9ydGhpbmdcbiAgcC54ID0gKHpfaW0gKiB0aGlzLmEpICsgdGhpcy54MDtcbiAgcC55ID0gKHpfcmUgKiB0aGlzLmEpICsgdGhpcy55MDtcblxuICByZXR1cm4gcDtcbn07XG5cblxuLyoqXG4gICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgSW52ZXJzZSAgLSAgeC95IHRvIGxvbmcvbGF0XG4gICovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBuO1xuICB2YXIgeCA9IHAueDtcbiAgdmFyIHkgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX3ggPSB4IC0gdGhpcy54MDtcbiAgdmFyIGRlbHRhX3kgPSB5IC0gdGhpcy55MDtcblxuICAvLyAxLiBDYWxjdWxhdGUgelxuICB2YXIgel9yZSA9IGRlbHRhX3kgLyB0aGlzLmE7XG4gIHZhciB6X2ltID0gZGVsdGFfeCAvIHRoaXMuYTtcblxuICAvLyAyYS4gQ2FsY3VsYXRlIHRoZXRhIC0gZmlyc3QgYXBwcm94aW1hdGlvbiBnaXZlcyBrbSBhY2N1cmFjeVxuICB2YXIgel9uX3JlID0gMTtcbiAgdmFyIHpfbl9pbSA9IDA7IC8vIHpeMFxuICB2YXIgel9uX3JlMTtcbiAgdmFyIHpfbl9pbTE7XG5cbiAgdmFyIHRoX3JlID0gMDtcbiAgdmFyIHRoX2ltID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSA2OyBuKyspIHtcbiAgICB6X25fcmUxID0gel9uX3JlICogel9yZSAtIHpfbl9pbSAqIHpfaW07XG4gICAgel9uX2ltMSA9IHpfbl9pbSAqIHpfcmUgKyB6X25fcmUgKiB6X2ltO1xuICAgIHpfbl9yZSA9IHpfbl9yZTE7XG4gICAgel9uX2ltID0gel9uX2ltMTtcbiAgICB0aF9yZSA9IHRoX3JlICsgdGhpcy5DX3JlW25dICogel9uX3JlIC0gdGhpcy5DX2ltW25dICogel9uX2ltO1xuICAgIHRoX2ltID0gdGhfaW0gKyB0aGlzLkNfaW1bbl0gKiB6X25fcmUgKyB0aGlzLkNfcmVbbl0gKiB6X25faW07XG4gIH1cblxuICAvLyAyYi4gSXRlcmF0ZSB0byByZWZpbmUgdGhlIGFjY3VyYWN5IG9mIHRoZSBjYWxjdWxhdGlvblxuICAvLyAgICAgICAgMCBpdGVyYXRpb25zIGdpdmVzIGttIGFjY3VyYWN5XG4gIC8vICAgICAgICAxIGl0ZXJhdGlvbiBnaXZlcyBtIGFjY3VyYWN5IC0tIGdvb2QgZW5vdWdoIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gIC8vICAgICAgICAyIGl0ZXJhdGlvbnMgYml2ZXMgbW0gYWNjdXJhY3lcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZXJhdGlvbnM7IGkrKykge1xuICAgIHZhciB0aF9uX3JlID0gdGhfcmU7XG4gICAgdmFyIHRoX25faW0gPSB0aF9pbTtcbiAgICB2YXIgdGhfbl9yZTE7XG4gICAgdmFyIHRoX25faW0xO1xuXG4gICAgdmFyIG51bV9yZSA9IHpfcmU7XG4gICAgdmFyIG51bV9pbSA9IHpfaW07XG4gICAgZm9yIChuID0gMjsgbiA8PSA2OyBuKyspIHtcbiAgICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuICAgICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG4gICAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG4gICAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG4gICAgICBudW1fcmUgPSBudW1fcmUgKyAobiAtIDEpICogKHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltKTtcbiAgICAgIG51bV9pbSA9IG51bV9pbSArIChuIC0gMSkgKiAodGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW0pO1xuICAgIH1cblxuICAgIHRoX25fcmUgPSAxO1xuICAgIHRoX25faW0gPSAwO1xuICAgIHZhciBkZW5fcmUgPSB0aGlzLkJfcmVbMV07XG4gICAgdmFyIGRlbl9pbSA9IHRoaXMuQl9pbVsxXTtcbiAgICBmb3IgKG4gPSAyOyBuIDw9IDY7IG4rKykge1xuICAgICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICAgIHRoX25fcmUgPSB0aF9uX3JlMTtcbiAgICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICAgIGRlbl9yZSA9IGRlbl9yZSArIG4gKiAodGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW0pO1xuICAgICAgZGVuX2ltID0gZGVuX2ltICsgbiAqICh0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGxleCBkaXZpc2lvblxuICAgIHZhciBkZW4yID0gZGVuX3JlICogZGVuX3JlICsgZGVuX2ltICogZGVuX2ltO1xuICAgIHRoX3JlID0gKG51bV9yZSAqIGRlbl9yZSArIG51bV9pbSAqIGRlbl9pbSkgLyBkZW4yO1xuICAgIHRoX2ltID0gKG51bV9pbSAqIGRlbl9yZSAtIG51bV9yZSAqIGRlbl9pbSkgLyBkZW4yO1xuICB9XG5cbiAgLy8gMy4gQ2FsY3VsYXRlIGRfcGhpICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZF9sYW1iZGFcbiAgdmFyIGRfcHNpID0gdGhfcmU7XG4gIHZhciBkX2xhbWJkYSA9IHRoX2ltO1xuICB2YXIgZF9wc2lfbiA9IDE7IC8vIGRfcHNpXjBcblxuICB2YXIgZF9waGkgPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDk7IG4rKykge1xuICAgIGRfcHNpX24gPSBkX3BzaV9uICogZF9wc2k7XG4gICAgZF9waGkgPSBkX3BoaSArIHRoaXMuRFtuXSAqIGRfcHNpX247XG4gIH1cblxuICAvLyA0LiBDYWxjdWxhdGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZVxuICAvLyBkX3BoaSBpcyBjYWxjdWF0ZWQgaW4gc2Vjb25kIG9mIGFyYyAqIDEwXi01LCBzbyB3ZSBuZWVkIHRvIHNjYWxlIGJhY2sgdG8gcmFkaWFucy4gZF9sYW1iZGEgaXMgaW4gcmFkaWFucy5cbiAgdmFyIGxhdCA9IHRoaXMubGF0MCArIChkX3BoaSAqIFNFQ19UT19SQUQgKiAxRTUpO1xuICB2YXIgbG9uID0gdGhpcy5sb25nMCArIGRfbGFtYmRhO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuXG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJOZXdfWmVhbGFuZF9NYXBfR3JpZFwiLCBcIm56bWdcIl07XG59LHt9XSw1NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdHNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBwaGkyeiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9waGkyeicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIEVQU0xOID0gMS4wZS0xMDtcblxuLyogSW5pdGlhbGl6ZSB0aGUgT2JsaXF1ZSBNZXJjYXRvciAgcHJvamVjdGlvblxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub19vZmYgPSB0aGlzLm5vX29mZiB8fCBmYWxzZTtcbiAgdGhpcy5ub19yb3QgPSB0aGlzLm5vX3JvdCB8fCBmYWxzZTtcblxuICBpZiAoaXNOYU4odGhpcy5rMCkpIHtcbiAgICB0aGlzLmswID0gMTtcbiAgfVxuICB2YXIgc2lubGF0ID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdmFyIGNvc2xhdCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIHZhciBjb24gPSB0aGlzLmUgKiBzaW5sYXQ7XG5cbiAgdGhpcy5ibCA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAvICgxIC0gdGhpcy5lcykgKiBNYXRoLnBvdyhjb3NsYXQsIDQpKTtcbiAgdGhpcy5hbCA9IHRoaXMuYSAqIHRoaXMuYmwgKiB0aGlzLmswICogTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSAvICgxIC0gY29uICogY29uKTtcbiAgdmFyIHQwID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDAsIHNpbmxhdCk7XG4gIHZhciBkbCA9IHRoaXMuYmwgLyBjb3NsYXQgKiBNYXRoLnNxcnQoKDEgLSB0aGlzLmVzKSAvICgxIC0gY29uICogY29uKSk7XG4gIGlmIChkbCAqIGRsIDwgMSkge1xuICAgIGRsID0gMTtcbiAgfVxuICB2YXIgZmw7XG4gIHZhciBnbDtcbiAgaWYgKCFpc05hTih0aGlzLmxvbmdjKSkge1xuICAgIC8vQ2VudHJhbCBwb2ludCBhbmQgYXppbXV0aCBtZXRob2RcblxuICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuICAgICAgZmwgPSBkbCArIE1hdGguc3FydChkbCAqIGRsIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmwgPSBkbCAtIE1hdGguc3FydChkbCAqIGRsIC0gMSk7XG4gICAgfVxuICAgIHRoaXMuZWwgPSBmbCAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICBnbCA9IDAuNSAqIChmbCAtIDEgLyBmbCk7XG4gICAgdGhpcy5nYW1tYTAgPSBNYXRoLmFzaW4oTWF0aC5zaW4odGhpcy5hbHBoYSkgLyBkbCk7XG4gICAgdGhpcy5sb25nMCA9IHRoaXMubG9uZ2MgLSBNYXRoLmFzaW4oZ2wgKiBNYXRoLnRhbih0aGlzLmdhbW1hMCkpIC8gdGhpcy5ibDtcblxuICB9XG4gIGVsc2Uge1xuICAgIC8vMiBwb2ludHMgbWV0aG9kXG4gICAgdmFyIHQxID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDEsIE1hdGguc2luKHRoaXMubGF0MSkpO1xuICAgIHZhciB0MiA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQyLCBNYXRoLnNpbih0aGlzLmxhdDIpKTtcbiAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgIHRoaXMuZWwgPSAoZGwgKyBNYXRoLnNxcnQoZGwgKiBkbCAtIDEpKSAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmVsID0gKGRsIC0gTWF0aC5zcXJ0KGRsICogZGwgLSAxKSkgKiBNYXRoLnBvdyh0MCwgdGhpcy5ibCk7XG4gICAgfVxuICAgIHZhciBobCA9IE1hdGgucG93KHQxLCB0aGlzLmJsKTtcbiAgICB2YXIgbGwgPSBNYXRoLnBvdyh0MiwgdGhpcy5ibCk7XG4gICAgZmwgPSB0aGlzLmVsIC8gaGw7XG4gICAgZ2wgPSAwLjUgKiAoZmwgLSAxIC8gZmwpO1xuICAgIHZhciBqbCA9ICh0aGlzLmVsICogdGhpcy5lbCAtIGxsICogaGwpIC8gKHRoaXMuZWwgKiB0aGlzLmVsICsgbGwgKiBobCk7XG4gICAgdmFyIHBsID0gKGxsIC0gaGwpIC8gKGxsICsgaGwpO1xuICAgIHZhciBkbG9uMTIgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcyKTtcbiAgICB0aGlzLmxvbmcwID0gMC41ICogKHRoaXMubG9uZzEgKyB0aGlzLmxvbmcyKSAtIE1hdGguYXRhbihqbCAqIE1hdGgudGFuKDAuNSAqIHRoaXMuYmwgKiAoZGxvbjEyKSkgLyBwbCkgLyB0aGlzLmJsO1xuICAgIHRoaXMubG9uZzAgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzApO1xuICAgIHZhciBkbG9uMTAgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcwKTtcbiAgICB0aGlzLmdhbW1hMCA9IE1hdGguYXRhbihNYXRoLnNpbih0aGlzLmJsICogKGRsb24xMCkpIC8gZ2wpO1xuICAgIHRoaXMuYWxwaGEgPSBNYXRoLmFzaW4oZGwgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkpO1xuICB9XG5cbiAgaWYgKHRoaXMubm9fb2ZmKSB7XG4gICAgdGhpcy51YyA9IDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICB0aGlzLnVjID0gdGhpcy5hbCAvIHRoaXMuYmwgKiBNYXRoLmF0YW4yKE1hdGguc3FydChkbCAqIGRsIC0gMSksIE1hdGguY29zKHRoaXMuYWxwaGEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnVjID0gLTEgKiB0aGlzLmFsIC8gdGhpcy5ibCAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGRsICogZGwgLSAxKSwgTWF0aC5jb3ModGhpcy5hbHBoYSkpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cbi8qIE9ibGlxdWUgTWVyY2F0b3IgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHVzLCB2cztcbiAgdmFyIGNvbjtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgIGlmIChsYXQgPiAwKSB7XG4gICAgICBjb24gPSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb24gPSAxO1xuICAgIH1cbiAgICB2cyA9IHRoaXMuYWwgLyB0aGlzLmJsICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgY29uICogdGhpcy5nYW1tYTAgKiAwLjUpKTtcbiAgICB1cyA9IC0xICogY29uICogSEFMRl9QSSAqIHRoaXMuYWwgLyB0aGlzLmJsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciB0ID0gdHNmbnoodGhpcy5lLCBsYXQsIE1hdGguc2luKGxhdCkpO1xuICAgIHZhciBxbCA9IHRoaXMuZWwgLyBNYXRoLnBvdyh0LCB0aGlzLmJsKTtcbiAgICB2YXIgc2wgPSAwLjUgKiAocWwgLSAxIC8gcWwpO1xuICAgIHZhciB0bCA9IDAuNSAqIChxbCArIDEgLyBxbCk7XG4gICAgdmFyIHZsID0gTWF0aC5zaW4odGhpcy5ibCAqIChkbG9uKSk7XG4gICAgdmFyIHVsID0gKHNsICogTWF0aC5zaW4odGhpcy5nYW1tYTApIC0gdmwgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkpIC8gdGw7XG4gICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHVsKSAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICB2cyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2cyA9IDAuNSAqIHRoaXMuYWwgKiBNYXRoLmxvZygoMSAtIHVsKSAvICgxICsgdWwpKSAvIHRoaXMuYmw7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyh0aGlzLmJsICogKGRsb24pKSkgPD0gRVBTTE4pIHtcbiAgICAgIHVzID0gdGhpcy5hbCAqIHRoaXMuYmwgKiAoZGxvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXMgPSB0aGlzLmFsICogTWF0aC5hdGFuMihzbCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSArIHZsICogTWF0aC5zaW4odGhpcy5nYW1tYTApLCBNYXRoLmNvcyh0aGlzLmJsICogZGxvbikpIC8gdGhpcy5ibDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5ub19yb3QpIHtcbiAgICBwLnggPSB0aGlzLngwICsgdXM7XG4gICAgcC55ID0gdGhpcy55MCArIHZzO1xuICB9XG4gIGVsc2Uge1xuXG4gICAgdXMgLT0gdGhpcy51YztcbiAgICBwLnggPSB0aGlzLngwICsgdnMgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSArIHVzICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gICAgcC55ID0gdGhpcy55MCArIHVzICogTWF0aC5jb3ModGhpcy5hbHBoYSkgLSB2cyAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuICB9XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdXMsIHZzO1xuICBpZiAodGhpcy5ub19yb3QpIHtcbiAgICB2cyA9IHAueSAtIHRoaXMueTA7XG4gICAgdXMgPSBwLnggLSB0aGlzLngwO1xuICB9XG4gIGVsc2Uge1xuICAgIHZzID0gKHAueCAtIHRoaXMueDApICogTWF0aC5jb3ModGhpcy5hbHBoYSkgLSAocC55IC0gdGhpcy55MCkgKiBNYXRoLnNpbih0aGlzLmFscGhhKTtcbiAgICB1cyA9IChwLnkgLSB0aGlzLnkwKSAqIE1hdGguY29zKHRoaXMuYWxwaGEpICsgKHAueCAtIHRoaXMueDApICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gICAgdXMgKz0gdGhpcy51YztcbiAgfVxuICB2YXIgcXAgPSBNYXRoLmV4cCgtMSAqIHRoaXMuYmwgKiB2cyAvIHRoaXMuYWwpO1xuICB2YXIgc3AgPSAwLjUgKiAocXAgLSAxIC8gcXApO1xuICB2YXIgdHAgPSAwLjUgKiAocXAgKyAxIC8gcXApO1xuICB2YXIgdnAgPSBNYXRoLnNpbih0aGlzLmJsICogdXMgLyB0aGlzLmFsKTtcbiAgdmFyIHVwID0gKHZwICogTWF0aC5jb3ModGhpcy5nYW1tYTApICsgc3AgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkpIC8gdHA7XG4gIHZhciB0cyA9IE1hdGgucG93KHRoaXMuZWwgLyBNYXRoLnNxcnQoKDEgKyB1cCkgLyAoMSAtIHVwKSksIDEgLyB0aGlzLmJsKTtcbiAgaWYgKE1hdGguYWJzKHVwIC0gMSkgPCBFUFNMTikge1xuICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgcC55ID0gSEFMRl9QSTtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyh1cCArIDEpIDwgRVBTTE4pIHtcbiAgICBwLnggPSB0aGlzLmxvbmcwO1xuICAgIHAueSA9IC0xICogSEFMRl9QSTtcbiAgfVxuICBlbHNlIHtcbiAgICBwLnkgPSBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKHNwICogTWF0aC5jb3ModGhpcy5nYW1tYTApIC0gdnAgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCksIE1hdGguY29zKHRoaXMuYmwgKiB1cyAvIHRoaXMuYWwpKSAvIHRoaXMuYmwpO1xuICB9XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yXCIsIFwiSG90aW5lIE9ibGlxdWUgTWVyY2F0b3JcIiwgXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcl9BemltdXRoX05hdHVyYWxfT3JpZ2luXCIsIFwiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JfQXppbXV0aF9DZW50ZXJcIiwgXCJvbWVyY1wiXTtcbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL3BoaTJ6XCI6MTYsXCIuLi9jb21tb24vdHNmbnpcIjoyNH1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBlMGZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhZGp1c3RfbGF0ID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sYXQnKTtcbnZhciBtbGZuID0gX2RlcmVxXygnLi4vY29tbW9uL21sZm4nKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgZ04gPSBfZGVyZXFfKCcuLi9jb21tb24vZ04nKTtcbnZhciBNQVhfSVRFUiA9IDIwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2VcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTsgLy8gZGV2YWl0IGV0cmUgZGFucyB0bWVyYy5qcyBtYWlzIG4geSBlc3QgcGFzIGRvbmMgamUgY29tbWVudGUgc2lub24gcmV0b3VyIGRlIHZhbGV1cnMgbnVsbGVzXG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gIHRoaXMubWwwID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApOyAvL3NpIHF1ZSBkZXMgemVyb3MgbGUgY2FsY3VsIG5lIHNlIGZhaXQgcGFzXG59O1xuXG5cbi8qIFBvbHljb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgeCwgeSwgZWw7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgZWwgPSBkbG9uICogTWF0aC5zaW4obGF0KTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKE1hdGguYWJzKGxhdCkgPD0gRVBTTE4pIHtcbiAgICAgIHggPSB0aGlzLmEgKiBkbG9uO1xuICAgICAgeSA9IC0xICogdGhpcy5hICogdGhpcy5sYXQwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHggPSB0aGlzLmEgKiBNYXRoLnNpbihlbCkgLyBNYXRoLnRhbihsYXQpO1xuICAgICAgeSA9IHRoaXMuYSAqIChhZGp1c3RfbGF0KGxhdCAtIHRoaXMubGF0MCkgKyAoMSAtIE1hdGguY29zKGVsKSkgLyBNYXRoLnRhbihsYXQpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKGxhdCkgPD0gRVBTTE4pIHtcbiAgICAgIHggPSB0aGlzLmEgKiBkbG9uO1xuICAgICAgeSA9IC0xICogdGhpcy5tbDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5sID0gZ04odGhpcy5hLCB0aGlzLmUsIE1hdGguc2luKGxhdCkpIC8gTWF0aC50YW4obGF0KTtcbiAgICAgIHggPSBubCAqIE1hdGguc2luKGVsKTtcbiAgICAgIHkgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCkgLSB0aGlzLm1sMCArIG5sICogKDEgLSBNYXRoLmNvcyhlbCkpO1xuICAgIH1cblxuICB9XG4gIHAueCA9IHggKyB0aGlzLngwO1xuICBwLnkgPSB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiwgbGF0LCB4LCB5LCBpO1xuICB2YXIgYWwsIGJsO1xuICB2YXIgcGhpLCBkcGhpO1xuICB4ID0gcC54IC0gdGhpcy54MDtcbiAgeSA9IHAueSAtIHRoaXMueTA7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKE1hdGguYWJzKHkgKyB0aGlzLmEgKiB0aGlzLmxhdDApIDw9IEVQU0xOKSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHggLyB0aGlzLmEgKyB0aGlzLmxvbmcwKTtcbiAgICAgIGxhdCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWwgPSB0aGlzLmxhdDAgKyB5IC8gdGhpcy5hO1xuICAgICAgYmwgPSB4ICogeCAvIHRoaXMuYSAvIHRoaXMuYSArIGFsICogYWw7XG4gICAgICBwaGkgPSBhbDtcbiAgICAgIHZhciB0YW5waGk7XG4gICAgICBmb3IgKGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIHRhbnBoaSA9IE1hdGgudGFuKHBoaSk7XG4gICAgICAgIGRwaGkgPSAtMSAqIChhbCAqIChwaGkgKiB0YW5waGkgKyAxKSAtIHBoaSAtIDAuNSAqIChwaGkgKiBwaGkgKyBibCkgKiB0YW5waGkpIC8gKChwaGkgLSBhbCkgLyB0YW5waGkgLSAxKTtcbiAgICAgICAgcGhpICs9IGRwaGk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSBFUFNMTikge1xuICAgICAgICAgIGxhdCA9IHBoaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKE1hdGguYXNpbih4ICogTWF0aC50YW4ocGhpKSAvIHRoaXMuYSkpIC8gTWF0aC5zaW4obGF0KSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh5ICsgdGhpcy5tbDApIDw9IEVQU0xOKSB7XG4gICAgICBsYXQgPSAwO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvIHRoaXMuYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBhbCA9ICh0aGlzLm1sMCArIHkpIC8gdGhpcy5hO1xuICAgICAgYmwgPSB4ICogeCAvIHRoaXMuYSAvIHRoaXMuYSArIGFsICogYWw7XG4gICAgICBwaGkgPSBhbDtcbiAgICAgIHZhciBjbCwgbWxuLCBtbG5wLCBtYTtcbiAgICAgIHZhciBjb247XG4gICAgICBmb3IgKGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIGNvbiA9IHRoaXMuZSAqIE1hdGguc2luKHBoaSk7XG4gICAgICAgIGNsID0gTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pICogTWF0aC50YW4ocGhpKTtcbiAgICAgICAgbWxuID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBwaGkpO1xuICAgICAgICBtbG5wID0gdGhpcy5lMCAtIDIgKiB0aGlzLmUxICogTWF0aC5jb3MoMiAqIHBoaSkgKyA0ICogdGhpcy5lMiAqIE1hdGguY29zKDQgKiBwaGkpIC0gNiAqIHRoaXMuZTMgKiBNYXRoLmNvcyg2ICogcGhpKTtcbiAgICAgICAgbWEgPSBtbG4gLyB0aGlzLmE7XG4gICAgICAgIGRwaGkgPSAoYWwgKiAoY2wgKiBtYSArIDEpIC0gbWEgLSAwLjUgKiBjbCAqIChtYSAqIG1hICsgYmwpKSAvICh0aGlzLmVzICogTWF0aC5zaW4oMiAqIHBoaSkgKiAobWEgKiBtYSArIGJsIC0gMiAqIGFsICogbWEpIC8gKDQgKiBjbCkgKyAoYWwgLSBtYSkgKiAoY2wgKiBtbG5wIC0gMiAvIE1hdGguc2luKDIgKiBwaGkpKSAtIG1sbnApO1xuICAgICAgICBwaGkgLT0gZHBoaTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IEVQU0xOKSB7XG4gICAgICAgICAgbGF0ID0gcGhpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vbGF0PXBoaTR6KHRoaXMuZSx0aGlzLmUwLHRoaXMuZTEsdGhpcy5lMix0aGlzLmUzLGFsLGJsLDAsMCk7XG4gICAgICBjbCA9IE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIE1hdGgucG93KE1hdGguc2luKGxhdCksIDIpKSAqIE1hdGgudGFuKGxhdCk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmFzaW4oeCAqIGNsIC8gdGhpcy5hKSAvIE1hdGguc2luKGxhdCkpO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiUG9seWNvbmljXCIsIFwicG9seVwiXTtcbn0se1wiLi4vY29tbW9uL2FkanVzdF9sYXRcIjo0LFwiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2UwZm5cIjo3LFwiLi4vY29tbW9uL2UxZm5cIjo4LFwiLi4vY29tbW9uL2UyZm5cIjo5LFwiLi4vY29tbW9uL2UzZm5cIjoxMCxcIi4uL2NvbW1vbi9nTlwiOjExLFwiLi4vY29tbW9uL21sZm5cIjoxNH1dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhZGp1c3RfbGF0ID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sYXQnKTtcbnZhciBwal9lbmZuID0gX2RlcmVxXygnLi4vY29tbW9uL3BqX2VuZm4nKTtcbnZhciBNQVhfSVRFUiA9IDIwO1xudmFyIHBqX21sZm4gPSBfZGVyZXFfKCcuLi9jb21tb24vcGpfbWxmbicpO1xudmFyIHBqX2ludl9tbGZuID0gX2RlcmVxXygnLi4vY29tbW9uL3BqX2ludl9tbGZuJyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgYXNpbnogPSBfZGVyZXFfKCcuLi9jb21tb24vYXNpbnonKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5lbiA9IHBqX2VuZm4odGhpcy5lcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5uID0gMTtcbiAgICB0aGlzLm0gPSAwO1xuICAgIHRoaXMuZXMgPSAwO1xuICAgIHRoaXMuQ195ID0gTWF0aC5zcXJ0KCh0aGlzLm0gKyAxKSAvIHRoaXMubik7XG4gICAgdGhpcy5DX3ggPSB0aGlzLkNfeSAvICh0aGlzLm0gKyAxKTtcbiAgfVxuXG59O1xuXG4vKiBTaW51c29pZGFsIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciB4LCB5O1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAoIXRoaXMubSkge1xuICAgICAgbGF0ID0gdGhpcy5uICE9PSAxID8gTWF0aC5hc2luKHRoaXMubiAqIE1hdGguc2luKGxhdCkpIDogbGF0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBrID0gdGhpcy5uICogTWF0aC5zaW4obGF0KTtcbiAgICAgIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7XG4gICAgICAgIHZhciBWID0gKHRoaXMubSAqIGxhdCArIE1hdGguc2luKGxhdCkgLSBrKSAvICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcbiAgICAgICAgbGF0IC09IFY7XG4gICAgICAgIGlmIChNYXRoLmFicyhWKSA8IEVQU0xOKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgeCA9IHRoaXMuYSAqIHRoaXMuQ194ICogbG9uICogKHRoaXMubSArIE1hdGguY29zKGxhdCkpO1xuICAgIHkgPSB0aGlzLmEgKiB0aGlzLkNfeSAqIGxhdDtcblxuICB9XG4gIGVsc2Uge1xuXG4gICAgdmFyIHMgPSBNYXRoLnNpbihsYXQpO1xuICAgIHZhciBjID0gTWF0aC5jb3MobGF0KTtcbiAgICB5ID0gdGhpcy5hICogcGpfbWxmbihsYXQsIHMsIGMsIHRoaXMuZW4pO1xuICAgIHggPSB0aGlzLmEgKiBsb24gKiBjIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogcyAqIHMpO1xuICB9XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsYXQsIHRlbXAsIGxvbiwgcztcblxuICBwLnggLT0gdGhpcy54MDtcbiAgbG9uID0gcC54IC8gdGhpcy5hO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgbGF0ID0gcC55IC8gdGhpcy5hO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxhdCAvPSB0aGlzLkNfeTtcbiAgICBsb24gPSBsb24gLyAodGhpcy5DX3ggKiAodGhpcy5tICsgTWF0aC5jb3MobGF0KSkpO1xuICAgIGlmICh0aGlzLm0pIHtcbiAgICAgIGxhdCA9IGFzaW56KCh0aGlzLm0gKiBsYXQgKyBNYXRoLnNpbihsYXQpKSAvIHRoaXMubik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubiAhPT0gMSkge1xuICAgICAgbGF0ID0gYXNpbnooTWF0aC5zaW4obGF0KSAvIHRoaXMubik7XG4gICAgfVxuICAgIGxvbiA9IGFkanVzdF9sb24obG9uICsgdGhpcy5sb25nMCk7XG4gICAgbGF0ID0gYWRqdXN0X2xhdChsYXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHBqX2ludl9tbGZuKHAueSAvIHRoaXMuYSwgdGhpcy5lcywgdGhpcy5lbik7XG4gICAgcyA9IE1hdGguYWJzKGxhdCk7XG4gICAgaWYgKHMgPCBIQUxGX1BJKSB7XG4gICAgICBzID0gTWF0aC5zaW4obGF0KTtcbiAgICAgIHRlbXAgPSB0aGlzLmxvbmcwICsgcC54ICogTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogcyAqIHMpIC8gKHRoaXMuYSAqIE1hdGguY29zKGxhdCkpO1xuICAgICAgLy90ZW1wID0gdGhpcy5sb25nMCArIHAueCAvICh0aGlzLmEgKiBNYXRoLmNvcyhsYXQpKTtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGVtcCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzIC0gRVBTTE4pIDwgSEFMRl9QSSkge1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICB9XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJTaW51c29pZGFsXCIsIFwic2ludVwiXTtcbn0se1wiLi4vY29tbW9uL2FkanVzdF9sYXRcIjo0LFwiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2FzaW56XCI6NixcIi4uL2NvbW1vbi9wal9lbmZuXCI6MTcsXCIuLi9jb21tb24vcGpfaW52X21sZm5cIjoxOCxcIi4uL2NvbW1vbi9wal9tbGZuXCI6MTl9XSw1OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICByZWZlcmVuY2VzOlxuICAgIEZvcm11bGVzIGV0IGNvbnN0YW50ZXMgcG91ciBsZSBDYWxjdWwgcG91ciBsYVxuICAgIHByb2plY3Rpb24gY3lsaW5kcmlxdWUgY29uZm9ybWUgw6AgYXhlIG9ibGlxdWUgZXQgcG91ciBsYSB0cmFuc2Zvcm1hdGlvbiBlbnRyZVxuICAgIGRlcyBzeXN0w6htZXMgZGUgcsOpZsOpcmVuY2UuXG4gICAgaHR0cDovL3d3dy5zd2lzc3RvcG8uYWRtaW4uY2gvaW50ZXJuZXQvc3dpc3N0b3BvL2ZyL2hvbWUvdG9waWNzL3N1cnZleS9zeXMvcmVmc3lzL3N3aXR6ZXJsYW5kLnBhcnN5c3JlbGF0ZWQxLjMxMjE2LmRvd25sb2FkTGlzdC43NzAwNC5Eb3dubG9hZEZpbGUudG1wL3N3aXNzcHJvamVjdGlvbmZyLnBkZlxuICAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwaHkwID0gdGhpcy5sYXQwO1xuICB0aGlzLmxhbWJkYTAgPSB0aGlzLmxvbmcwO1xuICB2YXIgc2luUGh5MCA9IE1hdGguc2luKHBoeTApO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IHRoaXMuYTtcbiAgdmFyIGludkYgPSB0aGlzLnJmO1xuICB2YXIgZmxhdHRlbmluZyA9IDEgLyBpbnZGO1xuICB2YXIgZTIgPSAyICogZmxhdHRlbmluZyAtIE1hdGgucG93KGZsYXR0ZW5pbmcsIDIpO1xuICB2YXIgZSA9IHRoaXMuZSA9IE1hdGguc3FydChlMik7XG4gIHRoaXMuUiA9IHRoaXMuazAgKiBzZW1pTWFqb3JBeGlzICogTWF0aC5zcXJ0KDEgLSBlMikgLyAoMSAtIGUyICogTWF0aC5wb3coc2luUGh5MCwgMikpO1xuICB0aGlzLmFscGhhID0gTWF0aC5zcXJ0KDEgKyBlMiAvICgxIC0gZTIpICogTWF0aC5wb3coTWF0aC5jb3MocGh5MCksIDQpKTtcbiAgdGhpcy5iMCA9IE1hdGguYXNpbihzaW5QaHkwIC8gdGhpcy5hbHBoYSk7XG4gIHZhciBrMSA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgdGhpcy5iMCAvIDIpKTtcbiAgdmFyIGsyID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkwIC8gMikpO1xuICB2YXIgazMgPSBNYXRoLmxvZygoMSArIGUgKiBzaW5QaHkwKSAvICgxIC0gZSAqIHNpblBoeTApKTtcbiAgdGhpcy5LID0gazEgLSB0aGlzLmFscGhhICogazIgKyB0aGlzLmFscGhhICogZSAvIDIgKiBrMztcbn07XG5cblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgU2ExID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgLSBwLnkgLyAyKSk7XG4gIHZhciBTYTIgPSB0aGlzLmUgLyAyICogTWF0aC5sb2coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihwLnkpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4ocC55KSkpO1xuICB2YXIgUyA9IC10aGlzLmFscGhhICogKFNhMSArIFNhMikgKyB0aGlzLks7XG5cbiAgLy8gc3BoZXJpYyBsYXRpdHVkZVxuICB2YXIgYiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyA0KTtcblxuICAvLyBzcGhlcmljIGxvbmdpdHVkZVxuICB2YXIgSSA9IHRoaXMuYWxwaGEgKiAocC54IC0gdGhpcy5sYW1iZGEwKTtcblxuICAvLyBwc29ldWRvIGVxdWF0b3JpYWwgcm90YXRpb25cbiAgdmFyIHJvdEkgPSBNYXRoLmF0YW4oTWF0aC5zaW4oSSkgLyAoTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLnRhbihiKSArIE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3MoSSkpKTtcblxuICB2YXIgcm90QiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKGIpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhiKSAqIE1hdGguY29zKEkpKTtcblxuICBwLnkgPSB0aGlzLlIgLyAyICogTWF0aC5sb2coKDEgKyBNYXRoLnNpbihyb3RCKSkgLyAoMSAtIE1hdGguc2luKHJvdEIpKSkgKyB0aGlzLnkwO1xuICBwLnggPSB0aGlzLlIgKiByb3RJICsgdGhpcy54MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBZID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIFggPSBwLnkgLSB0aGlzLnkwO1xuXG4gIHZhciByb3RJID0gWSAvIHRoaXMuUjtcbiAgdmFyIHJvdEIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChYIC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgdmFyIGIgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLnNpbihyb3RCKSArIE1hdGguc2luKHRoaXMuYjApICogTWF0aC5jb3Mocm90QikgKiBNYXRoLmNvcyhyb3RJKSk7XG4gIHZhciBJID0gTWF0aC5hdGFuKE1hdGguc2luKHJvdEkpIC8gKE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3Mocm90SSkgLSBNYXRoLnNpbih0aGlzLmIwKSAqIE1hdGgudGFuKHJvdEIpKSk7XG5cbiAgdmFyIGxhbWJkYSA9IHRoaXMubGFtYmRhMCArIEkgLyB0aGlzLmFscGhhO1xuXG4gIHZhciBTID0gMDtcbiAgdmFyIHBoeSA9IGI7XG4gIHZhciBwcmV2UGh5ID0gLTEwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB3aGlsZSAoTWF0aC5hYnMocGh5IC0gcHJldlBoeSkgPiAwLjAwMDAwMDEpIHtcbiAgICBpZiAoKytpdGVyYXRpb24gPiAyMCkge1xuICAgICAgLy8uLi5yZXBvcnRFcnJvcihcIm9tZXJjRndkSW5maW5pdHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vUyA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5IC8gMikpO1xuICAgIFMgPSAxIC8gdGhpcy5hbHBoYSAqIChNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGIgLyAyKSkgLSB0aGlzLkspICsgdGhpcy5lICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBNYXRoLmFzaW4odGhpcy5lICogTWF0aC5zaW4ocGh5KSkgLyAyKSk7XG4gICAgcHJldlBoeSA9IHBoeTtcbiAgICBwaHkgPSAyICogTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyAyO1xuICB9XG5cbiAgcC54ID0gbGFtYmRhO1xuICBwLnkgPSBwaHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcInNvbWVyY1wiXTtcblxufSx7fV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIHNpZ24gPSBfZGVyZXFfKCcuLi9jb21tb24vc2lnbicpO1xudmFyIG1zZm56ID0gX2RlcmVxXygnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgdHNmbnogPSBfZGVyZXFfKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBwaGkyeiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9waGkyeicpO1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5zc2ZuXyA9IGZ1bmN0aW9uKHBoaXQsIHNpbnBoaSwgZWNjZW4pIHtcbiAgc2lucGhpICo9IGVjY2VuO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgcGhpdCkpICogTWF0aC5wb3coKDEgLSBzaW5waGkpIC8gKDEgKyBzaW5waGkpLCAwLjUgKiBlY2NlbikpO1xufTtcblxuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29zbGF0MCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIHRoaXMuc2lubGF0MCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmICh0aGlzLmswID09PSAxICYmICFpc05hTih0aGlzLmxhdF90cykgJiYgTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdGhpcy5rMCA9IDAuNSAqICgxICsgc2lnbih0aGlzLmxhdDApICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG4gICAgICAgIC8vTm9ydGggcG9sZVxuICAgICAgICAvL3RyYWNlKCdzdGVyZTpub3J0aCBwb2xlJyk7XG4gICAgICAgIHRoaXMuY29uID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvL1NvdXRoIHBvbGVcbiAgICAgICAgLy90cmFjZSgnc3RlcmU6c291dGggcG9sZScpO1xuICAgICAgICB0aGlzLmNvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnMgPSBNYXRoLnNxcnQoTWF0aC5wb3coMSArIHRoaXMuZSwgMSArIHRoaXMuZSkgKiBNYXRoLnBvdygxIC0gdGhpcy5lLCAxIC0gdGhpcy5lKSk7XG4gICAgaWYgKHRoaXMuazAgPT09IDEgJiYgIWlzTmFOKHRoaXMubGF0X3RzKSAmJiBNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0aGlzLmswID0gMC41ICogdGhpcy5jb25zICogbXNmbnoodGhpcy5lLCBNYXRoLnNpbih0aGlzLmxhdF90cyksIE1hdGguY29zKHRoaXMubGF0X3RzKSkgLyB0c2Zueih0aGlzLmUsIHRoaXMuY29uICogdGhpcy5sYXRfdHMsIHRoaXMuY29uICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gICAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lubGF0MCwgdGhpcy5jb3NsYXQwKTtcbiAgICB0aGlzLlgwID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKHRoaXMubGF0MCwgdGhpcy5zaW5sYXQwLCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgdGhpcy5jb3NYMCA9IE1hdGguY29zKHRoaXMuWDApO1xuICAgIHRoaXMuc2luWDAgPSBNYXRoLnNpbih0aGlzLlgwKTtcbiAgfVxufTtcblxuLy8gU3RlcmVvZ3JhcGhpYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbmxhdCA9IE1hdGguc2luKGxhdCk7XG4gIHZhciBjb3NsYXQgPSBNYXRoLmNvcyhsYXQpO1xuICB2YXIgQSwgWCwgc2luWCwgY29zWCwgdHMsIHJoO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxvbiAtIHRoaXMubG9uZzApIC0gTWF0aC5QSSkgPD0gRVBTTE4gJiYgTWF0aC5hYnMobGF0ICsgdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuICAgIC8vY2FzZSBvZiB0aGUgb3JpZ2luZSBwb2ludFxuICAgIC8vdHJhY2UoJ3N0ZXJlOnRoaXMgaXMgdGhlIG9yaWdpbiBwb2ludCcpO1xuICAgIHAueCA9IE5hTjtcbiAgICBwLnkgPSBOYU47XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgLy90cmFjZSgnc3RlcmU6c3BoZXJlIGNhc2UnKTtcbiAgICBBID0gMiAqIHRoaXMuazAgLyAoMSArIHRoaXMuc2lubGF0MCAqIHNpbmxhdCArIHRoaXMuY29zbGF0MCAqIGNvc2xhdCAqIE1hdGguY29zKGRsb24pKTtcbiAgICBwLnggPSB0aGlzLmEgKiBBICogY29zbGF0ICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuICAgIHAueSA9IHRoaXMuYSAqIEEgKiAodGhpcy5jb3NsYXQwICogc2lubGF0IC0gdGhpcy5zaW5sYXQwICogY29zbGF0ICogTWF0aC5jb3MoZGxvbikpICsgdGhpcy55MDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBYID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKGxhdCwgc2lubGF0LCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgY29zWCA9IE1hdGguY29zKFgpO1xuICAgIHNpblggPSBNYXRoLnNpbihYKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCAqIHRoaXMuY29uLCB0aGlzLmNvbiAqIHNpbmxhdCk7XG4gICAgICByaCA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdHMgLyB0aGlzLmNvbnM7XG4gICAgICBwLnggPSB0aGlzLngwICsgcmggKiBNYXRoLnNpbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmNvbiAqIHJoICogTWF0aC5jb3MobG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5sYXQwKSA8IEVQU0xOKSB7XG4gICAgICAvL0VxXG4gICAgICAvL3RyYWNlKCdzdGVyZTplcXVhdGV1cicpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswIC8gKDEgKyBjb3NYICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgcC55ID0gQSAqIHNpblg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9vdGhlciBjYXNlXG4gICAgICAvL3RyYWNlKCdzdGVyZTpub3JtYWwgY2FzZScpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdGhpcy5tczEgLyAodGhpcy5jb3NYMCAqICgxICsgdGhpcy5zaW5YMCAqIHNpblggKyB0aGlzLmNvc1gwICogY29zWCAqIE1hdGguY29zKGRsb24pKSk7XG4gICAgICBwLnkgPSBBICogKHRoaXMuY29zWDAgKiBzaW5YIC0gdGhpcy5zaW5YMCAqIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuICAgIH1cbiAgICBwLnggPSBBICogY29zWCAqIE1hdGguc2luKGRsb24pICsgdGhpcy54MDtcbiAgfVxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xufTtcblxuXG4vLyogU3RlcmVvZ3JhcGhpYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQsIHRzLCBjZSwgQ2hpO1xuICB2YXIgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGMgPSAyICogTWF0aC5hdGFuKHJoIC8gKDAuNSAqIHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBsYXQgPSBNYXRoLmFzaW4oTWF0aC5jb3MoYykgKiB0aGlzLnNpbmxhdDAgKyBwLnkgKiBNYXRoLnNpbihjKSAqIHRoaXMuY29zbGF0MCAvIHJoKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8IEVQU0xOKSB7XG4gICAgICBpZiAodGhpcy5sYXQwID4gMCkge1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIHAueSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogTWF0aC5zaW4oYyksIHJoICogdGhpcy5jb3NsYXQwICogTWF0aC5jb3MoYykgLSBwLnkgKiB0aGlzLnNpbmxhdDAgKiBNYXRoLnNpbihjKSkpO1xuICAgIH1cbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgICAgbGF0ID0gdGhpcy5sYXQwO1xuICAgICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgICBwLnggPSBsb247XG4gICAgICAgIHAueSA9IGxhdDtcbiAgICAgICAgLy90cmFjZShwLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHAueCAqPSB0aGlzLmNvbjtcbiAgICAgIHAueSAqPSB0aGlzLmNvbjtcbiAgICAgIHRzID0gcmggKiB0aGlzLmNvbnMgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazApO1xuICAgICAgbGF0ID0gdGhpcy5jb24gKiBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICAgIGxvbiA9IHRoaXMuY29uICogYWRqdXN0X2xvbih0aGlzLmNvbiAqIHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2UgPSAyICogTWF0aC5hdGFuKHJoICogdGhpcy5jb3NYMCAvICgyICogdGhpcy5hICogdGhpcy5rMCAqIHRoaXMubXMxKSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgaWYgKHJoIDw9IEVQU0xOKSB7XG4gICAgICAgIENoaSA9IHRoaXMuWDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgQ2hpID0gTWF0aC5hc2luKE1hdGguY29zKGNlKSAqIHRoaXMuc2luWDAgKyBwLnkgKiBNYXRoLnNpbihjZSkgKiB0aGlzLmNvc1gwIC8gcmgpO1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCAqIE1hdGguc2luKGNlKSwgcmggKiB0aGlzLmNvc1gwICogTWF0aC5jb3MoY2UpIC0gcC55ICogdGhpcy5zaW5YMCAqIE1hdGguc2luKGNlKSkpO1xuICAgICAgfVxuICAgICAgbGF0ID0gLTEgKiBwaGkyeih0aGlzLmUsIE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgQ2hpKSkpO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xuXG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcInN0ZXJlXCIsIFwiU3RlcmVvZ3JhcGhpY19Tb3V0aF9Qb2xlXCIsIFwiUG9sYXIgU3RlcmVvZ3JhcGhpYyAodmFyaWFudCBCKVwiXTtcblxufSx7XCIuLi9jb21tb24vYWRqdXN0X2xvblwiOjUsXCIuLi9jb21tb24vbXNmbnpcIjoxNSxcIi4uL2NvbW1vbi9waGkyelwiOjE2LFwiLi4vY29tbW9uL3NpZ25cIjoyMSxcIi4uL2NvbW1vbi90c2ZuelwiOjI0fV0sNjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdhdXNzID0gX2RlcmVxXygnLi9nYXVzcycpO1xudmFyIGFkanVzdF9sb24gPSBfZGVyZXFfKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGdhdXNzLmluaXQuYXBwbHkodGhpcyk7XG4gIGlmICghdGhpcy5yYykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNpbmMwID0gTWF0aC5zaW4odGhpcy5waGljMCk7XG4gIHRoaXMuY29zYzAgPSBNYXRoLmNvcyh0aGlzLnBoaWMwKTtcbiAgdGhpcy5SMiA9IDIgKiB0aGlzLnJjO1xuICBpZiAoIXRoaXMudGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gXCJPYmxpcXVlIFN0ZXJlb2dyYXBoaWMgQWx0ZXJuYXRpdmVcIjtcbiAgfVxufTtcblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgc2luYywgY29zYywgY29zbCwgaztcbiAgcC54ID0gYWRqdXN0X2xvbihwLnggLSB0aGlzLmxvbmcwKTtcbiAgZ2F1c3MuZm9yd2FyZC5hcHBseSh0aGlzLCBbcF0pO1xuICBzaW5jID0gTWF0aC5zaW4ocC55KTtcbiAgY29zYyA9IE1hdGguY29zKHAueSk7XG4gIGNvc2wgPSBNYXRoLmNvcyhwLngpO1xuICBrID0gdGhpcy5rMCAqIHRoaXMuUjIgLyAoMSArIHRoaXMuc2luYzAgKiBzaW5jICsgdGhpcy5jb3NjMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gayAqIGNvc2MgKiBNYXRoLnNpbihwLngpO1xuICBwLnkgPSBrICogKHRoaXMuY29zYzAgKiBzaW5jIC0gdGhpcy5zaW5jMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gdGhpcy5hICogcC54ICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5hICogcC55ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBzaW5jLCBjb3NjLCBsb24sIGxhdCwgcmhvO1xuICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG4gIHAueSA9IChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuYTtcblxuICBwLnggLz0gdGhpcy5rMDtcbiAgcC55IC89IHRoaXMuazA7XG4gIGlmICgocmhvID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSkpKSB7XG4gICAgdmFyIGMgPSAyICogTWF0aC5hdGFuMihyaG8sIHRoaXMuUjIpO1xuICAgIHNpbmMgPSBNYXRoLnNpbihjKTtcbiAgICBjb3NjID0gTWF0aC5jb3MoYyk7XG4gICAgbGF0ID0gTWF0aC5hc2luKGNvc2MgKiB0aGlzLnNpbmMwICsgcC55ICogc2luYyAqIHRoaXMuY29zYzAgLyByaG8pO1xuICAgIGxvbiA9IE1hdGguYXRhbjIocC54ICogc2luYywgcmhvICogdGhpcy5jb3NjMCAqIGNvc2MgLSBwLnkgKiB0aGlzLnNpbmMwICogc2luYyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gdGhpcy5waGljMDtcbiAgICBsb24gPSAwO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIGdhdXNzLmludmVyc2UuYXBwbHkodGhpcywgW3BdKTtcbiAgcC54ID0gYWRqdXN0X2xvbihwLnggKyB0aGlzLmxvbmcwKTtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiU3RlcmVvZ3JhcGhpY19Ob3J0aF9Qb2xlXCIsIFwiT2JsaXF1ZV9TdGVyZW9ncmFwaGljXCIsIFwiUG9sYXJfU3RlcmVvZ3JhcGhpY1wiLCBcInN0ZXJlYVwiLFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCJdO1xuXG59LHtcIi4uL2NvbW1vbi9hZGp1c3RfbG9uXCI6NSxcIi4vZ2F1c3NcIjo0Nn1dLDYyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBlMGZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gX2RlcmVxXygnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtbGZuID0gX2RlcmVxXygnLi4vY29tbW9uL21sZm4nKTtcbnZhciBhZGp1c3RfbG9uID0gX2RlcmVxXygnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBzaWduID0gX2RlcmVxXygnLi4vY29tbW9uL3NpZ24nKTtcbnZhciBhc2lueiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hc2lueicpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gIHRoaXMubWwwID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBGb3J3YXJkICAtIGxvbmcvbGF0IHRvIHgveVxuICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcbiAgKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGNvbjtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBiID0gY29zX3BoaSAqIE1hdGguc2luKGRlbHRhX2xvbik7XG4gICAgaWYgKChNYXRoLmFicyhNYXRoLmFicyhiKSAtIDEpKSA8IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuICg5Myk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeCA9IDAuNSAqIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZygoMSArIGIpIC8gKDEgLSBiKSk7XG4gICAgICBjb24gPSBNYXRoLmFjb3MoY29zX3BoaSAqIE1hdGguY29zKGRlbHRhX2xvbikgLyBNYXRoLnNxcnQoMSAtIGIgKiBiKSk7XG4gICAgICBpZiAobGF0IDwgMCkge1xuICAgICAgICBjb24gPSAtY29uO1xuICAgICAgfVxuICAgICAgeSA9IHRoaXMuYSAqIHRoaXMuazAgKiAoY29uIC0gdGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGFsID0gY29zX3BoaSAqIGRlbHRhX2xvbjtcbiAgICB2YXIgYWxzID0gTWF0aC5wb3coYWwsIDIpO1xuICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcbiAgICB2YXIgdHEgPSBNYXRoLnRhbihsYXQpO1xuICAgIHZhciB0ID0gTWF0aC5wb3codHEsIDIpO1xuICAgIGNvbiA9IDEgLSB0aGlzLmVzICogTWF0aC5wb3coc2luX3BoaSwgMik7XG4gICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICB2YXIgbWwgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCk7XG5cbiAgICB4ID0gdGhpcy5rMCAqIG4gKiBhbCAqICgxICsgYWxzIC8gNiAqICgxIC0gdCArIGMgKyBhbHMgLyAyMCAqICg1IC0gMTggKiB0ICsgTWF0aC5wb3codCwgMikgKyA3MiAqIGMgLSA1OCAqIHRoaXMuZXAyKSkpICsgdGhpcy54MDtcbiAgICB5ID0gdGhpcy5rMCAqIChtbCAtIHRoaXMubWwwICsgbiAqIHRxICogKGFscyAqICgwLjUgKyBhbHMgLyAyNCAqICg1IC0gdCArIDkgKiBjICsgNCAqIE1hdGgucG93KGMsIDIpICsgYWxzIC8gMzAgKiAoNjEgLSA1OCAqIHQgKyBNYXRoLnBvdyh0LCAyKSArIDYwMCAqIGMgLSAzMzAgKiB0aGlzLmVwMikpKSkpICsgdGhpcy55MDtcblxuICB9XG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGNvbiwgcGhpO1xuICB2YXIgZGVsdGFfcGhpO1xuICB2YXIgaTtcbiAgdmFyIG1heF9pdGVyID0gNjtcbiAgdmFyIGxhdCwgbG9uO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBmID0gTWF0aC5leHAocC54IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICB2YXIgZyA9IDAuNSAqIChmIC0gMSAvIGYpO1xuICAgIHZhciB0ZW1wID0gdGhpcy5sYXQwICsgcC55IC8gKHRoaXMuYSAqIHRoaXMuazApO1xuICAgIHZhciBoID0gTWF0aC5jb3ModGVtcCk7XG4gICAgY29uID0gTWF0aC5zcXJ0KCgxIC0gaCAqIGgpIC8gKDEgKyBnICogZykpO1xuICAgIGxhdCA9IGFzaW56KGNvbik7XG4gICAgaWYgKHRlbXAgPCAwKSB7XG4gICAgICBsYXQgPSAtbGF0O1xuICAgIH1cbiAgICBpZiAoKGcgPT09IDApICYmIChoID09PSAwKSkge1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKE1hdGguYXRhbjIoZywgaCkgKyB0aGlzLmxvbmcwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGVsbGlwc29pZGFsIGZvcm1cbiAgICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gICAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuXG4gICAgY29uID0gKHRoaXMubWwwICsgeSAvIHRoaXMuazApIC8gdGhpcy5hO1xuICAgIHBoaSA9IGNvbjtcbiAgICBmb3IgKGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICAgIGRlbHRhX3BoaSA9ICgoY29uICsgdGhpcy5lMSAqIE1hdGguc2luKDIgKiBwaGkpIC0gdGhpcy5lMiAqIE1hdGguc2luKDQgKiBwaGkpICsgdGhpcy5lMyAqIE1hdGguc2luKDYgKiBwaGkpKSAvIHRoaXMuZTApIC0gcGhpO1xuICAgICAgcGhpICs9IGRlbHRhX3BoaTtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YV9waGkpIDw9IEVQU0xOKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPj0gbWF4X2l0ZXIpIHtcbiAgICAgICAgcmV0dXJuICg5NSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IoKVxuICAgIGlmIChNYXRoLmFicyhwaGkpIDwgSEFMRl9QSSkge1xuICAgICAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgdmFyIHRhbl9waGkgPSBNYXRoLnRhbihwaGkpO1xuICAgICAgdmFyIGMgPSB0aGlzLmVwMiAqIE1hdGgucG93KGNvc19waGksIDIpO1xuICAgICAgdmFyIGNzID0gTWF0aC5wb3coYywgMik7XG4gICAgICB2YXIgdCA9IE1hdGgucG93KHRhbl9waGksIDIpO1xuICAgICAgdmFyIHRzID0gTWF0aC5wb3codCwgMik7XG4gICAgICBjb24gPSAxIC0gdGhpcy5lcyAqIE1hdGgucG93KHNpbl9waGksIDIpO1xuICAgICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICAgIHZhciByID0gbiAqICgxIC0gdGhpcy5lcykgLyBjb247XG4gICAgICB2YXIgZCA9IHggLyAobiAqIHRoaXMuazApO1xuICAgICAgdmFyIGRzID0gTWF0aC5wb3coZCwgMik7XG4gICAgICBsYXQgPSBwaGkgLSAobiAqIHRhbl9waGkgKiBkcyAvIHIpICogKDAuNSAtIGRzIC8gMjQgKiAoNSArIDMgKiB0ICsgMTAgKiBjIC0gNCAqIGNzIC0gOSAqIHRoaXMuZXAyIC0gZHMgLyAzMCAqICg2MSArIDkwICogdCArIDI5OCAqIGMgKyA0NSAqIHRzIC0gMjUyICogdGhpcy5lcDIgLSAzICogY3MpKSk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoZCAqICgxIC0gZHMgLyA2ICogKDEgKyAyICogdCArIGMgLSBkcyAvIDIwICogKDUgLSAyICogYyArIDI4ICogdCAtIDMgKiBjcyArIDggKiB0aGlzLmVwMiArIDI0ICogdHMpKSkgLyBjb3NfcGhpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGF0ID0gSEFMRl9QSSAqIHNpZ24oeSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlRyYW5zdmVyc2VfTWVyY2F0b3JcIiwgXCJUcmFuc3ZlcnNlIE1lcmNhdG9yXCIsIFwidG1lcmNcIl07XG5cbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2FzaW56XCI6NixcIi4uL2NvbW1vbi9lMGZuXCI6NyxcIi4uL2NvbW1vbi9lMWZuXCI6OCxcIi4uL2NvbW1vbi9lMmZuXCI6OSxcIi4uL2NvbW1vbi9lM2ZuXCI6MTAsXCIuLi9jb21tb24vbWxmblwiOjE0LFwiLi4vY29tbW9uL3NpZ25cIjoyMX1dLDYzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xudmFyIHRtZXJjID0gX2RlcmVxXygnLi90bWVyYycpO1xuZXhwb3J0cy5kZXBlbmRzT24gPSAndG1lcmMnO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy56b25lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGF0MCA9IDA7XG4gIHRoaXMubG9uZzAgPSAoKDYgKiBNYXRoLmFicyh0aGlzLnpvbmUpKSAtIDE4MykgKiBEMlI7XG4gIHRoaXMueDAgPSA1MDAwMDA7XG4gIHRoaXMueTAgPSB0aGlzLnV0bVNvdXRoID8gMTAwMDAwMDAgOiAwO1xuICB0aGlzLmswID0gMC45OTk2O1xuXG4gIHRtZXJjLmluaXQuYXBwbHkodGhpcyk7XG4gIHRoaXMuZm9yd2FyZCA9IHRtZXJjLmZvcndhcmQ7XG4gIHRoaXMuaW52ZXJzZSA9IHRtZXJjLmludmVyc2U7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlVuaXZlcnNhbCBUcmFuc3ZlcnNlIE1lcmNhdG9yIFN5c3RlbVwiLCBcInV0bVwiXTtcblxufSx7XCIuL3RtZXJjXCI6NjJ9XSw2NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYWRqdXN0X2xvbiA9IF9kZXJlcV8oJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgYXNpbnogPSBfZGVyZXFfKCcuLi9jb21tb24vYXNpbnonKTtcbi8qIEluaXRpYWxpemUgdGhlIFZhbiBEZXIgR3JpbnRlbiBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vdGhpcy5SID0gNjM3MDk5NzsgLy9SYWRpdXMgb2YgZWFydGhcbiAgdGhpcy5SID0gdGhpcy5hO1xufTtcblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHgsIHk7XG5cbiAgaWYgKE1hdGguYWJzKGxhdCkgPD0gRVBTTE4pIHtcbiAgICB4ID0gdGhpcy54MCArIHRoaXMuUiAqIGRsb247XG4gICAgeSA9IHRoaXMueTA7XG4gIH1cbiAgdmFyIHRoZXRhID0gYXNpbnooMiAqIE1hdGguYWJzKGxhdCAvIE1hdGguUEkpKTtcbiAgaWYgKChNYXRoLmFicyhkbG9uKSA8PSBFUFNMTikgfHwgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikpIHtcbiAgICB4ID0gdGhpcy54MDtcbiAgICBpZiAobGF0ID49IDApIHtcbiAgICAgIHkgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGgudGFuKDAuNSAqIHRoZXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB5ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiAtTWF0aC50YW4oMC41ICogdGhldGEpO1xuICAgIH1cbiAgICAvLyAgcmV0dXJuKE9LKTtcbiAgfVxuICB2YXIgYWwgPSAwLjUgKiBNYXRoLmFicygoTWF0aC5QSSAvIGRsb24pIC0gKGRsb24gLyBNYXRoLlBJKSk7XG4gIHZhciBhc3EgPSBhbCAqIGFsO1xuICB2YXIgc2ludGggPSBNYXRoLnNpbih0aGV0YSk7XG4gIHZhciBjb3N0aCA9IE1hdGguY29zKHRoZXRhKTtcblxuICB2YXIgZyA9IGNvc3RoIC8gKHNpbnRoICsgY29zdGggLSAxKTtcbiAgdmFyIGdzcSA9IGcgKiBnO1xuICB2YXIgbSA9IGcgKiAoMiAvIHNpbnRoIC0gMSk7XG4gIHZhciBtc3EgPSBtICogbTtcbiAgdmFyIGNvbiA9IE1hdGguUEkgKiB0aGlzLlIgKiAoYWwgKiAoZyAtIG1zcSkgKyBNYXRoLnNxcnQoYXNxICogKGcgLSBtc3EpICogKGcgLSBtc3EpIC0gKG1zcSArIGFzcSkgKiAoZ3NxIC0gbXNxKSkpIC8gKG1zcSArIGFzcSk7XG4gIGlmIChkbG9uIDwgMCkge1xuICAgIGNvbiA9IC1jb247XG4gIH1cbiAgeCA9IHRoaXMueDAgKyBjb247XG4gIC8vY29uID0gTWF0aC5hYnMoY29uIC8gKE1hdGguUEkgKiB0aGlzLlIpKTtcbiAgdmFyIHEgPSBhc3EgKyBnO1xuICBjb24gPSBNYXRoLlBJICogdGhpcy5SICogKG0gKiBxIC0gYWwgKiBNYXRoLnNxcnQoKG1zcSArIGFzcSkgKiAoYXNxICsgMSkgLSBxICogcSkpIC8gKG1zcSArIGFzcSk7XG4gIGlmIChsYXQgPj0gMCkge1xuICAgIC8veSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24gLSAyICogYWwgKiBjb24pO1xuICAgIHkgPSB0aGlzLnkwICsgY29uO1xuICB9XG4gIGVsc2Uge1xuICAgIC8veSA9IHRoaXMueTAgLSBNYXRoLlBJICogdGhpcy5SICogTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24gLSAyICogYWwgKiBjb24pO1xuICAgIHkgPSB0aGlzLnkwIC0gY29uO1xuICB9XG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuLyogVmFuIERlciBHcmludGVuIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uLCBsYXQ7XG4gIHZhciB4eCwgeXksIHh5cywgYzEsIGMyLCBjMztcbiAgdmFyIGExO1xuICB2YXIgbTE7XG4gIHZhciBjb247XG4gIHZhciB0aDE7XG4gIHZhciBkO1xuXG4gIC8qIGludmVyc2UgZXF1YXRpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIGNvbiA9IE1hdGguUEkgKiB0aGlzLlI7XG4gIHh4ID0gcC54IC8gY29uO1xuICB5eSA9IHAueSAvIGNvbjtcbiAgeHlzID0geHggKiB4eCArIHl5ICogeXk7XG4gIGMxID0gLU1hdGguYWJzKHl5KSAqICgxICsgeHlzKTtcbiAgYzIgPSBjMSAtIDIgKiB5eSAqIHl5ICsgeHggKiB4eDtcbiAgYzMgPSAtMiAqIGMxICsgMSArIDIgKiB5eSAqIHl5ICsgeHlzICogeHlzO1xuICBkID0geXkgKiB5eSAvIGMzICsgKDIgKiBjMiAqIGMyICogYzIgLyBjMyAvIGMzIC8gYzMgLSA5ICogYzEgKiBjMiAvIGMzIC8gYzMpIC8gMjc7XG4gIGExID0gKGMxIC0gYzIgKiBjMiAvIDMgLyBjMykgLyBjMztcbiAgbTEgPSAyICogTWF0aC5zcXJ0KC1hMSAvIDMpO1xuICBjb24gPSAoKDMgKiBkKSAvIGExKSAvIG0xO1xuICBpZiAoTWF0aC5hYnMoY29uKSA+IDEpIHtcbiAgICBpZiAoY29uID49IDApIHtcbiAgICAgIGNvbiA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uID0gLTE7XG4gICAgfVxuICB9XG4gIHRoMSA9IE1hdGguYWNvcyhjb24pIC8gMztcbiAgaWYgKHAueSA+PSAwKSB7XG4gICAgbGF0ID0gKC1tMSAqIE1hdGguY29zKHRoMSArIE1hdGguUEkgLyAzKSAtIGMyIC8gMyAvIGMzKSAqIE1hdGguUEk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gLSgtbTEgKiBNYXRoLmNvcyh0aDEgKyBNYXRoLlBJIC8gMykgLSBjMiAvIDMgLyBjMykgKiBNYXRoLlBJO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHh4KSA8IEVQU0xOKSB7XG4gICAgbG9uID0gdGhpcy5sb25nMDtcbiAgfVxuICBlbHNlIHtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLlBJICogKHh5cyAtIDEgKyBNYXRoLnNxcnQoMSArIDIgKiAoeHggKiB4eCAtIHl5ICogeXkpICsgeHlzICogeHlzKSkgLyAyIC8geHgpO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJWYW5fZGVyX0dyaW50ZW5fSVwiLCBcIlZhbkRlckdyaW50ZW5cIiwgXCJ2YW5kZ1wiXTtcbn0se1wiLi4vY29tbW9uL2FkanVzdF9sb25cIjo1LFwiLi4vY29tbW9uL2FzaW56XCI6Nn1dLDY1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xudmFyIFIyRCA9IDU3LjI5NTc3OTUxMzA4MjMyMDg4O1xudmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIGRhdHVtX3RyYW5zZm9ybSA9IF9kZXJlcV8oJy4vZGF0dW1fdHJhbnNmb3JtJyk7XG52YXIgYWRqdXN0X2F4aXMgPSBfZGVyZXFfKCcuL2FkanVzdF9heGlzJyk7XG52YXIgcHJvaiA9IF9kZXJlcV8oJy4vUHJvaicpO1xudmFyIHRvUG9pbnQgPSBfZGVyZXFfKCcuL2NvbW1vbi90b1BvaW50Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzb3VyY2UsIGRlc3QsIHBvaW50KSB7XG4gIHZhciB3Z3M4NDtcbiAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnQpKSB7XG4gICAgcG9pbnQgPSB0b1BvaW50KHBvaW50KTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpIHtcbiAgICByZXR1cm4gKChzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSB8fCBzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkgJiYgZGVzdC5kYXR1bUNvZGUgIT09IFwiV0dTODRcIik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBkYXR1bSBzaGlmdHMgdG93Z3M4NCwgaWYgZWl0aGVyIHNvdXJjZSBvciBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIGlzIG5vdCB3Z3M4NFxuICBpZiAoc291cmNlLmRhdHVtICYmIGRlc3QuZGF0dW0gJiYgKGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkgfHwgY2hlY2tOb3RXR1MoZGVzdCwgc291cmNlKSkpIHtcbiAgICB3Z3M4NCA9IG5ldyBwcm9qKCdXR1M4NCcpO1xuICAgIHRyYW5zZm9ybShzb3VyY2UsIHdnczg0LCBwb2ludCk7XG4gICAgc291cmNlID0gd2dzODQ7XG4gIH1cbiAgLy8gREdSLCAyMDEwLzExLzEyXG4gIGlmIChzb3VyY2UuYXhpcyAhPT0gXCJlbnVcIikge1xuICAgIGFkanVzdF9heGlzKHNvdXJjZSwgZmFsc2UsIHBvaW50KTtcbiAgfVxuICAvLyBUcmFuc2Zvcm0gc291cmNlIHBvaW50cyB0byBsb25nL2xhdCwgaWYgdGhleSBhcmVuJ3QgYWxyZWFkeS5cbiAgaWYgKHNvdXJjZS5wcm9qTmFtZSA9PT0gXCJsb25nbGF0XCIpIHtcbiAgICBwb2ludC54ICo9IEQyUjsgLy8gY29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICBwb2ludC55ICo9IEQyUjtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoc291cmNlLnRvX21ldGVyKSB7XG4gICAgICBwb2ludC54ICo9IHNvdXJjZS50b19tZXRlcjtcbiAgICAgIHBvaW50LnkgKj0gc291cmNlLnRvX21ldGVyO1xuICAgIH1cbiAgICBzb3VyY2UuaW52ZXJzZShwb2ludCk7IC8vIENvbnZlcnQgQ2FydGVzaWFuIHRvIGxvbmdsYXRcbiAgfVxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKHNvdXJjZS5mcm9tX2dyZWVud2ljaCkge1xuICAgIHBvaW50LnggKz0gc291cmNlLmZyb21fZ3JlZW53aWNoO1xuICB9XG5cbiAgLy8gQ29udmVydCBkYXR1bXMgaWYgbmVlZGVkLCBhbmQgaWYgcG9zc2libGUuXG4gIHBvaW50ID0gZGF0dW1fdHJhbnNmb3JtKHNvdXJjZS5kYXR1bSwgZGVzdC5kYXR1bSwgcG9pbnQpO1xuXG4gIC8vIEFkanVzdCBmb3IgdGhlIHByaW1lIG1lcmlkaWFuIGlmIG5lY2Vzc2FyeVxuICBpZiAoZGVzdC5mcm9tX2dyZWVud2ljaCkge1xuICAgIHBvaW50LnggLT0gZGVzdC5mcm9tX2dyZWVud2ljaDtcbiAgfVxuXG4gIGlmIChkZXN0LnByb2pOYW1lID09PSBcImxvbmdsYXRcIikge1xuICAgIC8vIGNvbnZlcnQgcmFkaWFucyB0byBkZWNpbWFsIGRlZ3JlZXNcbiAgICBwb2ludC54ICo9IFIyRDtcbiAgICBwb2ludC55ICo9IFIyRDtcbiAgfVxuICBlbHNlIHsgLy8gZWxzZSBwcm9qZWN0XG4gICAgZGVzdC5mb3J3YXJkKHBvaW50KTtcbiAgICBpZiAoZGVzdC50b19tZXRlcikge1xuICAgICAgcG9pbnQueCAvPSBkZXN0LnRvX21ldGVyO1xuICAgICAgcG9pbnQueSAvPSBkZXN0LnRvX21ldGVyO1xuICAgIH1cbiAgfVxuXG4gIC8vIERHUiwgMjAxMC8xMS8xMlxuICBpZiAoZGVzdC5heGlzICE9PSBcImVudVwiKSB7XG4gICAgYWRqdXN0X2F4aXMoZGVzdCwgdHJ1ZSwgcG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50O1xufTtcbn0se1wiLi9Qcm9qXCI6MixcIi4vYWRqdXN0X2F4aXNcIjozLFwiLi9jb21tb24vdG9Qb2ludFwiOjIzLFwiLi9kYXR1bV90cmFuc2Zvcm1cIjozMX1dLDY2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEMlIgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc3O1xudmFyIGV4dGVuZCA9IF9kZXJlcV8oJy4vZXh0ZW5kJyk7XG5cbmZ1bmN0aW9uIG1hcGl0KG9iaiwga2V5LCB2KSB7XG4gIG9ialtrZXldID0gdi5tYXAoZnVuY3Rpb24oYWEpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIHNFeHByKGFhLCBvKTtcbiAgICByZXR1cm4gbztcbiAgfSkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXh0ZW5kKGEsIGIpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHNFeHByKHYsIG9iaikge1xuICB2YXIga2V5O1xuICBpZiAoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICBvYmpbdl0gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICBlbHNlIHtcbiAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gICAgaWYgKGtleSA9PT0gJ1BBUkFNRVRFUicpIHtcbiAgICAgIGtleSA9IHYuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKHYubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2WzBdKSkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICBzRXhwcih2WzBdLCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2WzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghdi5sZW5ndGgpIHtcbiAgICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnVE9XR1M4NCcpIHtcbiAgICAgIG9ialtrZXldID0gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgaWYgKFsnVU5JVCcsICdQUklNRU0nLCAnVkVSVF9EQVRVTSddLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIG5hbWU6IHZbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBjb252ZXJ0OiB2WzFdXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIG9ialtrZXldLmF1dGggPSB2WzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdTUEhFUk9JRCcpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgbmFtZTogdlswXSxcbiAgICAgICAgICBhOiB2WzFdLFxuICAgICAgICAgIHJmOiB2WzJdXG4gICAgICAgIH07XG4gICAgICAgIGlmICh2Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIG9ialtrZXldLmF1dGggPSB2WzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChbJ0dFT0dDUycsICdHRU9DQ1MnLCAnREFUVU0nLCAnVkVSVF9DUycsICdDT01QRF9DUycsICdMT0NBTF9DUycsICdGSVRURURfQ1MnLCAnTE9DQUxfREFUVU0nXS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICB2WzBdID0gWyduYW1lJywgdlswXV07XG4gICAgICAgIG1hcGl0KG9iaiwga2V5LCB2KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYuZXZlcnkoZnVuY3Rpb24oYWEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYWEpO1xuICAgICAgfSkpIHtcbiAgICAgICAgbWFwaXQob2JqLCBrZXksIHYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNFeHByKHYsIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuYW1lKG9iaiwgcGFyYW1zKSB7XG4gIHZhciBvdXROYW1lID0gcGFyYW1zWzBdO1xuICB2YXIgaW5OYW1lID0gcGFyYW1zWzFdO1xuICBpZiAoIShvdXROYW1lIGluIG9iaikgJiYgKGluTmFtZSBpbiBvYmopKSB7XG4gICAgb2JqW291dE5hbWVdID0gb2JqW2luTmFtZV07XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIG9ialtvdXROYW1lXSA9IHBhcmFtc1syXShvYmpbb3V0TmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkMnIoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0ICogRDJSO1xufVxuXG5mdW5jdGlvbiBjbGVhbldLVCh3a3QpIHtcbiAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuICAgIHdrdC5wcm9qTmFtZSA9ICdsb25nbGF0JztcbiAgfVxuICBlbHNlIGlmICh3a3QudHlwZSA9PT0gJ0xPQ0FMX0NTJykge1xuICAgIHdrdC5wcm9qTmFtZSA9ICdpZGVudGl0eSc7XG4gICAgd2t0LmxvY2FsID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHdrdC5QUk9KRUNUSU9OID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB3a3QucHJvak5hbWUgPSBPYmplY3Qua2V5cyh3a3QuUFJPSkVDVElPTilbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2t0LnByb2pOYW1lID0gd2t0LlBST0pFQ1RJT047XG4gICAgfVxuICB9XG4gIGlmICh3a3QuVU5JVCkge1xuICAgIHdrdC51bml0cyA9IHdrdC5VTklULm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAod2t0LnVuaXRzID09PSAnbWV0cmUnKSB7XG4gICAgICB3a3QudW5pdHMgPSAnbWV0ZXInO1xuICAgIH1cbiAgICBpZiAod2t0LlVOSVQuY29udmVydCkge1xuICAgICAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuICAgICAgICBpZiAod2t0LkRBVFVNICYmIHdrdC5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgICAgIHdrdC50b19tZXRlciA9IHBhcnNlRmxvYXQod2t0LlVOSVQuY29udmVydCwgMTApKndrdC5EQVRVTS5TUEhFUk9JRC5hO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3a3QudG9fbWV0ZXIgPSBwYXJzZUZsb2F0KHdrdC5VTklULmNvbnZlcnQsIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAod2t0LkdFT0dDUykge1xuICAgIC8vaWYod2t0LkdFT0dDUy5QUklNRU0mJndrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQpe1xuICAgIC8vICB3a3QuZnJvbV9ncmVlbndpY2g9d2t0LkdFT0dDUy5QUklNRU0uY29udmVydCpEMlI7XG4gICAgLy99XG4gICAgaWYgKHdrdC5HRU9HQ1MuREFUVU0pIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuR0VPR0NTLkRBVFVNLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LkdFT0dDUy5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICh3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIDIpID09PSAnZF8nKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF9nZW9kZXRpY19kYXR1bV8xOTQ5JyB8fCB3a3QuZGF0dW1Db2RlID09PSAnbmV3X3plYWxhbmRfMTk0OScpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnbnpnZDQ5JztcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUgPT09IFwid2dzXzE5ODRcIikge1xuICAgICAgaWYgKHdrdC5QUk9KRUNUSU9OID09PSAnTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZScpIHtcbiAgICAgICAgd2t0LnNwaGVyZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB3a3QuZGF0dW1Db2RlID0gJ3dnczg0JztcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTYpID09PSAnX2ZlcnJvJykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgLSA2KTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTgpID09PSAnX2pha2FydGEnKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDgpO1xuICAgIH1cbiAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignYmVsZ2UnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IFwicm5iNzJcIjtcbiAgICB9XG4gICAgaWYgKHdrdC5HRU9HQ1MuREFUVU0gJiYgd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRCkge1xuICAgICAgd2t0LmVsbHBzID0gd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRC5uYW1lLnJlcGxhY2UoJ18xOScsICcnKS5yZXBsYWNlKC9bQ2NdbGFya2VcXF8xOC8sICdjbHJrJyk7XG4gICAgICBpZiAod2t0LmVsbHBzLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgMTMpID09PSBcImludGVybmF0aW9uYWxcIikge1xuICAgICAgICB3a3QuZWxscHMgPSAnaW50bCc7XG4gICAgICB9XG5cbiAgICAgIHdrdC5hID0gd2t0LkdFT0dDUy5EQVRVTS5TUEhFUk9JRC5hO1xuICAgICAgd2t0LnJmID0gcGFyc2VGbG9hdCh3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELnJmLCAxMCk7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdvc2diXzE5MzYnKSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IFwib3NnYjM2XCI7XG4gICAgfVxuICB9XG4gIGlmICh3a3QuYiAmJiAhaXNGaW5pdGUod2t0LmIpKSB7XG4gICAgd2t0LmIgPSB3a3QuYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvTWV0ZXIoaW5wdXQpIHtcbiAgICB2YXIgcmF0aW8gPSB3a3QudG9fbWV0ZXIgfHwgMTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChpbnB1dCwgMTApICogcmF0aW87XG4gIH1cbiAgdmFyIHJlbmFtZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHJlbmFtZSh3a3QsIGEpO1xuICB9O1xuICB2YXIgbGlzdCA9IFtcbiAgICBbJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCAnU3RhbmRhcmRfUGFyYWxsZWxfMSddLFxuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMicsICdTdGFuZGFyZF9QYXJhbGxlbF8yJ10sXG4gICAgWydmYWxzZV9lYXN0aW5nJywgJ0ZhbHNlX0Vhc3RpbmcnXSxcbiAgICBbJ2ZhbHNlX25vcnRoaW5nJywgJ0ZhbHNlX05vcnRoaW5nJ10sXG4gICAgWydjZW50cmFsX21lcmlkaWFuJywgJ0NlbnRyYWxfTWVyaWRpYW4nXSxcbiAgICBbJ2xhdGl0dWRlX29mX29yaWdpbicsICdMYXRpdHVkZV9PZl9PcmlnaW4nXSxcbiAgICBbJ2xhdGl0dWRlX29mX29yaWdpbicsICdDZW50cmFsX1BhcmFsbGVsJ10sXG4gICAgWydzY2FsZV9mYWN0b3InLCAnU2NhbGVfRmFjdG9yJ10sXG4gICAgWydrMCcsICdzY2FsZV9mYWN0b3InXSxcbiAgICBbJ2xhdGl0dWRlX29mX2NlbnRlcicsICdMYXRpdHVkZV9vZl9jZW50ZXInXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCAnTG9uZ2l0dWRlX09mX0NlbnRlciddLFxuICAgIFsnbG9uZ2MnLCAnbG9uZ2l0dWRlX29mX2NlbnRlcicsIGQycl0sXG4gICAgWyd4MCcsICdmYWxzZV9lYXN0aW5nJywgdG9NZXRlcl0sXG4gICAgWyd5MCcsICdmYWxzZV9ub3J0aGluZycsIHRvTWV0ZXJdLFxuICAgIFsnbG9uZzAnLCAnY2VudHJhbF9tZXJpZGlhbicsIGQycl0sXG4gICAgWydsYXQwJywgJ2xhdGl0dWRlX29mX29yaWdpbicsIGQycl0sXG4gICAgWydsYXQwJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCBkMnJdLFxuICAgIFsnbGF0MScsICdzdGFuZGFyZF9wYXJhbGxlbF8xJywgZDJyXSxcbiAgICBbJ2xhdDInLCAnc3RhbmRhcmRfcGFyYWxsZWxfMicsIGQycl0sXG4gICAgWydhbHBoYScsICdhemltdXRoJywgZDJyXSxcbiAgICBbJ3Nyc0NvZGUnLCAnbmFtZSddXG4gIF07XG4gIGxpc3QuZm9yRWFjaChyZW5hbWVyKTtcbiAgaWYgKCF3a3QubG9uZzAgJiYgd2t0LmxvbmdjICYmICh3a3QucHJvak5hbWUgPT09ICdBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYScgfHwgd2t0LnByb2pOYW1lID09PSBcIkxhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWFcIikpIHtcbiAgICB3a3QubG9uZzAgPSB3a3QubG9uZ2M7XG4gIH1cbiAgaWYgKCF3a3QubGF0X3RzICYmIHdrdC5sYXQxICYmICh3a3QucHJvak5hbWUgPT09ICdTdGVyZW9ncmFwaGljX1NvdXRoX1BvbGUnIHx8IHdrdC5wcm9qTmFtZSA9PT0gJ1BvbGFyIFN0ZXJlb2dyYXBoaWMgKHZhcmlhbnQgQiknKSkge1xuICAgIHdrdC5sYXQwID0gZDJyKHdrdC5sYXQxID4gMCA/IDkwIDogLTkwKTtcbiAgICB3a3QubGF0X3RzID0gd2t0LmxhdDE7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2t0LCBzZWxmKSB7XG4gIHZhciBsaXNwID0gSlNPTi5wYXJzZSgoXCIsXCIgKyB3a3QpLnJlcGxhY2UoL1xccypcXCxcXHMqKFtBLVpfMC05XSs/KShcXFspL2csICcsW1wiJDFcIiwnKS5zbGljZSgxKS5yZXBsYWNlKC9cXHMqXFwsXFxzKihbQS1aXzAtOV0rPylcXF0vZywgJyxcIiQxXCJdJykucmVwbGFjZSgvLFxcW1wiVkVSVENTXCIuKy8sJycpKTtcbiAgdmFyIHR5cGUgPSBsaXNwLnNoaWZ0KCk7XG4gIHZhciBuYW1lID0gbGlzcC5zaGlmdCgpO1xuICBsaXNwLnVuc2hpZnQoWyduYW1lJywgbmFtZV0pO1xuICBsaXNwLnVuc2hpZnQoWyd0eXBlJywgdHlwZV0pO1xuICBsaXNwLnVuc2hpZnQoJ291dHB1dCcpO1xuICB2YXIgb2JqID0ge307XG4gIHNFeHByKGxpc3AsIG9iaik7XG4gIGNsZWFuV0tUKG9iai5vdXRwdXQpO1xuICByZXR1cm4gZXh0ZW5kKHNlbGYsIG9iai5vdXRwdXQpO1xufTtcblxufSx7XCIuL2V4dGVuZFwiOjM0fV0sNjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cblxuLyoqXG4gKiBVVE0gem9uZXMgYXJlIGdyb3VwZWQsIGFuZCBhc3NpZ25lZCB0byBvbmUgb2YgYSBncm91cCBvZiA2XG4gKiBzZXRzLlxuICpcbiAqIHtpbnR9IEBwcml2YXRlXG4gKi9cbnZhciBOVU1fMTAwS19TRVRTID0gNjtcblxuLyoqXG4gKiBUaGUgY29sdW1uIGxldHRlcnMgKGZvciBlYXN0aW5nKSBvZiB0aGUgbG93ZXIgbGVmdCB2YWx1ZSwgcGVyXG4gKiBzZXQuXG4gKlxuICoge3N0cmluZ30gQHByaXZhdGVcbiAqL1xudmFyIFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMgPSAnQUpTQUpTJztcblxuLyoqXG4gKiBUaGUgcm93IGxldHRlcnMgKGZvciBub3J0aGluZykgb2YgdGhlIGxvd2VyIGxlZnQgdmFsdWUsIHBlclxuICogc2V0LlxuICpcbiAqIHtzdHJpbmd9IEBwcml2YXRlXG4gKi9cbnZhciBTRVRfT1JJR0lOX1JPV19MRVRURVJTID0gJ0FGQUZBRic7XG5cbnZhciBBID0gNjU7IC8vIEFcbnZhciBJID0gNzM7IC8vIElcbnZhciBPID0gNzk7IC8vIE9cbnZhciBWID0gODY7IC8vIFZcbnZhciBaID0gOTA7IC8vIFpcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9mIGxhdC9sb24gdG8gTUdSUy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzIG9uIGFcbiAqICAgICBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge2ludH0gYWNjdXJhY3kgQWNjdXJhY3kgaW4gZGlnaXRzICg1IGZvciAxIG0sIDQgZm9yIDEwIG0sIDMgZm9yXG4gKiAgICAgIDEwMCBtLCAyIGZvciAxMDAwIG0gb3IgMSBmb3IgMTAwMDAgbSkuIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBNR1JTIHN0cmluZyBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGFuZCBhY2N1cmFjeS5cbiAqL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24obGwsIGFjY3VyYWN5KSB7XG4gIGFjY3VyYWN5ID0gYWNjdXJhY3kgfHwgNTsgLy8gZGVmYXVsdCBhY2N1cmFjeSAxbVxuICByZXR1cm4gZW5jb2RlKExMdG9VVE0oe1xuICAgIGxhdDogbGxbMV0sXG4gICAgbG9uOiBsbFswXVxuICB9KSwgYWNjdXJhY3kpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9mIE1HUlMgdG8gbGF0L2xvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWdycyBNR1JTIHN0cmluZy5cbiAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSB3aXRoIGxlZnQgKGxvbmdpdHVkZSksIGJvdHRvbSAobGF0aXR1ZGUpLCByaWdodFxuICogICAgIChsb25naXR1ZGUpIGFuZCB0b3AgKGxhdGl0dWRlKSB2YWx1ZXMgaW4gV0dTODQsIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICBib3VuZGluZyBib3ggZm9yIHRoZSBwcm92aWRlZCBNR1JTIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24obWdycykge1xuICB2YXIgYmJveCA9IFVUTXRvTEwoZGVjb2RlKG1ncnMudG9VcHBlckNhc2UoKSkpO1xuICBpZiAoYmJveC5sYXQgJiYgYmJveC5sb24pIHtcbiAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdCwgYmJveC5sb24sIGJib3gubGF0XTtcbiAgfVxuICByZXR1cm4gW2Jib3gubGVmdCwgYmJveC5ib3R0b20sIGJib3gucmlnaHQsIGJib3gudG9wXTtcbn07XG5cbmV4cG9ydHMudG9Qb2ludCA9IGZ1bmN0aW9uKG1ncnMpIHtcbiAgdmFyIGJib3ggPSBVVE10b0xMKGRlY29kZShtZ3JzLnRvVXBwZXJDYXNlKCkpKTtcbiAgaWYgKGJib3gubGF0ICYmIGJib3gubG9uKSB7XG4gICAgcmV0dXJuIFtiYm94LmxvbiwgYmJveC5sYXRdO1xuICB9XG4gIHJldHVybiBbKGJib3gubGVmdCArIGJib3gucmlnaHQpIC8gMiwgKGJib3gudG9wICsgYmJveC5ib3R0b20pIC8gMl07XG59O1xuLyoqXG4gKiBDb252ZXJzaW9uIGZyb20gZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoZGVnKSB7XG4gIHJldHVybiAoZGVnICogKE1hdGguUEkgLyAxODAuMCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnNpb24gZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWQpIHtcbiAgcmV0dXJuICgxODAuMCAqIChyYWQgLyBNYXRoLlBJKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXQgb2YgTG9uZ2l0dWRlIGFuZCBMYXRpdHVkZSBjby1vcmRpbmF0ZXMgdG8gVVRNXG4gKiB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzXG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSBXR1M4NCBjb29yZGluYXRlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyB0aGUgVVRNIHZhbHVlIHdpdGggZWFzdGluZyxcbiAqICAgICBub3J0aGluZywgem9uZU51bWJlciBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLCBhbmQgYW4gb3B0aW9uYWxcbiAqICAgICBhY2N1cmFjeSBwcm9wZXJ0eSBpbiBkaWdpdHMuIFJldHVybnMgbnVsbCBpZiB0aGUgY29udmVyc2lvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIExMdG9VVE0obGwpIHtcbiAgdmFyIExhdCA9IGxsLmxhdDtcbiAgdmFyIExvbmcgPSBsbC5sb247XG4gIHZhciBhID0gNjM3ODEzNy4wOyAvL2VsbGlwLnJhZGl1cztcbiAgdmFyIGVjY1NxdWFyZWQgPSAwLjAwNjY5NDM4OyAvL2VsbGlwLmVjY3NxO1xuICB2YXIgazAgPSAwLjk5OTY7XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgZWNjUHJpbWVTcXVhcmVkO1xuICB2YXIgTiwgVCwgQywgQSwgTTtcbiAgdmFyIExhdFJhZCA9IGRlZ1RvUmFkKExhdCk7XG4gIHZhciBMb25nUmFkID0gZGVnVG9SYWQoTG9uZyk7XG4gIHZhciBMb25nT3JpZ2luUmFkO1xuICB2YXIgWm9uZU51bWJlcjtcbiAgLy8gKGludClcbiAgWm9uZU51bWJlciA9IE1hdGguZmxvb3IoKExvbmcgKyAxODApIC8gNikgKyAxO1xuXG4gIC8vTWFrZSBzdXJlIHRoZSBsb25naXR1ZGUgMTgwLjAwIGlzIGluIFpvbmUgNjBcbiAgaWYgKExvbmcgPT09IDE4MCkge1xuICAgIFpvbmVOdW1iZXIgPSA2MDtcbiAgfVxuXG4gIC8vIFNwZWNpYWwgem9uZSBmb3IgTm9yd2F5XG4gIGlmIChMYXQgPj0gNTYuMCAmJiBMYXQgPCA2NC4wICYmIExvbmcgPj0gMy4wICYmIExvbmcgPCAxMi4wKSB7XG4gICAgWm9uZU51bWJlciA9IDMyO1xuICB9XG5cbiAgLy8gU3BlY2lhbCB6b25lcyBmb3IgU3ZhbGJhcmRcbiAgaWYgKExhdCA+PSA3Mi4wICYmIExhdCA8IDg0LjApIHtcbiAgICBpZiAoTG9uZyA+PSAwLjAgJiYgTG9uZyA8IDkuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMxO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDkuMCAmJiBMb25nIDwgMjEuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMzO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDIxLjAgJiYgTG9uZyA8IDMzLjApIHtcbiAgICAgIFpvbmVOdW1iZXIgPSAzNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTG9uZyA+PSAzMy4wICYmIExvbmcgPCA0Mi4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzc7XG4gICAgfVxuICB9XG5cbiAgTG9uZ09yaWdpbiA9IChab25lTnVtYmVyIC0gMSkgKiA2IC0gMTgwICsgMzsgLy8rMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuICBMb25nT3JpZ2luUmFkID0gZGVnVG9SYWQoTG9uZ09yaWdpbik7XG5cbiAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuICBOID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKExhdFJhZCkgKiBNYXRoLnNpbihMYXRSYWQpKTtcbiAgVCA9IE1hdGgudGFuKExhdFJhZCkgKiBNYXRoLnRhbihMYXRSYWQpO1xuICBDID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MoTGF0UmFkKSAqIE1hdGguY29zKExhdFJhZCk7XG4gIEEgPSBNYXRoLmNvcyhMYXRSYWQpICogKExvbmdSYWQgLSBMb25nT3JpZ2luUmFkKTtcblxuICBNID0gYSAqICgoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSAqIExhdFJhZCAtICgzICogZWNjU3F1YXJlZCAvIDggKyAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMiArIDQ1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMTAyNCkgKiBNYXRoLnNpbigyICogTGF0UmFkKSArICgxNSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2ICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDQgKiBMYXRSYWQpIC0gKDM1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMzA3MikgKiBNYXRoLnNpbig2ICogTGF0UmFkKSk7XG5cbiAgdmFyIFVUTUVhc3RpbmcgPSAoazAgKiBOICogKEEgKyAoMSAtIFQgKyBDKSAqIEEgKiBBICogQSAvIDYuMCArICg1IC0gMTggKiBUICsgVCAqIFQgKyA3MiAqIEMgLSA1OCAqIGVjY1ByaW1lU3F1YXJlZCkgKiBBICogQSAqIEEgKiBBICogQSAvIDEyMC4wKSArIDUwMDAwMC4wKTtcblxuICB2YXIgVVRNTm9ydGhpbmcgPSAoazAgKiAoTSArIE4gKiBNYXRoLnRhbihMYXRSYWQpICogKEEgKiBBIC8gMiArICg1IC0gVCArIDkgKiBDICsgNCAqIEMgKiBDKSAqIEEgKiBBICogQSAqIEEgLyAyNC4wICsgKDYxIC0gNTggKiBUICsgVCAqIFQgKyA2MDAgKiBDIC0gMzMwICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBICogQSAvIDcyMC4wKSkpO1xuICBpZiAoTGF0IDwgMC4wKSB7XG4gICAgVVRNTm9ydGhpbmcgKz0gMTAwMDAwMDAuMDsgLy8xMDAwMDAwMCBtZXRlciBvZmZzZXQgZm9yXG4gICAgLy8gc291dGhlcm4gaGVtaXNwaGVyZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub3J0aGluZzogTWF0aC5yb3VuZChVVE1Ob3J0aGluZyksXG4gICAgZWFzdGluZzogTWF0aC5yb3VuZChVVE1FYXN0aW5nKSxcbiAgICB6b25lTnVtYmVyOiBab25lTnVtYmVyLFxuICAgIHpvbmVMZXR0ZXI6IGdldExldHRlckRlc2lnbmF0b3IoTGF0KVxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFVUTSBjb29yZHMgdG8gbGF0L2xvbmcsIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogY2xhc3Mgd2hlcmUgdGhlIFpvbmUgY2FuIGJlIHNwZWNpZmllZCBhcyBhIHNpbmdsZSBzdHJpbmcgZWcuXCI2ME5cIiB3aGljaFxuICogaXMgdGhlbiBicm9rZW4gZG93biBpbnRvIHRoZSBab25lTnVtYmVyIGFuZCBab25lTGV0dGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdXRtIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggbm9ydGhpbmcsIGVhc3RpbmcsIHpvbmVOdW1iZXJcbiAqICAgICBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLiBJZiBhbiBvcHRpb25hbCBhY2N1cmFjeSBwcm9wZXJ0eSBpc1xuICogICAgIHByb3ZpZGVkIChpbiBtZXRlcnMpLCBhIGJvdW5kaW5nIGJveCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2ZcbiAqICAgICBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGVpdGhlciBsYXQgYW5kIGxvbiB2YWx1ZXNcbiAqICAgICAoaWYgbm8gYWNjdXJhY3kgd2FzIHByb3ZpZGVkKSwgb3IgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0IHZhbHVlc1xuICogICAgIGZvciB0aGUgYm91bmRpbmcgYm94IGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBhY2N1cmFjeS5cbiAqICAgICBSZXR1cm5zIG51bGwgaWYgdGhlIGNvbnZlcnNpb24gZmFpbGVkLlxuICovXG5mdW5jdGlvbiBVVE10b0xMKHV0bSkge1xuXG4gIHZhciBVVE1Ob3J0aGluZyA9IHV0bS5ub3J0aGluZztcbiAgdmFyIFVUTUVhc3RpbmcgPSB1dG0uZWFzdGluZztcbiAgdmFyIHpvbmVMZXR0ZXIgPSB1dG0uem9uZUxldHRlcjtcbiAgdmFyIHpvbmVOdW1iZXIgPSB1dG0uem9uZU51bWJlcjtcbiAgLy8gY2hlY2sgdGhlIFpvbmVOdW1tYmVyIGlzIHZhbGlkXG4gIGlmICh6b25lTnVtYmVyIDwgMCB8fCB6b25lTnVtYmVyID4gNjApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrMCA9IDAuOTk5NjtcbiAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuICB2YXIgZWNjU3F1YXJlZCA9IDAuMDA2Njk0Mzg7IC8vZWxsaXAuZWNjc3E7XG4gIHZhciBlY2NQcmltZVNxdWFyZWQ7XG4gIHZhciBlMSA9ICgxIC0gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSkgLyAoMSArIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCkpO1xuICB2YXIgTjEsIFQxLCBDMSwgUjEsIEQsIE07XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgbXUsIHBoaTFSYWQ7XG5cbiAgLy8gcmVtb3ZlIDUwMCwwMDAgbWV0ZXIgb2Zmc2V0IGZvciBsb25naXR1ZGVcbiAgdmFyIHggPSBVVE1FYXN0aW5nIC0gNTAwMDAwLjA7XG4gIHZhciB5ID0gVVRNTm9ydGhpbmc7XG5cbiAgLy8gV2UgbXVzdCBrbm93IHNvbWVob3cgaWYgd2UgYXJlIGluIHRoZSBOb3J0aGVybiBvciBTb3V0aGVyblxuICAvLyBoZW1pc3BoZXJlLCB0aGlzIGlzIHRoZSBvbmx5IHRpbWUgd2UgdXNlIHRoZSBsZXR0ZXIgU28gZXZlblxuICAvLyBpZiB0aGUgWm9uZSBsZXR0ZXIgaXNuJ3QgZXhhY3RseSBjb3JyZWN0IGl0IHNob3VsZCBpbmRpY2F0ZVxuICAvLyB0aGUgaGVtaXNwaGVyZSBjb3JyZWN0bHlcbiAgaWYgKHpvbmVMZXR0ZXIgPCAnTicpIHtcbiAgICB5IC09IDEwMDAwMDAwLjA7IC8vIHJlbW92ZSAxMCwwMDAsMDAwIG1ldGVyIG9mZnNldCB1c2VkXG4gICAgLy8gZm9yIHNvdXRoZXJuIGhlbWlzcGhlcmVcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSA2MCB6b25lcyB3aXRoIHpvbmUgMSBiZWluZyBhdCBXZXN0IC0xODAgdG8gLTE3NFxuICBMb25nT3JpZ2luID0gKHpvbmVOdW1iZXIgLSAxKSAqIDYgLSAxODAgKyAzOyAvLyArMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuXG4gIGVjY1ByaW1lU3F1YXJlZCA9IChlY2NTcXVhcmVkKSAvICgxIC0gZWNjU3F1YXJlZCk7XG5cbiAgTSA9IHkgLyBrMDtcbiAgbXUgPSBNIC8gKGEgKiAoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSk7XG5cbiAgcGhpMVJhZCA9IG11ICsgKDMgKiBlMSAvIDIgLSAyNyAqIGUxICogZTEgKiBlMSAvIDMyKSAqIE1hdGguc2luKDIgKiBtdSkgKyAoMjEgKiBlMSAqIGUxIC8gMTYgLSA1NSAqIGUxICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oNCAqIG11KSArICgxNTEgKiBlMSAqIGUxICogZTEgLyA5NikgKiBNYXRoLnNpbig2ICogbXUpO1xuICAvLyBkb3VibGUgcGhpMSA9IFByb2pNYXRoLnJhZFRvRGVnKHBoaTFSYWQpO1xuXG4gIE4xID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKHBoaTFSYWQpICogTWF0aC5zaW4ocGhpMVJhZCkpO1xuICBUMSA9IE1hdGgudGFuKHBoaTFSYWQpICogTWF0aC50YW4ocGhpMVJhZCk7XG4gIEMxID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MocGhpMVJhZCkgKiBNYXRoLmNvcyhwaGkxUmFkKTtcbiAgUjEgPSBhICogKDEgLSBlY2NTcXVhcmVkKSAvIE1hdGgucG93KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSwgMS41KTtcbiAgRCA9IHggLyAoTjEgKiBrMCk7XG5cbiAgdmFyIGxhdCA9IHBoaTFSYWQgLSAoTjEgKiBNYXRoLnRhbihwaGkxUmFkKSAvIFIxKSAqIChEICogRCAvIDIgLSAoNSArIDMgKiBUMSArIDEwICogQzEgLSA0ICogQzEgKiBDMSAtIDkgKiBlY2NQcmltZVNxdWFyZWQpICogRCAqIEQgKiBEICogRCAvIDI0ICsgKDYxICsgOTAgKiBUMSArIDI5OCAqIEMxICsgNDUgKiBUMSAqIFQxIC0gMjUyICogZWNjUHJpbWVTcXVhcmVkIC0gMyAqIEMxICogQzEpICogRCAqIEQgKiBEICogRCAqIEQgKiBEIC8gNzIwKTtcbiAgbGF0ID0gcmFkVG9EZWcobGF0KTtcblxuICB2YXIgbG9uID0gKEQgLSAoMSArIDIgKiBUMSArIEMxKSAqIEQgKiBEICogRCAvIDYgKyAoNSAtIDIgKiBDMSArIDI4ICogVDEgLSAzICogQzEgKiBDMSArIDggKiBlY2NQcmltZVNxdWFyZWQgKyAyNCAqIFQxICogVDEpICogRCAqIEQgKiBEICogRCAqIEQgLyAxMjApIC8gTWF0aC5jb3MocGhpMVJhZCk7XG4gIGxvbiA9IExvbmdPcmlnaW4gKyByYWRUb0RlZyhsb24pO1xuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh1dG0uYWNjdXJhY3kpIHtcbiAgICB2YXIgdG9wUmlnaHQgPSBVVE10b0xMKHtcbiAgICAgIG5vcnRoaW5nOiB1dG0ubm9ydGhpbmcgKyB1dG0uYWNjdXJhY3ksXG4gICAgICBlYXN0aW5nOiB1dG0uZWFzdGluZyArIHV0bS5hY2N1cmFjeSxcbiAgICAgIHpvbmVMZXR0ZXI6IHV0bS56b25lTGV0dGVyLFxuICAgICAgem9uZU51bWJlcjogdXRtLnpvbmVOdW1iZXJcbiAgICB9KTtcbiAgICByZXN1bHQgPSB7XG4gICAgICB0b3A6IHRvcFJpZ2h0LmxhdCxcbiAgICAgIHJpZ2h0OiB0b3BSaWdodC5sb24sXG4gICAgICBib3R0b206IGxhdCxcbiAgICAgIGxlZnQ6IGxvblxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbGF0OiBsYXQsXG4gICAgICBsb246IGxvblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNR1JTIGxldHRlciBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gbGF0aXR1ZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGluIFdHUzg0IHRvIGdldCB0aGUgbGV0dGVyIGRlc2lnbmF0b3JcbiAqICAgICBmb3IuXG4gKiBAcmV0dXJuIHtjaGFyfSBUaGUgbGV0dGVyIGRlc2lnbmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldExldHRlckRlc2lnbmF0b3IobGF0KSB7XG4gIC8vVGhpcyBpcyBoZXJlIGFzIGFuIGVycm9yIGZsYWcgdG8gc2hvdyB0aGF0IHRoZSBMYXRpdHVkZSBpc1xuICAvL291dHNpZGUgTUdSUyBsaW1pdHNcbiAgdmFyIExldHRlckRlc2lnbmF0b3IgPSAnWic7XG5cbiAgaWYgKCg4NCA+PSBsYXQpICYmIChsYXQgPj0gNzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdYJztcbiAgfVxuICBlbHNlIGlmICgoNzIgPiBsYXQpICYmIChsYXQgPj0gNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdXJztcbiAgfVxuICBlbHNlIGlmICgoNjQgPiBsYXQpICYmIChsYXQgPj0gNTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdWJztcbiAgfVxuICBlbHNlIGlmICgoNTYgPiBsYXQpICYmIChsYXQgPj0gNDgpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdVJztcbiAgfVxuICBlbHNlIGlmICgoNDggPiBsYXQpICYmIChsYXQgPj0gNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdUJztcbiAgfVxuICBlbHNlIGlmICgoNDAgPiBsYXQpICYmIChsYXQgPj0gMzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdTJztcbiAgfVxuICBlbHNlIGlmICgoMzIgPiBsYXQpICYmIChsYXQgPj0gMjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdSJztcbiAgfVxuICBlbHNlIGlmICgoMjQgPiBsYXQpICYmIChsYXQgPj0gMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdRJztcbiAgfVxuICBlbHNlIGlmICgoMTYgPiBsYXQpICYmIChsYXQgPj0gOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1AnO1xuICB9XG4gIGVsc2UgaWYgKCg4ID4gbGF0KSAmJiAobGF0ID49IDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdOJztcbiAgfVxuICBlbHNlIGlmICgoMCA+IGxhdCkgJiYgKGxhdCA+PSAtOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ00nO1xuICB9XG4gIGVsc2UgaWYgKCgtOCA+IGxhdCkgJiYgKGxhdCA+PSAtMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdMJztcbiAgfVxuICBlbHNlIGlmICgoLTE2ID4gbGF0KSAmJiAobGF0ID49IC0yNCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0snO1xuICB9XG4gIGVsc2UgaWYgKCgtMjQgPiBsYXQpICYmIChsYXQgPj0gLTMyKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnSic7XG4gIH1cbiAgZWxzZSBpZiAoKC0zMiA+IGxhdCkgJiYgKGxhdCA+PSAtNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdIJztcbiAgfVxuICBlbHNlIGlmICgoLTQwID4gbGF0KSAmJiAobGF0ID49IC00OCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0cnO1xuICB9XG4gIGVsc2UgaWYgKCgtNDggPiBsYXQpICYmIChsYXQgPj0gLTU2KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRic7XG4gIH1cbiAgZWxzZSBpZiAoKC01NiA+IGxhdCkgJiYgKGxhdCA+PSAtNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdFJztcbiAgfVxuICBlbHNlIGlmICgoLTY0ID4gbGF0KSAmJiAobGF0ID49IC03MikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0QnO1xuICB9XG4gIGVsc2UgaWYgKCgtNzIgPiBsYXQpICYmIChsYXQgPj0gLTgwKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnQyc7XG4gIH1cbiAgcmV0dXJuIExldHRlckRlc2lnbmF0b3I7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIFVUTSBsb2NhdGlvbiBhcyBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHV0bSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLFxuICogICAgIHpvbmVMZXR0ZXIsIHpvbmVOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY2N1cmFjeSBBY2N1cmFjeSBpbiBkaWdpdHMgKDEtNSkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1HUlMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodXRtLCBhY2N1cmFjeSkge1xuICAvLyBwcmVwZW5kIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHNlYXN0aW5nID0gXCIwMDAwMFwiICsgdXRtLmVhc3RpbmcsXG4gICAgc25vcnRoaW5nID0gXCIwMDAwMFwiICsgdXRtLm5vcnRoaW5nO1xuXG4gIHJldHVybiB1dG0uem9uZU51bWJlciArIHV0bS56b25lTGV0dGVyICsgZ2V0MTAwa0lEKHV0bS5lYXN0aW5nLCB1dG0ubm9ydGhpbmcsIHV0bS56b25lTnVtYmVyKSArIHNlYXN0aW5nLnN1YnN0cihzZWFzdGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSkgKyBzbm9ydGhpbmcuc3Vic3RyKHNub3J0aGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0d28gbGV0dGVyIDEwMGsgZGVzaWduYXRvciBmb3IgYSBnaXZlbiBVVE0gZWFzdGluZyxcbiAqIG5vcnRoaW5nIGFuZCB6b25lIG51bWJlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGVhc3RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3J0aGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHpvbmVOdW1iZXJcbiAqIEByZXR1cm4gdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrSUQoZWFzdGluZywgbm9ydGhpbmcsIHpvbmVOdW1iZXIpIHtcbiAgdmFyIHNldFBhcm0gPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcbiAgdmFyIHNldENvbHVtbiA9IE1hdGguZmxvb3IoZWFzdGluZyAvIDEwMDAwMCk7XG4gIHZhciBzZXRSb3cgPSBNYXRoLmZsb29yKG5vcnRoaW5nIC8gMTAwMDAwKSAlIDIwO1xuICByZXR1cm4gZ2V0TGV0dGVyMTAwa0lEKHNldENvbHVtbiwgc2V0Um93LCBzZXRQYXJtKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFVUTSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgTUdSUyAxMDBLIHNldCBpdCBpcyBpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQW4gVVRNIHpvbmUgbnVtYmVyLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMTAwayBzZXQgdGhlIFVUTSB6b25lIGlzIGluLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrU2V0Rm9yWm9uZShpKSB7XG4gIHZhciBzZXRQYXJtID0gaSAlIE5VTV8xMDBLX1NFVFM7XG4gIGlmIChzZXRQYXJtID09PSAwKSB7XG4gICAgc2V0UGFybSA9IE5VTV8xMDBLX1NFVFM7XG4gIH1cblxuICByZXR1cm4gc2V0UGFybTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR3by1sZXR0ZXIgTUdSUyAxMDBrIGRlc2lnbmF0b3IgZ2l2ZW4gaW5mb3JtYXRpb25cbiAqIHRyYW5zbGF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nLCBlYXN0aW5nIGFuZCB6b25lIG51bWJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiB0aGUgY29sdW1uIGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlNcbiAqICAgICAgICAxMDBrIHNldCBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gZWFzdGluZy5cbiAqICAgICAgICBWYWx1ZXMgYXJlIDEtOC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgdGhlIHJvdyBpbmRleCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG4gKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nIHZhbHVlLiBWYWx1ZXNcbiAqICAgICAgICBhcmUgZnJvbSAwLTE5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcm0gdGhlIHNldCBibG9jaywgYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSUyAxMDBrIHNldFxuICogICAgICAgIHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSB6b25lLiBWYWx1ZXMgYXJlIGZyb21cbiAqICAgICAgICAxLTYwLlxuICogQHJldHVybiB0d28gbGV0dGVyIE1HUlMgMTAwayBjb2RlLlxuICovXG5mdW5jdGlvbiBnZXRMZXR0ZXIxMDBrSUQoY29sdW1uLCByb3csIHBhcm0pIHtcbiAgLy8gY29sT3JpZ2luIGFuZCByb3dPcmlnaW4gYXJlIHRoZSBsZXR0ZXJzIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldFxuICB2YXIgaW5kZXggPSBwYXJtIC0gMTtcbiAgdmFyIGNvbE9yaWdpbiA9IFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMuY2hhckNvZGVBdChpbmRleCk7XG4gIHZhciByb3dPcmlnaW4gPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIC8vIGNvbEludCBhbmQgcm93SW50IGFyZSB0aGUgbGV0dGVycyB0byBidWlsZCB0byByZXR1cm5cbiAgdmFyIGNvbEludCA9IGNvbE9yaWdpbiArIGNvbHVtbiAtIDE7XG4gIHZhciByb3dJbnQgPSByb3dPcmlnaW4gKyByb3c7XG4gIHZhciByb2xsb3ZlciA9IGZhbHNlO1xuXG4gIGlmIChjb2xJbnQgPiBaKSB7XG4gICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb2xJbnQgPT09IEkgfHwgKGNvbE9yaWdpbiA8IEkgJiYgY29sSW50ID4gSSkgfHwgKChjb2xJbnQgPiBJIHx8IGNvbE9yaWdpbiA8IEkpICYmIHJvbGxvdmVyKSkge1xuICAgIGNvbEludCsrO1xuICB9XG5cbiAgaWYgKGNvbEludCA9PT0gTyB8fCAoY29sT3JpZ2luIDwgTyAmJiBjb2xJbnQgPiBPKSB8fCAoKGNvbEludCA+IE8gfHwgY29sT3JpZ2luIDwgTykgJiYgcm9sbG92ZXIpKSB7XG4gICAgY29sSW50Kys7XG5cbiAgICBpZiAoY29sSW50ID09PSBJKSB7XG4gICAgICBjb2xJbnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY29sSW50ID4gWikge1xuICAgIGNvbEludCA9IGNvbEludCAtIFogKyBBIC0gMTtcbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByb2xsb3ZlciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCgocm93SW50ID09PSBJKSB8fCAoKHJvd09yaWdpbiA8IEkpICYmIChyb3dJbnQgPiBJKSkpIHx8ICgoKHJvd0ludCA+IEkpIHx8IChyb3dPcmlnaW4gPCBJKSkgJiYgcm9sbG92ZXIpKSB7XG4gICAgcm93SW50Kys7XG4gIH1cblxuICBpZiAoKChyb3dJbnQgPT09IE8pIHx8ICgocm93T3JpZ2luIDwgTykgJiYgKHJvd0ludCA+IE8pKSkgfHwgKCgocm93SW50ID4gTykgfHwgKHJvd09yaWdpbiA8IE8pKSAmJiByb2xsb3ZlcikpIHtcbiAgICByb3dJbnQrKztcblxuICAgIGlmIChyb3dJbnQgPT09IEkpIHtcbiAgICAgIHJvd0ludCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICB9XG5cbiAgdmFyIHR3b0xldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29sSW50KSArIFN0cmluZy5mcm9tQ2hhckNvZGUocm93SW50KTtcbiAgcmV0dXJuIHR3b0xldHRlcjtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIFVUTSBwYXJhbWV0ZXJzIGZyb20gYSBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ncnNTdHJpbmcgYW4gVVBQRVJDQVNFIGNvb3JkaW5hdGUgc3RyaW5nIGlzIGV4cGVjdGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTGV0dGVyLFxuICogICAgIHpvbmVOdW1iZXIgYW5kIGFjY3VyYWN5IChpbiBtZXRlcnMpIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShtZ3JzU3RyaW5nKSB7XG5cbiAgaWYgKG1ncnNTdHJpbmcgJiYgbWdyc1N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgY292ZXJ0aW5nIGZyb20gbm90aGluZ1wiKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBtZ3JzU3RyaW5nLmxlbmd0aDtcblxuICB2YXIgaHVuSyA9IG51bGw7XG4gIHZhciBzYiA9IFwiXCI7XG4gIHZhciB0ZXN0Q2hhcjtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGdldCBab25lIG51bWJlclxuICB3aGlsZSAoISgvW0EtWl0vKS50ZXN0KHRlc3RDaGFyID0gbWdyc1N0cmluZy5jaGFyQXQoaSkpKSB7XG4gICAgaWYgKGkgPj0gMikge1xuICAgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gICAgfVxuICAgIHNiICs9IHRlc3RDaGFyO1xuICAgIGkrKztcbiAgfVxuXG4gIHZhciB6b25lTnVtYmVyID0gcGFyc2VJbnQoc2IsIDEwKTtcblxuICBpZiAoaSA9PT0gMCB8fCBpICsgMyA+IGxlbmd0aCkge1xuICAgIC8vIEEgZ29vZCBNR1JTIHN0cmluZyBoYXMgdG8gYmUgNC01IGRpZ2l0cyBsb25nLFxuICAgIC8vICMjQUFBLyNBQUEgYXQgbGVhc3QuXG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICB2YXIgem9uZUxldHRlciA9IG1ncnNTdHJpbmcuY2hhckF0KGkrKyk7XG5cbiAgLy8gU2hvdWxkIHdlIGNoZWNrIHRoZSB6b25lIGxldHRlciBoZXJlPyBXaHkgbm90LlxuICBpZiAoem9uZUxldHRlciA8PSAnQScgfHwgem9uZUxldHRlciA9PT0gJ0InIHx8IHpvbmVMZXR0ZXIgPT09ICdZJyB8fCB6b25lTGV0dGVyID49ICdaJyB8fCB6b25lTGV0dGVyID09PSAnSScgfHwgem9uZUxldHRlciA9PT0gJ08nKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IHpvbmUgbGV0dGVyIFwiICsgem9uZUxldHRlciArIFwiIG5vdCBoYW5kbGVkOiBcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgaHVuSyA9IG1ncnNTdHJpbmcuc3Vic3RyaW5nKGksIGkgKz0gMik7XG5cbiAgdmFyIHNldCA9IGdldDEwMGtTZXRGb3Jab25lKHpvbmVOdW1iZXIpO1xuXG4gIHZhciBlYXN0MTAwayA9IGdldEVhc3RpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgwKSwgc2V0KTtcbiAgdmFyIG5vcnRoMTAwayA9IGdldE5vcnRoaW5nRnJvbUNoYXIoaHVuSy5jaGFyQXQoMSksIHNldCk7XG5cbiAgLy8gV2UgaGF2ZSBhIGJ1ZyB3aGVyZSB0aGUgbm9ydGhpbmcgbWF5IGJlIDIwMDAwMDAgdG9vIGxvdy5cbiAgLy8gSG93XG4gIC8vIGRvIHdlIGtub3cgd2hlbiB0byByb2xsIG92ZXI/XG5cbiAgd2hpbGUgKG5vcnRoMTAwayA8IGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpKSB7XG4gICAgbm9ydGgxMDBrICs9IDIwMDAwMDA7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGNoYXIgaW5kZXggZm9yIGVhc3Rpbmcvbm9ydGhpbmcgc2VwYXJhdG9yXG4gIHZhciByZW1haW5kZXIgPSBsZW5ndGggLSBpO1xuXG4gIGlmIChyZW1haW5kZXIgJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGhhcyB0byBoYXZlIGFuIGV2ZW4gbnVtYmVyIFxcbm9mIGRpZ2l0cyBhZnRlciB0aGUgem9uZSBsZXR0ZXIgYW5kIHR3byAxMDBrbSBsZXR0ZXJzIC0gZnJvbnQgXFxuaGFsZiBmb3IgZWFzdGluZyBtZXRlcnMsIHNlY29uZCBoYWxmIGZvciBcXG5ub3J0aGluZyBtZXRlcnNcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgdmFyIHNlcCA9IHJlbWFpbmRlciAvIDI7XG5cbiAgdmFyIHNlcEVhc3RpbmcgPSAwLjA7XG4gIHZhciBzZXBOb3J0aGluZyA9IDAuMDtcbiAgdmFyIGFjY3VyYWN5Qm9udXMsIHNlcEVhc3RpbmdTdHJpbmcsIHNlcE5vcnRoaW5nU3RyaW5nLCBlYXN0aW5nLCBub3J0aGluZztcbiAgaWYgKHNlcCA+IDApIHtcbiAgICBhY2N1cmFjeUJvbnVzID0gMTAwMDAwLjAgLyBNYXRoLnBvdygxMCwgc2VwKTtcbiAgICBzZXBFYXN0aW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArIHNlcCk7XG4gICAgc2VwRWFzdGluZyA9IHBhcnNlRmxvYXQoc2VwRWFzdGluZ1N0cmluZykgKiBhY2N1cmFjeUJvbnVzO1xuICAgIHNlcE5vcnRoaW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSArIHNlcCk7XG4gICAgc2VwTm9ydGhpbmcgPSBwYXJzZUZsb2F0KHNlcE5vcnRoaW5nU3RyaW5nKSAqIGFjY3VyYWN5Qm9udXM7XG4gIH1cblxuICBlYXN0aW5nID0gc2VwRWFzdGluZyArIGVhc3QxMDBrO1xuICBub3J0aGluZyA9IHNlcE5vcnRoaW5nICsgbm9ydGgxMDBrO1xuXG4gIHJldHVybiB7XG4gICAgZWFzdGluZzogZWFzdGluZyxcbiAgICBub3J0aGluZzogbm9ydGhpbmcsXG4gICAgem9uZUxldHRlcjogem9uZUxldHRlcixcbiAgICB6b25lTnVtYmVyOiB6b25lTnVtYmVyLFxuICAgIGFjY3VyYWN5OiBhY2N1cmFjeUJvbnVzXG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMGsgem9uZSwgYW5kIGdpdmVuIHRoZVxuICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgZWFzdGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgZWFzdGluZyB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBlIFRoZSBmaXJzdCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDDCtGsgem9uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXQgVGhlIE1HUlMgdGFibGUgc2V0IGZvciB0aGUgem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlYXN0aW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVhc3RpbmdGcm9tQ2hhcihlLCBzZXQpIHtcbiAgLy8gY29sT3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcbiAgLy8gY29sdW1uXG4gIHZhciBjdXJDb2wgPSBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG4gIHZhciBlYXN0aW5nVmFsdWUgPSAxMDAwMDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJDb2wgIT09IGUuY2hhckNvZGVBdCgwKSkge1xuICAgIGN1ckNvbCsrO1xuICAgIGlmIChjdXJDb2wgPT09IEkpIHtcbiAgICAgIGN1ckNvbCsrO1xuICAgIH1cbiAgICBpZiAoY3VyQ29sID09PSBPKSB7XG4gICAgICBjdXJDb2wrKztcbiAgICB9XG4gICAgaWYgKGN1ckNvbCA+IFopIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgKFwiQmFkIGNoYXJhY3RlcjogXCIgKyBlKTtcbiAgICAgIH1cbiAgICAgIGN1ckNvbCA9IEE7XG4gICAgICByZXdpbmRNYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBlYXN0aW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gZWFzdGluZ1ZhbHVlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBzZWNvbmQgbGV0dGVyIGZyb20gYSB0d28tbGV0dGVyIE1HUlMgMTAwayB6b25lLCBhbmQgZ2l2ZW4gdGhlXG4gKiBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBub3J0aGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgbm9ydGhpbmcgdmFsdWUuIFlvdSBoYXZlIHRvXG4gKiByZW1lbWJlciB0aGF0IE5vcnRoaW5ncyBhcmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBlcXVhdG9yLCBhbmQgdGhlIHZlcnRpY2FsXG4gKiBjeWNsZSBvZiBsZXR0ZXJzIG1lYW4gYSAyMDAwMDAwIGFkZGl0aW9uYWwgbm9ydGhpbmcgbWV0ZXJzLiBUaGlzIGhhcHBlbnNcbiAqIGFwcHJveC4gZXZlcnkgMTggZGVncmVlcyBvZiBsYXRpdHVkZS4gVGhpcyBtZXRob2QgZG9lcyAqTk9UKiBjb3VudCBhbnlcbiAqIGFkZGl0aW9uYWwgbm9ydGhpbmdzLiBZb3UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyBtYW55IDIwMDAwMDAgbWV0ZXJzIG5lZWRcbiAqIHRvIGJlIGFkZGVkIGZvciB0aGUgem9uZSBsZXR0ZXIgb2YgdGhlIE1HUlMgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBuIFNlY29uZCBsZXR0ZXIgb2YgdGhlIE1HUlMgMTAwayB6b25lXG4gKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBudW1iZXIsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGVcbiAqICAgICBVVE0gem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBub3J0aGluZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGxldHRlciBhbmQgc2V0LlxuICovXG5mdW5jdGlvbiBnZXROb3J0aGluZ0Zyb21DaGFyKG4sIHNldCkge1xuXG4gIGlmIChuID4gJ1YnKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGdpdmVuIGludmFsaWQgTm9ydGhpbmcgXCIgKyBuKTtcbiAgfVxuXG4gIC8vIHJvd09yaWdpbiBpcyB0aGUgbGV0dGVyIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldCBmb3IgdGhlXG4gIC8vIGNvbHVtblxuICB2YXIgY3VyUm93ID0gU0VUX09SSUdJTl9ST1dfTEVUVEVSUy5jaGFyQ29kZUF0KHNldCAtIDEpO1xuICB2YXIgbm9ydGhpbmdWYWx1ZSA9IDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJSb3cgIT09IG4uY2hhckNvZGVBdCgwKSkge1xuICAgIGN1clJvdysrO1xuICAgIGlmIChjdXJSb3cgPT09IEkpIHtcbiAgICAgIGN1clJvdysrO1xuICAgIH1cbiAgICBpZiAoY3VyUm93ID09PSBPKSB7XG4gICAgICBjdXJSb3crKztcbiAgICB9XG4gICAgLy8gZml4aW5nIGEgYnVnIG1ha2luZyB3aG9sZSBhcHBsaWNhdGlvbiBoYW5nIGluIHRoaXMgbG9vcFxuICAgIC8vIHdoZW4gJ24nIGlzIGEgd3JvbmcgY2hhcmFjdGVyXG4gICAgaWYgKGN1clJvdyA+IFYpIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHsgLy8gbWFraW5nIHN1cmUgdGhhdCB0aGlzIGxvb3AgZW5kc1xuICAgICAgICB0aHJvdyAoXCJCYWQgY2hhcmFjdGVyOiBcIiArIG4pO1xuICAgICAgfVxuICAgICAgY3VyUm93ID0gQTtcbiAgICAgIHJld2luZE1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIG5vcnRoaW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gbm9ydGhpbmdWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gZ2V0TWluTm9ydGhpbmcgcmV0dXJucyB0aGUgbWluaW11bSBub3J0aGluZyB2YWx1ZSBvZiBhIE1HUlNcbiAqIHpvbmUuXG4gKlxuICogUG9ydGVkIGZyb20gR2VvdHJhbnMnIGMgTGF0dGl0dWRlX0JhbmRfVmFsdWUgc3RydWN0dXJlIHRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IHpvbmVMZXR0ZXIgVGhlIE1HUlMgem9uZSB0byBnZXQgdGhlIG1pbiBub3J0aGluZyBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpIHtcbiAgdmFyIG5vcnRoaW5nO1xuICBzd2l0Y2ggKHpvbmVMZXR0ZXIpIHtcbiAgY2FzZSAnQyc6XG4gICAgbm9ydGhpbmcgPSAxMTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0QnOlxuICAgIG5vcnRoaW5nID0gMjAwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdFJzpcbiAgICBub3J0aGluZyA9IDI4MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRic6XG4gICAgbm9ydGhpbmcgPSAzNzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0cnOlxuICAgIG5vcnRoaW5nID0gNDYwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdIJzpcbiAgICBub3J0aGluZyA9IDU1MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnSic6XG4gICAgbm9ydGhpbmcgPSA2NDAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0snOlxuICAgIG5vcnRoaW5nID0gNzMwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdMJzpcbiAgICBub3J0aGluZyA9IDgyMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnTSc6XG4gICAgbm9ydGhpbmcgPSA5MTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ04nOlxuICAgIG5vcnRoaW5nID0gMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdQJzpcbiAgICBub3J0aGluZyA9IDgwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdRJzpcbiAgICBub3J0aGluZyA9IDE3MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnUic6XG4gICAgbm9ydGhpbmcgPSAyNjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1MnOlxuICAgIG5vcnRoaW5nID0gMzUwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdUJzpcbiAgICBub3J0aGluZyA9IDQ0MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnVSc6XG4gICAgbm9ydGhpbmcgPSA1MzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1YnOlxuICAgIG5vcnRoaW5nID0gNjIwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdXJzpcbiAgICBub3J0aGluZyA9IDcwMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnWCc6XG4gICAgbm9ydGhpbmcgPSA3OTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgbm9ydGhpbmcgPSAtMS4wO1xuICB9XG4gIGlmIChub3J0aGluZyA+PSAwLjApIHtcbiAgICByZXR1cm4gbm9ydGhpbmc7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgKFwiSW52YWxpZCB6b25lIGxldHRlcjogXCIgKyB6b25lTGV0dGVyKTtcbiAgfVxuXG59XG5cbn0se31dLDY4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwicHJvajRcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4zLjE0XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQcm9qNGpzIGlzIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IHRvIHRyYW5zZm9ybSBwb2ludCBjb29yZGluYXRlcyBmcm9tIG9uZSBjb29yZGluYXRlIHN5c3RlbSB0byBhbm90aGVyLCBpbmNsdWRpbmcgZGF0dW0gdHJhbnNmb3JtYXRpb25zLlwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwidGVzdFwiLFxuICAgIFwiZG9jXCI6IFwiZG9jc1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiLi9ub2RlX21vZHVsZXMvaXN0YW5idWwvbGliL2NsaS5qcyB0ZXN0IC4vbm9kZV9tb2R1bGVzL21vY2hhL2Jpbi9fbW9jaGEgdGVzdC90ZXN0LmpzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzLmdpdFwiXG4gIH0sXG4gIFwiYXV0aG9yXCI6IFwiXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImphbVwiOiB7XG4gICAgXCJtYWluXCI6IFwiZGlzdC9wcm9qNC5qc1wiLFxuICAgIFwiaW5jbHVkZVwiOiBbXG4gICAgICBcImRpc3QvcHJvajQuanNcIixcbiAgICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgICBcIkFVVEhPUlNcIixcbiAgICAgIFwiTElDRU5TRS5tZFwiXG4gICAgXVxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJncnVudC1jbGlcIjogXCJ+MC4xLjEzXCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6IFwifjAuNi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjguMFwiLFxuICAgIFwiY2hhaVwiOiBcIn4xLjguMVwiLFxuICAgIFwibW9jaGFcIjogXCJ+MS4xNy4xXCIsXG4gICAgXCJncnVudC1tb2NoYS1waGFudG9tanNcIjogXCJ+MC40LjBcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJ+MTIuMC4xXCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjQuMC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIn4wLjExLjFcIixcbiAgICBcImN1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2N1am9qcy9jdXJsLmdpdFwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJ+MC4yLjRcIixcbiAgICBcInRpblwiOiBcIn4wLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIm1ncnNcIjogXCJ+MC4wLjJcIlxuICB9XG59XG59LHt9XSxcIi4vaW5jbHVkZWRQcm9qZWN0aW9uc1wiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPV9kZXJlcV8oJ2hURURwbicpO1xufSx7fV0sXCJoVEVEcG5cIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcHJvanMgPSBbXG4gX2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvdG1lcmMnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvdXRtJyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL3N0ZXJlYScpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9zdGVyZScpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9zb21lcmMnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvb21lcmMnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvbGNjJyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL2tyb3ZhaycpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9jYXNzJyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL2xhZWEnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvYWVhJyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL2dub20nKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvY2VhJyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL2VxYycpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9wb2x5JyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL256bWcnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvbWlsbCcpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9zaW51JyksXG5cdF9kZXJlcV8oJy4vbGliL3Byb2plY3Rpb25zL21vbGwnKSxcblx0X2RlcmVxXygnLi9saWIvcHJvamVjdGlvbnMvZXFkYycpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy92YW5kZycpLFxuXHRfZGVyZXFfKCcuL2xpYi9wcm9qZWN0aW9ucy9hZXFkJylcbl07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb2o0KXtcbiBwcm9qcy5mb3JFYWNoKGZ1bmN0aW9uKHByb2ope1xuICAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQocHJvaik7XG4gfSk7XG59XG59LHtcIi4vbGliL3Byb2plY3Rpb25zL2FlYVwiOjQwLFwiLi9saWIvcHJvamVjdGlvbnMvYWVxZFwiOjQxLFwiLi9saWIvcHJvamVjdGlvbnMvY2Fzc1wiOjQyLFwiLi9saWIvcHJvamVjdGlvbnMvY2VhXCI6NDMsXCIuL2xpYi9wcm9qZWN0aW9ucy9lcWNcIjo0NCxcIi4vbGliL3Byb2plY3Rpb25zL2VxZGNcIjo0NSxcIi4vbGliL3Byb2plY3Rpb25zL2dub21cIjo0NyxcIi4vbGliL3Byb2plY3Rpb25zL2tyb3Zha1wiOjQ4LFwiLi9saWIvcHJvamVjdGlvbnMvbGFlYVwiOjQ5LFwiLi9saWIvcHJvamVjdGlvbnMvbGNjXCI6NTAsXCIuL2xpYi9wcm9qZWN0aW9ucy9taWxsXCI6NTMsXCIuL2xpYi9wcm9qZWN0aW9ucy9tb2xsXCI6NTQsXCIuL2xpYi9wcm9qZWN0aW9ucy9uem1nXCI6NTUsXCIuL2xpYi9wcm9qZWN0aW9ucy9vbWVyY1wiOjU2LFwiLi9saWIvcHJvamVjdGlvbnMvcG9seVwiOjU3LFwiLi9saWIvcHJvamVjdGlvbnMvc2ludVwiOjU4LFwiLi9saWIvcHJvamVjdGlvbnMvc29tZXJjXCI6NTksXCIuL2xpYi9wcm9qZWN0aW9ucy9zdGVyZVwiOjYwLFwiLi9saWIvcHJvamVjdGlvbnMvc3RlcmVhXCI6NjEsXCIuL2xpYi9wcm9qZWN0aW9ucy90bWVyY1wiOjYyLFwiLi9saWIvcHJvamVjdGlvbnMvdXRtXCI6NjMsXCIuL2xpYi9wcm9qZWN0aW9ucy92YW5kZ1wiOjY0fV19LHt9LFszNl0pXG4oMzYpXG59KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBekJBO0FBMkJBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUExVkE7QUE2VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTdGQTtBQUNBO0FBOEZBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBckJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFqQkE7QUFDQTtBQWtCQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUF3QkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBOURBO0FBQ0E7QUErREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZUE7QUFDQTtBQURBO0FBMUNBO0FBOENBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUExMktBO0FBNDJLQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Map/Leaflet/proj4.js\n");

/***/ })

})